<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="CE2QArf5fjsQPPRbfXjtRJhVX-T6HZ1lVgKfTFby_3A">
  <meta name="baidu-site-verification" content="code-MbGHohQ17H">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hcoona.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/config.js" defer=""></script>

    <meta name="description" content="数据库系统是非常重要且复杂的系统，但是其架构方面的知识却不像其他重要的系统（例如操作系统，编译器等）一样为人所熟知。传统教材通常着重讲述数据库相关的算法和理论知识，很少涉及到系统开发和架构方面。论文[1]使用流行的商业和开源数据库系统作为例子，着重论述（关系型）数据库系统的架构。尽管有些细节方面在这些年中发生了变化，但是大体结构和思路上并没有太多出入。">
<meta property="og:type" content="article">
<meta property="og:title" content="论文笔记：[FTNDB'07] Architecture of a Database System">
<meta property="og:url" content="https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/index.html">
<meta property="og:site_name" content="HCOONa's blog">
<meta property="og:description" content="数据库系统是非常重要且复杂的系统，但是其架构方面的知识却不像其他重要的系统（例如操作系统，编译器等）一样为人所熟知。传统教材通常着重讲述数据库相关的算法和理论知识，很少涉及到系统开发和架构方面。论文[1]使用流行的商业和开源数据库系统作为例子，着重论述（关系型）数据库系统的架构。尽管有些细节方面在这些年中发生了变化，但是大体结构和思路上并没有太多出入。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hcoona.github.io/images/fntdb07-1-1.svg">
<meta property="article:published_time" content="2019-07-07T10:47:52.000Z">
<meta property="article:modified_time" content="2025-08-28T05:15:47.304Z">
<meta property="article:author" content="Shuai Zhang">
<meta property="article:tag" content="Paper Note">
<meta property="article:tag" content="Database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hcoona.github.io/images/fntdb07-1-1.svg">


<link rel="canonical" href="https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/","path":"Paper-Note/architecture-of-a-database-system/","title":"论文笔记：[FTNDB'07] Architecture of a Database System"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>论文笔记：[FTNDB'07] Architecture of a Database System | HCOONa's blog</title>
  
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FC1VDVXMFD"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-FC1VDVXMFD","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/analytics/google-analytics.js" defer=""></script>




  <script>
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "lk3wjeo70z");
</script>




  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/pangu@7.2.0/dist/browser/pangu.umd.js" integrity="sha256-JnmRRnJK7DC6RQJbAJb6AXOM9OmWzS6z8eYultk/48Y=" crossorigin="anonymous" defer=""></script>
<script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/utils.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/motion.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/sidebar.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/next-boot.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/pjax.js" defer=""></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://unpkg.com/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/tags/pdf.js" defer=""></script>



  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/fancybox.js" defer=""></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/math/mathjax.js" defer=""></script>


  <script src="https://unpkg.com/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer=""></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/"}</script>
  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/quicklink.js" defer=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="HCOONa's blog" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="HCOONa's blog" type="application/rss+xml">
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HCOONa's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">进程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">准入控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%9E%B6%E6%9E%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">并行处理架构：进程和内存的协作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86relational_query_processor"><span class="nav-number">5.</span> <span class="nav-text">关系查询处理（Relational Query Processor）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E6%9F%A5%E8%AF%A2%E8%A7%A3%E6%9E%90%E5%92%8C%E6%8E%88%E6%9D%83query_parsing_and_authorization"><span class="nav-number">5.1.</span> <span class="nav-text">查询解析和授权（Query Parsing and Authorization）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99query_rewrite"><span class="nav-number">5.2.</span> <span class="nav-text">查询重写（Query Rewrite）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96query_optimizer"><span class="nav-number">5.3.</span> <span class="nav-text">查询优化（Query Optimizer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8Cquery_executor"><span class="nav-number">5.4.</span> <span class="nav-text">查询执行（Query Executor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E8%AE%BF%E5%AD%98%E6%96%B9%E6%B3%95access_methods"><span class="nav-number">5.5.</span> <span class="nav-text">访存方法（Access Methods）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93data_warehouses"><span class="nav-number">5.6.</span> <span class="nav-text">数据仓库（Data Warehouses）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7database_extensibility"><span class="nav-number">5.7.</span> <span class="nav-text">数据库可扩展性（Database Extensibility）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E7%A9%BA%E9%97%B4%E6%8E%A7%E5%88%B6spatial_control"><span class="nav-number">6.1.</span> <span class="nav-text">空间控制（Spatial Control）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6temporal_controlbuffering"><span class="nav-number">6.2.</span> <span class="nav-text">缓存控制（Temporal Control：Buffering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86buffer_management"><span class="nav-number">6.3.</span> <span class="nav-text">缓存管理（Buffer Management）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">7.</span> <span class="nav-text">事务：并发控制和恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#_a_note_on_acid"><span class="nav-number">7.1.</span> <span class="nav-text">A Note on ACID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_a_brief_review_of_serializability"><span class="nav-number">7.2.</span> <span class="nav-text">A Brief Review of Serializability</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_locking_and_latching"><span class="nav-number">7.3.</span> <span class="nav-text">Locking and Latching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_log_manager"><span class="nav-number">7.4.</span> <span class="nav-text">Log Manager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_locking_and_logging_in_indexes"><span class="nav-number">7.5.</span> <span class="nav-text">Locking and Logging in Indexes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#_latching_in_b_trees"><span class="nav-number">7.5.1.</span> <span class="nav-text">Latching in B+-Trees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#_logging_for_physical_structures"><span class="nav-number">7.5.2.</span> <span class="nav-text">Logging for Physical Structures</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_next_key_locking_physical_surrogates_for_logical_properties"><span class="nav-number">7.6.</span> <span class="nav-text">Next-Key Locking: Physical Surrogates for Logical Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_interdependencies_of_transactional_storage"><span class="nav-number">7.7.</span> <span class="nav-text">Interdependencies of Transactional Storage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6"><span class="nav-number">8.</span> <span class="nav-text">公共组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#_catalog_manager"><span class="nav-number">8.1.</span> <span class="nav-text">Catalog Manager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_memory_allocator"><span class="nav-number">8.2.</span> <span class="nav-text">Memory Allocator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_disk_management_subsystems"><span class="nav-number">8.3.</span> <span class="nav-text">Disk Management Subsystems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_replication_services"><span class="nav-number">8.4.</span> <span class="nav-text">Replication Services</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_administration_monitoring_and_utilities"><span class="nav-number">8.5.</span> <span class="nav-text">Administration, Monitoring, and Utilities</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.</span> <span class="nav-text">标准实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.1.</span> <span class="nav-text">进程模型的标准实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#_process_per_dbms_worker"><span class="nav-number">9.1.1.</span> <span class="nav-text">Process per DBMS worker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#_thread_per_dbms_worker"><span class="nav-number">9.1.2.</span> <span class="nav-text">Thread per DBMS worker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#_processthread_pool"><span class="nav-number">9.1.3.</span> <span class="nav-text">Process/thread pool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.2.</span> <span class="nav-text">并行处理架构的标准实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.3.</span> <span class="nav-text">关系查询处理的标准实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.4.</span> <span class="nav-text">存储管理的标准实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#_%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.5.</span> <span class="nav-text">事务的标准实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#_references"><span class="nav-number">10.</span> <span class="nav-text">References</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shuai Zhang" src="//www.gravatar.com/avatar/80d20dde8a29396d8ec78af0289a3e88">
  <p class="site-author-name" itemprop="name">Shuai Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hcoona/" title="GitHub → https://github.com/hcoona/" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhangshuai89" title="ZhiHu → https://www.zhihu.com/people/zhangshuai89" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>ZhiHu</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN" data-clarity-region="article">
    <link itemprop="mainEntityOfPage" href="https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//www.gravatar.com/avatar/80d20dde8a29396d8ec78af0289a3e88">
      <meta itemprop="name" content="Shuai Zhang">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HCOONa's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="论文笔记：[FTNDB'07] Architecture of a Database System | HCOONa's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          论文笔记：[FTNDB'07] Architecture of a Database System
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-07 18:47:52" itemprop="dateCreated datePublished" datetime="2019-07-07T18:47:52+08:00">2019-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 13:15:47" itemprop="dateModified" datetime="2025-08-28T13:15:47+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Paper-Note/" itemprop="url" rel="index"><span itemprop="name">Paper Note</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><div class="paragraph">
<p>数据库系统是非常重要且复杂的系统，但是其架构方面的知识却不像其他重要的系统（例如操作系统，编译器等）一样为人所熟知。传统教材通常着重讲述数据库相关的算法和理论知识，很少涉及到系统开发和架构方面。论文<a href="#DBS-002">[1]</a>使用流行的商业和开源数据库系统作为例子，着重论述（关系型）数据库系统的架构。尽管有些细节方面在这些年中发生了变化，但是大体结构和思路上并没有太多出入。</p>
</div>
<div class="paragraph">
<p><span id="more"></span></p>
</div>
<div class="paragraph">
<p>这篇论文内容比较多，暂时先不怎么引入自己的想法，只是摘录一些重点内容，以免以后彻底遗忘论文内容。</p>
</div>
<div class="sect1">
<h2 id="_整体结构">整体结构</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数据库系统的整体结构如<a href="#fig-1-1">Figure 1</a>所示。</p>
</div>
<div id="fig-1-1" class="imageblock text-center">
<div class="content">
<img data-src="/images/fntdb07-1-1.svg" alt="fntdb07 1 1">
</div>
<div class="title">Figure 1. 数据库主要组件</div>
</div>
<div class="paragraph">
<p>以一次对数据库的请求为例：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>首先需要和数据库建立持续的连接，这部分由<a href="#fig-1-1">Figure 1</a>中最上面的组件Client Communications Manager负责。通常数据库需要支持不同的协议，例如ODBC和JDBC，TCP和本地Pipe。</p>
</li>
<li>
<p>用户连接建立后，需要为其分配线程资源，这部分由<a href="#fig-1-1">Figure 1</a>中左边的组件完成。通常Admission Control也在这个时期进行。</p>
</li>
<li>
<p>接下来用户的请求进入数据库的核心部分，通过<a href="#fig-1-1">Figure 1</a>中间的组件Relational Query Processor进行处理。</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>用户的SQL查询首先被解析成为内部表示形式，通常是对应于关系代数的表达式树。</p>
</li>
<li>
<p>接下来SQL查询会被进行优化，在此之前一般会有一个Rewrite的步骤对Query进行一些预处理以简化Optimizer的逻辑。</p>
</li>
<li>
<p>经过优化后的SQL查询可能包含多个Operator，这些Operator运算的结果还需要组合和串联，这部分工作由Plan Executor来执行。</p>
</li>
</ol>
</div>
</li>
<li>
<p>Operator的执行需要数据库底层进行支持，这部分功能由<a href="#fig-1-1">Figure 1</a>中最下面的组件Transactional Storage Manager负责。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_进程模型">进程模型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数据库是面向多用户的服务，需要具备同时服务多个用户的能力，这需要一些基础的并行执行组件。数据库一般有自己的进程抽象，这是由于大部分数据库需要支持不同的运行环境，而一些早期操作系统对于线程的支持不够好，所以需要数据库自己进行适配。这里使用进程这一名词是因为可能数据库系统可能跨越多个计算节点。</p>
</div>
<div class="paragraph">
<p>一般数据库协议采用长连接模型，连接建立后会有对应关联的Session信息，维护了当前连接执行的命令的上下文环境，例如是否正在处理Transaction等等。数据库系统一般会为一个客户端连接分配一个对应的DBMS worker进行管理。DBMS worker需要占用一定的计算资源，其采用的进程模型有以下几种情况：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Process per DBMS worker</p>
</li>
<li>
<p>Thread per DBMS worker</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>OS thread per DBMS worker</p>
</li>
<li>
<p>DBMS thread per DBMS worker</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>DBMS threads scheduled on OS process</p>
</li>
<li>
<p>DBMS threads scheduled on OS threads</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Process/thread pool</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>DBMS workers multiplexed over a process pool</p>
</li>
<li>
<p>DBMS workers multiplexed over a thread pool</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>个人认为</strong>，出现这么多模型的大部分原因是受历史因素拖累，只考虑现代操作系统（尤其是Linux）的话，由于可以较好的支持大量threads，采用这几种模型都是比较合理的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>DBMS threads scheduled on OS threads</p>
</li>
<li>
<p>DBMS workers multiplexed over a thread pool</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>有些时候，数据库还会采用自己的线程库，里面进一步封装了用户态线程（也叫做纤程Fiber）。这样做的优势是可以进一步的减少线程上下文切换带来的开销，缺点是维护成本较高，DEBUG工具和信息也比较少。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_准入控制">准入控制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>进行准入控制有以下两方面的考虑因素：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>防止一个用户占用过多资源，影响其他用户使用系统</p>
</li>
<li>
<p>拒绝用户访问没有权限访问的内容</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>数据库系统的准入控制一般有以下两个时机：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当用户请求到达时进行准入控制，避免为无效的请求分配资源</p>
</li>
<li>
<p>在执行查询计划时进行控制，因为直到这一时刻才能方便的汇总所有必要的信息，例如将要执行物理查询计划的节点的负载</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并行处理架构进程和内存的协作">并行处理架构：进程和内存的协作</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数据库系统为了性能考虑，需要更多的考虑进程和内存的协作，常见的几种模型如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Shared Memory</p>
</li>
<li>
<p>Shared-Nothing</p>
</li>
<li>
<p>Shared-Disk</p>
</li>
<li>
<p>NUMA</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>目前主流的单机数据库系统都支持了Shared Memory模型，这样做比较容易达到更高的性能。分布式的数据库系统一般使用Shared-Nothing模型，这基本上符合当前的硬件能力，即硬件并不提供（像访问本地节点数据一样可靠的）访问远程节点数据（内存/硬盘）的能力。目前一些新的硬件技术可能会打破这一假设，也是目前比较热点的一些新尝试领域。</p>
</div>
<div class="paragraph">
<p>采用Shared-Disk模型的分布式数据系统也有不少，这里假设所有进程都能以相似的代价访问共享磁盘。一些设施确实可以做到这一点，例如SAN（Storage Area Networks）。或者将更底层的软件系统视为共享磁盘使用，以此建立Shared-Disk模型的系统，例如BigTable<a href="#bigtable">[2]</a>。</p>
</div>
<div class="paragraph">
<p>NUMA尽管最早是作为分布式模型提出的，但是并没有在这一领域得到广泛的应用，反而在单机多核架构上发挥了巨大的作用。个人认为这种架构关于访问速度上的假设虽然勉强成立，但是对于可靠性方面的假设却不成立，因此很难在分布式领域得到很好的应用。主流的数据库系统在单机上一般都考虑了NUMA架构的影响。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_关系查询处理relational_query_processor">关系查询处理（Relational Query Processor）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一般而言，关系查询的处理可以视为是单用户单线程执行的任务。并发控制是在更下层进行处理的，对上层提供了几乎透明的接口。查询主要分为两大类：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>DML（Data Manipulation Language），例如SELECT/INSERT/UPDATE/DELETE</p>
</li>
<li>
<p>DDL（Data Definition Language），例如CREATE TABLE/CREATE INDEX</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_查询解析和授权query_parsing_and_authorization">查询解析和授权（Query Parsing and Authorization）</h3>
<div class="paragraph">
<p>对于一个SQL语句，解析的主要工作是</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>检查查询语句是否正确</p>
</li>
<li>
<p>获取名字和引用信息，例如 <code>SELECT c1 FROM t1 JOIN t2 ON t1.id = t2.t1id</code> 中</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>t1</code> 是Table名称，但是需要规范化为4阶段名称 <code>server.database.schema.table</code>，从而精确的定位这个表</p>
</li>
<li>
<p><code>c1</code> 是个列名，这个列是存在于 <code>t1</code> 还是 <code>t2</code> 中，也需要在这个阶段进行处理和规范化</p>
</li>
</ol>
</div>
</li>
<li>
<p>将查询转换为内部表示形式，通常是关系代数对应的内部表示形式</p>
</li>
<li>
<p>检查用户是否有权限执行这个查询</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面这些工作一般都需要和Catalog Manager进行协作以获取表相关的元信息。此外，有些运算符还需要根据这些元信息确定类型，例如 <code>(EMP.salary * 1.15) &lt; 75000</code> 中的比较运算符是整数比较，浮点数比较，还是Decimal比较，就取决于 <code>EMP.salary</code> 的类型。</p>
</div>
<div class="paragraph">
<p>有些约束也可以在这一时刻进行检查，例如 <code>SET EMP.salary = -1</code> 如果具有约束 <code>EMP.salary &gt; 0</code> 的话，就可以在这一时刻检查出来并拒绝。</p>
</div>
</div>
<div class="sect2">
<h3 id="_查询重写query_rewrite">查询重写（Query Rewrite）</h3>
<div class="paragraph">
<p>尽管有些数据库系统会将查询重写合并到上面的查询解析模块，或者下面的查询优化模块中，但是逻辑上这还是一个比较独立的功能，其主要功能是：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>视图（View）展开</p>
</li>
<li>
<p>常量计算，例如 <code>R.x &lt; 10 + 2 + R.y</code> ⇒ <code>R.x &lt; 12 + R.y</code></p>
</li>
<li>
<p>Predicate重写，例如</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>NOT Emp.salary &gt; 1000000</code> ⇒ <code>Emp.salary ⇐ 1000000</code>（节约了一个Operator）</p>
</li>
<li>
<p><code>Emp.salary &lt; 75000 AND Emp.salary &gt; 1000000</code> ⇒ <code>False</code>（这种情况一般出现于视图展开之后）</p>
</li>
<li>
<p><code>R.x &lt; 10 AND R.x = S.y</code> ⇒ <code>R.x &lt; 10 AND S.y &lt; 10 AND R.x = S.y</code>（逻辑传递关系，有可能利用 <code>S.y</code> 上的索引）</p>
</li>
</ol>
</div>
</li>
<li>
<p>语义优化，例如（常见于视图展开后）</p>
<div class="listingblock">
<div class="content">
<pre><code class="highlight sql"><span class="keyword">SELECT</span> Emp.name, Emp.salary
  <span class="keyword">FROM</span> Dept
  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Emp <span class="keyword">ON</span> Emp.deptno <span class="operator">=</span> Dept.dno</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于根本就没用到 <code>Dept</code> 表，所以可以转化成 <code>SELECT Emp.name, Emp.salary FROM Emp</code>。</p>
</div>
</li>
<li>
<p>子查询展开和其他启发式重写规则</p>
<div class="paragraph">
<p>由于查询优化是比较复杂的问题（NP-hard<a href="#optimizer-np-hard">[3]</a>)，为了保证复杂性上界，在进行查询优化时，一般不会跨越查询单元进行优化。因此在这之前，如果可能的话，将嵌套子查询重写为一个查询，会对后面的查询优化有所帮助。一般而言，在这一阶段会将所有等价的查询重写为一个标准形式。</p>
</div>
<div class="paragraph">
<p>此外还有一些基于启发式规则或者代价预估进行的优化。</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_查询优化query_optimizer">查询优化（Query Optimizer）</h3>
<div class="paragraph">
<p>查询优化的主要工作是生成查询计划，目前主流的方法是沿用Selinger等人在实现System R时使用的方法<a href="#system-r-optimizer">[4]</a>。生成的查询计划有多种表示方法。早期的数据库系统为了追求性能一般直接生成机器码；后来为了保证一定的可移植性，一般生成中间结果然后解释执行。</p>
</div>
<div class="paragraph">
<p>尽管大家都沿用了Selinger的方法，但是也做出了不少改进：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>计划空间（Plan space）。出于性能考虑，Selinger通过以下两种手段来缩减计划空间以减少计算量：只针对左偏树（left-deep tree）进行优化，推后执行笛卡尔积（Cartesian product）。但是大多数现代的数据库系统都会对这两种情况进行考虑，即同时针对左偏树和右偏树（bushy tree）进行优化，提前考虑笛卡尔积。</p>
</li>
<li>
<p>选择代价估计（Selectivity estimation）。Selinger简单的通过索引的大小估计表的大小。现代系统一般通过采样获得直方图和其他统计信息进行估计。</p>
</li>
<li>
<p>搜索算法（Search Algorithms）。一些商业数据库系统，特别是Microsoft和Tandem，没有采用Selinger的方法，而是采用一种自顶向下的搜索策略<a href="#cascade-optimizer">[5]</a>。这种搜索策略有时可以减少优化器考虑的计划数量<a href="#top-down-opt">[6]</a>，但是代价是增加优化器的内存使用量。有些系统会在搜索大量表格时会退化到使用启发式规则进行搜索的策略。</p>
</li>
<li>
<p>并发（Parallelism）。现今主流的商业数据库系统都在一定程度上支持了并发处理，并且大多支持了查询内并发。查询优化器需要知道如何在CPU之间，甚至机器之间调度这些parallelized operators。一个简单的思路是采用2级调度策略，一层只考虑在机器之间进行调度，另一层就像传统的优化器一样，只考虑机器内部的CPU之间调度。一些商业数据库系统使用了这样的策略，但是另一些没有使用2级调度，而是综合考虑了网络拓扑和数据分布进行全局调度。</p>
</li>
<li>
<p>自动调整（Auto-Tuning）。数据的特征发生变化时，进行优化的策略也需要相应发生改变。一些公司正在试图通过机器学习等手段进行数据库系统的自动调优。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>数据库系统通常会缓存一些查询计划以减少重新计算的开销。但是值得注意的是，这些缓存应该在合适的时机失效，例如做出优化决策的假设已经不复存在的时刻。</p>
</div>
</div>
<div class="sect2">
<h3 id="_查询执行query_executor">查询执行（Query Executor）</h3>
<div class="paragraph">
<p>查询计划一般是有向图的形式表示的dataflow，将表和operator联系起来。目前大多数现代查询执行引擎都采用iterator模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">iterator</span> {
  iterator &amp;inputs[];
  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;
  <span class="function">tuple <span class="title">get_next</span><span class="params">()</span></span>;
  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一个operator都继承自iterator。这样一来，operator只需关注自身逻辑即可，无需关注其上下游。</p>
</div>
<div class="paragraph">
<p>iterator模型的一个特性是数据流和控制流的强耦合，这一模型简化了不少情况下问题的处理。每调用一次 <code>get_next()</code> 方法，当其返回时，就预示着数据到达，并且调用结束，这就是数据流和控制流强耦合的情况。这样做只需一个线程即可驱动整个查询计划的执行，并且无需考虑operator之间性能匹配的问题。由于不需要进行调度和阻塞式等待，这样做也能够较为容易的达到非常高的系统利用率。而并发执行和网络通信可以通过封装exchange iterator的方式来解决<a href="#exchange-op">[7]</a>。</p>
</div>
<div class="paragraph">
<p>存取数据时，有两种可行的方法。一种是数据正在buffer pool中，此时需要pin buffer page，然后拿到这个tuple的引用进行使用，使用完毕后unpin buffer page，这种称为BP-tuples。另一种是将tuple复制出来使用，称为M-tuples。尽管M-tuples比BP-tuples容易管理，但是效率却低很多，一般只用于特殊情况，例如长查询。</p>
</div>
<div class="paragraph">
<p>大多数情况下，诸如INSERT/DELETE/UPDATE之类的写请求对应的查询计划非常简单和直接，但是有些特殊情况需要非常小心，特别是涉及到读后写的情况。例如（Halloween problem）“给每个工资低于$20K的员工涨10%的工资”，首先通过索引找到了候选tuple，然后执行更新。但是数据更新会导致索引更新，因此这个tuple执行更新语句过后如果仍然符合过滤条件，有可能会再被选中执行更新。解决的方法一种是使用临时表之类的技术彻底将读和写过程分离，另一种是使用Multi-version之类的技术避免读到更新后的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_访存方法access_methods">访存方法（Access Methods）</h3>
<div class="paragraph">
<p><a href="#fig-1-1">Figure 1</a>中最下面模块中的Access Methods。个人感觉类似于Plan Executor和Storage Engine的交叉点，也是最底层访问数据的Operator。</p>
</div>
<div class="paragraph">
<p>这里讨论了几个问题，其中一个是需要将Scan的参数传递给底层，这是出于以下考虑：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>需要利用索引</p>
</li>
<li>
<p>可以批量的pin/unpin或者copy/delete符合条件的tuples以提升性能</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此外还提到了Row ID的选择，尽管使用Physical disk address可以获得更高的性能，但是当B+-tree分裂或者tuple需要移动时就比较复杂。另一种做法就是secondary index使用primary key作为Row Id。Oracle干脆允许tuple span pages，以避免移动tuples。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数据仓库data_warehouses">数据仓库（Data Warehouses）</h3>
<div class="paragraph">
<p>数据仓库的场景（也称为OLAP场景）和OLTP的场景比较不一样，上面提到的优化过程和执行引擎的讨论需要一定的扩展和修改才能在OLAP的场景下得到更好的性能。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Bitmap Indexes</strong>。有些列，例如性别，只有固定的取值可能，使用Bitmap索引可以得到更好的性能。</p>
</li>
<li>
<p><strong>Fast Load</strong>。尽管以前OLAP可以一天导入一次，但是现在一般都希望能够更快。Bulk load可以跳过SQL解析等步骤，直接操作底层存储引擎，获得更好的性能。</p>
</li>
<li>
<p><strong>Materialized Views</strong>。可以创建物理视图，更新数据时同时更新基表和物理视图，用空间换取查询时间。</p>
</li>
<li>
<p><strong>OLAP and Ad-hoc Query Support</strong>。有些数据仓库具有固定的查询场景，因此可以预测到需要执行的语句，例如周期性执行的查询。这些场景某些程度上可以通过data cubes进行支持，类似于预计算。但是对于ad-hoc查询的支持一直是一个难题。</p>
</li>
<li>
<p><strong>Optimization of Snowflake Schema Queries</strong>。OLAP数据库的表结构一般设计成雪花形状，针对这种schema可以进行一些优化。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>特别的Column Storage可以在OLAP的场景下发挥巨大的作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数据库可扩展性database_extensibility">数据库可扩展性（Database Extensibility）</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>UDT/UDF</p>
</li>
<li>
<p>JSON/XML</p>
</li>
<li>
<p>Full-Text Search</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_存储管理">存储管理</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_空间控制spatial_control">空间控制（Spatial Control）</h3>
<div class="paragraph">
<p>众所周知，顺序存取远快于随机存取。数据库系统应当对于如何排布数据具有控制权，而且数据库系统比底层的操作系统知道更多信息，因此会比操作系统做的更好。早期的数据库系统通过直接操作裸磁盘的方式达成这一目的。但是这种方式会独占磁盘，管理和恢复数据困难，不能无痛享受其他技术（例如SAN，RAID等等），因此渐渐被其他方式所取代。目前主流的方法是分配一个大文件，然后使用 <code>mmap</code> API或者Direct I/O，Concurrent I/O之类的技术对其进行操作，模拟一块裸磁盘。</p>
</div>
</div>
<div class="sect2">
<h3 id="_缓存控制temporal_controlbuffering">缓存控制（Temporal Control：Buffering）</h3>
<div class="paragraph">
<p>除了需要控制数据的位置，数据库系统还需要控制数据合适被写入持久化存储设备，这出于以下两方面考虑：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一些数据必须立即写入持久化设备以保证正确性，例如事务的write ahead logging</p>
</li>
<li>
<p>数据库根据业务数据做了大量的缓存管理方面的工作，不需要底层操作系统也做类似的事情带来额外的开销</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_缓存管理buffer_management">缓存管理（Buffer Management）</h3>
<div class="paragraph">
<p>数据库一般使用一块内存空间（frame）和硬盘上的内容进行一一映射，这个映射不涉及到数据内容的转换以避免额外的CPU开销。这一映射关系和元数据等信息会被管理起来，其中一个重要的信息是dirty flag。如果这个frame被决定换出内存，此时根据dirty flag决定是否需要将frame写回磁盘。上面提到过的pin/unpin也会决定这个frame是否能够被换出到磁盘中。</p>
</div>
<div class="paragraph">
<p>frame根据一定的替换策略进行加载和换出，这方面的算法是过去研究的重点，例如LRU，CLOCK，LRU-2等算法。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_事务并发控制和恢复">事务：并发控制和恢复</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数据库系统中真正比较大块，拆分的不怎么清晰的地方就是事务存储管理，通常由相互纠缠的以下4个模块构成：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>并发控制中的Lock Manager</p>
</li>
<li>
<p>错误恢复中的Log Manager</p>
</li>
<li>
<p>用于分离I/O的Buffer Pool</p>
</li>
<li>
<p>在底层磁盘上管理数据的Access Methods</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_a_note_on_acid">A Note on ACID</h3>
<div class="paragraph">
<p>ACID指的是数据库系统中的事务：</p>
</div>
<div class="hdlist">
<table>
<tbody><tr>
<td class="hdlist1">
Atomicity
</td>
<td class="hdlist2">
<p>一个事务造成的改动，要么全部生效，要么全部不生效</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Consistency
</td>
<td class="hdlist2">
<p>不能违反SQL定义的约束</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Isolation
</td>
<td class="hdlist2">
<p>两个并发运行的事务之间不能相互影响</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Durability
</td>
<td class="hdlist2">
<p>一个事务一旦成功，其造成的改动——除非被另外的过程所改写——不能丢失</p>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_a_brief_review_of_serializability">A Brief Review of Serializability</h3>
<div class="paragraph">
<p>主要有三大类实现并发控制的方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Strict two-phase locking（2PL）</p>
</li>
<li>
<p>Multi-Version Concurrency Control（MVCC）</p>
</li>
<li>
<p>Optimistic Concurrency Control（OCC）</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_locking_and_latching">Locking and Latching</h3>
<div class="paragraph">
<p>数据库会自己实现一个锁控制系统，称为Locking。数据库系统会自己维护一个Lock Table记录Transaction/Lock/Object之间的关系，这样当Abort一个Transaction的时候，就能将与其关联的所有Lock都释放掉。此外，由于加锁的顺序是由用户存取数据的顺序驱动的，因此死锁检测也是一个必不可少的工作。这种锁系统主要是针对Transaction的。</p>
</div>
<div class="paragraph">
<p>数据库系统也会在访问数据结构时使用更细粒度的锁对数据及数据结构进行保护，这种锁称为Latching。一般来说Latching都是由操作系统或者硬件指令提供的基础设施，因此对于Latching的使用要避免出现死锁的情况。</p>
</div>
<div class="paragraph">
<p>ANSI SQL规定了几种隔离性级别：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>READ UNCOMMITTED</p>
</li>
<li>
<p>READ COMMITTED</p>
</li>
<li>
<p>REPEATABLE READ</p>
</li>
<li>
<p>SERIALIZABLE</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这几种隔离性级别都是在早期针对于使用锁进行隔离性控制提出的规范。现在由于MVCC和OCC的使用，一些数据库系统也提供了其他的隔离性级别：</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="5">
<li>
<p>CURSOR STABILITY</p>
</li>
<li>
<p>SNAPSHOT ISOLATION</p>
</li>
<li>
<p>READ CONSISTENCY</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_log_manager">Log Manager</h3>
<div class="paragraph">
<p>建议阅读ARIES的论文<a href="#aries">[8]</a>，其中不仅叙述了使用Logging的方法，也讨论了其他实现方法。</p>
</div>
<div class="paragraph">
<p>一般数据库系统使用Write-Ahead Logging（WAL）实现事务持久化，其要点在于以下3点规则：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>每个对数据页的修改都应该产生一条日志，这个日志必须在内存页落盘之前落盘</p>
</li>
<li>
<p>日志必须有序落盘</p>
</li>
<li>
<p>日志落盘后才能响应事务成功</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>尽管基本规则非常简单，但是实际实现为了获得更好的性能通常远比这些规则复杂。关键在于保持事务提交的 <em>fast path</em> 上高性能的同时，提供Rollback/Abort的一定性能。在考虑到特定场景优化后，日志系统将变得更为复杂。</p>
</div>
<div class="paragraph">
<p>一般数据库采用 <em>DIRECT, STEAL/NOT-FORCE</em> 这样的原则<a href="#log-opt">[9]</a>：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>数据对象原地更新</p>
</li>
<li>
<p>即便数据页上含有未提交的事务写入的数据，unpinned frame也可以被替换掉（此时如果含有脏数据，则将改动写回磁盘。可以这么做是因为可以用undo日志撤销aborted事务的改动）</p>
</li>
<li>
<p>事务commit时，无需将数据页落盘（因为写了redo日志了）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>另一方面，减少日志的大小也可以有效的增加日志系统的性能。物理操作通常含有更多和当前结构相关的数据，这些数据可以提高执行这一操作时的性能，但是写日志时可以只记录逻辑操作，抛弃这些结构相关的数据，以进一步减少日志大小，提升写入日志时的性能。例如在ARIES系统中，将物理操作记入UNDO日志中，将逻辑操作记入REDO日志中。</p>
</div>
<div class="paragraph">
<p>系统非正常停机后，再次启动时需要从日志中恢复系统的状态。使用 <em>recovery log sequence number</em> （recovery LSN），记录日志的顺序；使用 <em>checkpoint</em> 周期性的记录 recover LSN 以避免从太早的时间点开始恢复过程。最简单的办法就是把所有的数据页全都落盘，然后记录一个检查点，但是这样做性能太低了。ARIES使用了一种比较聪明的办法，以避免等待所有的数据页落盘。（没写细节）</p>
</div>
<div class="paragraph">
<p>特别需要注意的是事务Rollback也需要写WAL，如果此时磁盘空间不足的话就会导致Rollback卡住的情况。一般采用预留一部分空间的方法来避免这一情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_locking_and_logging_in_indexes">Locking and Logging in Indexes</h3>
<div class="paragraph">
<p>在Index结构上的Locking和Logging可能有不同于Transaction的策略以优化性能。</p>
</div>
<div class="sect3">
<h4 id="_latching_in_b_trees">Latching in B+-Trees</h4>
<div class="paragraph">
<p>如果使用严格的两阶段锁来保证SERIALIZABLE一致性的话，可以选择将整个B+树都锁住（锁住根节点）。但是这样一来，两个完全没有交集的事务也不能够并行运行了。常见的有以下3种策略解决这一问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>保守策略（Conservative schemes）。只有确保对数据页的访问没有任何相互影响的时候，才允许并发访问同一个数据页。例如一个操作正在遍历这个数据页，而另一个操作想要在这个数据页中进行插入操作，这样两个操作是不允许并发执行的，因为可能插入操作会导致数据页分裂。这种策略对比其他2个比较新的策略有点过于保守了。</p>
</li>
<li>
<p>Latch-coupling schemes。在遍历数据时，访问数据节点前对其加锁（Latch），只有在获取到下一个要访问的节点的锁后，才释放当前节点的锁。</p>
</li>
<li>
<p>Right-link schemes。B+树中的节点存有一个右向指针。遍历时不使用上面提到的Latch-coupling的策略，访问完一个节点之后就释放锁。由于存在这样一个右向指针，在遍历的时候就可以察觉到是否在此期间发生了树的分裂，并且可以正确的找到所需的下一个节点。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>特别的，Latch-coupling只适用于B+树，而Right-link策略比较通用<a href="#gist">[10]</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_logging_for_physical_structures">Logging for Physical Structures</h4>
<div class="paragraph">
<p>B+树的分裂可以不用UNDO，所以在记日志的时候可以标记REDO only。这种思想也可以用于其他结构的变换上，例如文件的增长等等。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_next_key_locking_physical_surrogates_for_logical_properties">Next-Key Locking: Physical Surrogates for Logical Properties</h3>
<div class="paragraph">
<p>B+树在实现Serializability事务隔离性级别时，有特殊的优化方法，这种优化方法时针对于解决“Phantom”不一致现象的。Phantom现象是这样一种现象，假设有一个查询带有一个范围谓词（predicate），例如 <code>Name BETWEEN 'Bob' AND 'Bobby'</code>，同时另一个查询向这个范围内插入了一条新的记录，例如 <code>Name = 'Bobbie'</code>，那么第一个查询就有可能在执行的过程中看到不一致的结果。这是因为在锁定记录时，没有对查询的这个范围本身加锁，导致了两个实际上有重叠的查询请求并行执行出现的异常结果（违背Serializability隔离级别）。</p>
</div>
<div class="paragraph">
<p>解决这一问题的一个方法是使用谓词锁，但是这么做代价比较高，一方面是因为判断任意两个谓词是否有交集是比较困难的，另一方面是因为基于哈希的Lock Table也很难支持这样的操作。</p>
</div>
<div class="paragraph">
<p>在B+树中可以使用这样一种方法进行优化。每次进行查询时，除了锁住自己需要的范围以外，还需要额外的多锁住一个恰好超出范围上界的元素。显然这样的方法是奏效的，并且因为B+树的结构，找到这样的下一个元素是比较容易的。</p>
</div>
<div class="paragraph">
<p>这种方法的思想是，使用一个实际存在的物理对象来代替一个不容易实现的逻辑性质。在这个例子中，下一个元素代替了扩大谓词范围来判断谓词交集问题这一抽象概念。这种技巧应当为人所知，以便在恰当的时候使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_interdependencies_of_transactional_storage">Interdependencies of Transactional Storage</h3>
<div class="paragraph">
<p>本章的开头提到过Transactional Storage是数据库系统中，子模块之间深度交缠的一个巨大的子系统，在这一节中将讨论各个子模块之间的相互依赖。</p>
</div>
<div class="paragraph">
<p>只考虑并发控制和错误恢复机制的话，就会发现常见的错误恢复机制WAL依赖于并发控制的实现方法是使用strict two-phase locking。如果使用non-strict two-phase locking的话，如果已经drop了lock，那么在rollback时候进行undo的时候，可能没办法再拿到锁。</p>
</div>
<div class="paragraph">
<p>如果再把Access Methods考虑进来的话，事情就更复杂了。Access Methods的高性能实现本身就比较复杂，考虑到并发控制和错误恢复机制时，必须和其特有的数据结构紧密结合。这就是为什么主流的数据库系统一般都只实现了B+树和堆文件，只有PostgreSQL实现了GiST。而且每种数据结构都有其特有的并发控制或者是错误恢复机制的优化技巧，即便是最简单的堆文件也有这样的特殊技巧，而这些特殊技巧是无法应用到其他数据结构上的。</p>
</div>
<div class="paragraph">
<p>在Access Methods上实现的并发控制一般只是在基于锁的实现上做的比较好。其他的并发控制方法，例如MMVC和OCC，其实并没有考虑Access Methods的特性。因此在同一个Access Methods混合使用多种不同的并发控制方法是困难的。</p>
</div>
<div class="paragraph">
<p>在Access Methods上实现错误恢复的逻辑是一个和整个子系统高度相关的事情。数据结构的变更，使用物理变更日志还是使用逻辑变更日志，这些决策都离不开整个子系统的各个细节。例如在B+树中，恢复和并发逻辑就是交织的。一方面，如果需要进行错误恢复，则需要知道B+树可能进入什么样的不一致状态，然后才能通过日志来保证Atomicity。另一方面，例如B+树节点的分裂，其实就不需要记录UNDO日志，并不需要在Rollback的时候把分裂的节点再合并回去，这就需要日志系统支持REDO-only的能力。</p>
</div>
<div class="paragraph">
<p>尽管Buffer Manager相对而言比较独立，看似和其他几个模块关联比较松散，但是这是因为我们实现了 DIRECT, STEAL/NOT-FORCE 这样的性质。而支持这些性质实际上是依赖于其他几个模块的支持的，所以Buffer Manager也跟另外几个子模块耦合在了一起。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_公共组件">公共组件</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_catalog_manager">Catalog Manager</h3>
<div class="paragraph">
<p>Catalog Manager中存放了整个数据库系统中的元数据，例如用户，Schemas，表，列，索引，等等。过去实践中的一个重要的经验是，应当使用和访问一般数据相同的方法（即SQL）来访问和修改这些元数据。这些基础的数据需要进行特殊的对待，这通常是为了性能而进行的考虑。通常使用denormalized形式直接将这些数据存放在内存中提供服务，相关的SQL语句也直接进行了预编译和缓存，甚至一些事务相关的操作也进行了特殊优化。</p>
</div>
</div>
<div class="sect2">
<h3 id="_memory_allocator">Memory Allocator</h3>
<div class="paragraph">
<p>传统的教科书对于Memory Allocator的讲解都集中在内存池的管理上。但是实际上，数据库系统也将Memory Allocator应用于很多其他方面，例如Selinger的查询优化<a href="#system-r-optimizer">[4]</a>中进行动态规划时就会使用大量的内存，更别提hashjoin和sort这种吃内存的operator了。</p>
</div>
<div class="paragraph">
<p>另一方面，数据库系统中的Memory Allocator还会使用一种 <em>context-based</em> 技术来同时增加性能和 debug 能力，其提供的基本 API 如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>使用给定的名字或者类型创建一个 Context</strong>。这个 Context 可以给 Allocator 关于被分配的内存将要用于何种用途的额外附加信息，这样 Allocator 就可以选择更合适的策略进行内存分配。例如用于 Query Optimizer 的内存每次只需要增长一点点，用于 HashJoin 的内存就是一大片一大片分配的。</p>
</li>
<li>
<p><strong>给指定的 Context 分配一块内存</strong>。类似于 <code>malloc()</code> 函数，但是是从内部的内存池中分配的。</p>
</li>
<li>
<p><strong>回收指定的 Context 已经分配的一块内存</strong>。类似于 <code>free()</code> 函数。这种用法其实比较少见，一般都是一下就将整个 Context 给回收了。</p>
</li>
<li>
<p><strong>回收指定的 Context 的所有内存</strong>。</p>
</li>
<li>
<p><strong>重置一个 Context</strong>。这种情况也会回收这个 Context 已经分配出去的所有内存，但是会保留这个 Context 的元信息，所以接下来还可以继续使用这个 Context 进行内存分配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这和传统的 jemalloc 之类的，目标是无缝替换 <code>malloc</code> 调用的内存分配器略有不同。一些场景下，例如 optimizer 可能需要构建出 plan tree，因此会多次分配小内存对象，但是在这个 phase 结束后，将整个 context 一起回收掉，而不是再去遍历数据结构去进行小心翼翼的 <code>free</code> 操作。</p>
</div>
<div class="paragraph">
<p>这种使用方式和 Garbage Collector（GC）有些相似，但是比 GC 能够提供更多的可控性。例如其还保留了 <code>free</code> 操作，而且通过 Context 在内存分配和回收上进行了很好的隔离，也能获得更好的本地性。</p>
</div>
<div class="paragraph">
<p>由于数据库系统的数据流天然就是分成多个阶段进行的，这种 Memory Allocator 的设计方式特别适合数据库系统使用。特别是有些场景下如果事先知道无需进行 <code>free</code> 操作，而是在最后将整个 Context 回收的话，就无需追踪每一块分配出去的内存的使用情况，（对于经常分配小对象的场景）可以节约很多开销。</p>
</div>
</div>
<div class="sect2">
<h3 id="_disk_management_subsystems">Disk Management Subsystems</h3>
<div class="paragraph">
<p>主要解决两类问题。一个问题是如何将数据库系统的数据和分布在不同磁盘的多个文件建立对应关系，其中每个文件可能还有大小限制。另一个问题是如何处理不同磁盘设备的特性带来的优化问题。</p>
</div>
<div class="paragraph">
<p>文件的大小和存取性能可能受操作系统，文件系统，物理设备的限制。数据库系统的数据和文件的大小也不能完全匹配，有些大的表可能一个设备上的单一文件装不下（例如早期文件系统的2GiB限制），有些小的表可能需要合并放在一个文件内。</p>
</div>
<div class="paragraph">
<p>SCSI磁盘的性能和其他特性，和其他看起来是个磁盘但是实际上不是磁盘的设备可能相差很多，例如RAID，SAN等等。即便是RAID，RAID-0和RAID-5的特性又会相差很多。</p>
</div>
</div>
<div class="sect2">
<h3 id="_replication_services">Replication Services</h3>
<div class="paragraph">
<p>做Replication的方法主要有三种，但是只有最后一种性能上比较令人满意：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Physical Replication</strong>，即定期全盘复制</p>
</li>
<li>
<p><strong>Trigger-Based Replication</strong>，使用数据库的Trigger功能</p>
</li>
<li>
<p><strong>Log-Based Replication</strong>，将数据库日志（一般指Bin-Log）近实时的写入另一个位置，然后再进行恢复。这里又有2种做法，一种是从日志中重建SQL进行回放，另一种就是直接回放数据变更。前者通用性好，可以跨不同数据库vendor进行数据复制；后者性能更高。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_administration_monitoring_and_utilities">Administration, Monitoring, and Utilities</h3>
<div class="ulist">
<ul>
<li>
<p>Optimizer Statistics Gathering</p>
</li>
<li>
<p>Physical Reorganization and Index Construction</p>
</li>
<li>
<p>Backup/Export（Fuzzy dump + logging）</p>
</li>
<li>
<p>Bulk Load（Manipulate underlying access methods）</p>
</li>
<li>
<p>Monitoring, Tuning, and Resource Governers</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_标准实践">标准实践</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这里汇总一下论文中所有提到的，流行的数据库系统在上面各个章节讨论的话题上，所采用的实现方式。</p>
</div>
<div class="sect2">
<h3 id="_进程模型的标准实践">进程模型的标准实践</h3>
<div class="sect3">
<h4 id="_process_per_dbms_worker">Process per DBMS worker</h4>
<div class="paragraph">
<p>IBM DB2 在不支持高质量的 OS Thread 的系统上默认使用 Process per DBMS worker 模式，在支持高质量 OS Thread 的系统上默认使用 Thread per DBMS worker。</p>
</div>
<div class="paragraph">
<p>Oracle 也是和 DB2 的选择一样，但是还额外支持 Process Pool。</p>
</div>
<div class="paragraph">
<p>PostgreSQL 在所有系统上都使用 Process per DBMS worker 模式。</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread_per_dbms_worker">Thread per DBMS worker</h4>
<div class="paragraph">
<p>这里还有两种变体：使用 OS thread 或者使用 DBMS thread。</p>
</div>
<div class="paragraph">
<p>IBM DB2 在操作系统支持高性能 Thread 时默认使用 OS thread。MySQL 也使用 OS thread。</p>
</div>
<div class="paragraph">
<p>DBMS thread 是数据库系统在用户态自己实现的任务调度抽象，有时也叫“纤程”（Fiber）。这里又有两种情况，一种是基于 OS Process 实现，另一种是基于 OS Thread 实现。Sybase 和 Informix 支持了基于 OS Process 的 DBMS thread。大部分数据库系统都是用 OS Process 来实现 DBMS thread，但是不是所有的系统都支持在 OS Process 之间迁移 DBMS thread。MS SQL Server 支持了 OS Thread 实现的 DBMS Thread，但是应用场景比较少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_processthread_pool">Process/thread pool</h4>
<div class="paragraph">
<p>使用 Process pool 要比 Process per DBMS worker 模式更节省内存，而且也容易 Port 到对 Thread 支持不好的 OS 上。Oracle 也将这种模式作为一种支持的选项，并且推荐在用户并发连接多时使用这种模式。Oracle 的默认模式是 Process per DBMS worker，这两种模式都能很容易的扩展到很多种类的操作系统上。</p>
</div>
<div class="paragraph">
<p>MS SQL Server 默认使用 Thread pool。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并行处理架构的标准实践">并行处理架构的标准实践</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Shared-Memory</strong>: 所有主流的商业数据库系统都支持这种模式，包括：IBM DB2，Oracle，MS SQL Server。</p>
</li>
<li>
<p><strong>Shared-Nothing</strong>: IBM DB2，Informix，Tandem，NCR Teradata 都支持这种模式；Greenplum 提供一个 PostgreSQL 支持 Shared-Nothing 模式的定制版本。</p>
</li>
<li>
<p><strong>Shared-Disk</strong>: 支持这种模式的有Oracle RAC，Oracle RDB，IBM DB2 for zSeries</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_关系查询处理的标准实践">关系查询处理的标准实践</h3>
<div class="paragraph">
<p>从粗粒度的架构来看，几乎所有的关系型数据库的查询引擎都和 System R 的原型<a href="#system-r">[11]</a>差不多。这些年相关的进展主要集中在这个框架内怎么加速更多种类的查询和Schema，主要的改进有以下几个方面：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>查询优化的搜索策略（top-down vs. bottom-up）</p>
</li>
<li>
<p>查询执行的控制流模型（iterators + exchange operator vs. asynchronous producer/consumer）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在细粒度而言，不同的厂商有很多不同的做法，涉及到 optimizer，executor 和 access methods 的综合优化来达到更好的性能，尤其是涉及到不同的 workload 类型时，例如</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>OLTP</p>
</li>
<li>
<p>decision-support for warehousing</p>
</li>
<li>
<p>OLAP</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>具体的做法都是各个厂商的“秘方”，唯一知道的就是大家做得都挺好的。</p>
</div>
<div class="paragraph">
<p>开源领域，PostgreSQL 使用了比较成熟的传统的 cost-based 的优化器，拥有一系列 execution 算法和很多商业产品中所没有的扩展功能。MySQL 的查询引擎就简单多了，基本上就是 nested-loop joins over indices。MySQL 的查询优化着力于分析型的查询，确保整个过程的轻量和高效，特别是 key/foreign-key joins，outer-join-to-join rewrite，以及只查询结果的前若干行的场景。</p>
</div>
</div>
<div class="sect2">
<h3 id="_存储管理的标准实践">存储管理的标准实践</h3>
<div class="paragraph">
<p>现在数据库系统对于底层存储的主要使用方式是这样的，直接在指定的磁盘上创建一个大文件，通过底层系统调用（例如 mmap）直接对这个文件进行操作。基本上数据库系统将这个文件视为一大块连续的数据库数据页的数组。</p>
</div>
</div>
<div class="sect2">
<h3 id="_事务的标准实践">事务的标准实践</h3>
<div class="paragraph">
<p>现如今，所有的产业级数据库系统都支持 ACID 事务，并且基本上都使用 WAL 来实现 Durability，使用 2PL 实现并发控制。PostgreSQL 是一个特例，只使用 MVCC 实现并发控制。Oracle 是一个在提供了 2PL 以外还提供 MVCC 提供其他弱一致性模型的先行者。采用 B+ 树来做索引也基本上时所有数据库系统的标准了。有些数据库系统或者通过直接提供，或者通过插件的形式，还提供了多维索引的能力。但是只有 PostgreSQL 通过其特有的 GiST <a href="#gist">[10]</a>提供了高并发的多维索引和全文索引。</p>
</div>
<div class="paragraph">
<p>MySQL 的独到之处在于其支持多种实现作为其底层存储，并且允许 DBA 为同一个数据库内的不同表指定使用不同的存储管理实现。MyISAM 只支持表级锁，但是对于读多请求的表现最好。InnoDB 提供了行级锁，适用于读写均衡的场景。但是两种存储引擎都没有实现 System R 著名的多级锁粒度支持<a href="#granularity-locks">[12]</a>，因此在某些场景下两者表现得都不是很好，例如在混合了 scan 和 high-selectivity index access 的场景。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="DBS-002"></a>[1] HELLERSTEIN J M, STONEBRAKER M, HAMILTON J. Architecture of a Database System[J]. Foundations and Trends® in Databases, 2007, 1(2): 141–259.</p>
</li>
<li>
<p><a id="bigtable"></a>[2] CHANG F, DEAN J, GHEMAWAT S, et al. Bigtable: A Distributed Storage System for Structured Data[J]. 7th USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2006: 205–218.</p>
</li>
<li>
<p><a id="optimizer-np-hard"></a>[3] IBARAKI T, KAMEDA T. On the Optimal Nesting Order for Computing N-relational Joins[J]. ACM Trans. Database Syst., New York, NY, USA: ACM, 1984, 9(3): 482–502.</p>
</li>
<li>
<p><a id="system-r-optimizer"></a>[4] SELINGER P G, ASTRAHAN M M, CHAMBERLIN D D, et al. Access Path Selection in a Relational Database Management System[C]//Proceedings of the 1979 ACM SIGMOD International Conference on Management of Data. New York, NY, USA: ACM, 1979: 23–34.</p>
</li>
<li>
<p><a id="cascade-optimizer"></a>[5] GRAEFE G. The Cascades Framework for Query Optimization[J]. IEEE Data Eng. Bull., 1995, 18(3): 19–29.</p>
</li>
<li>
<p><a id="top-down-opt"></a>[6] SHAPIRO L D, MAIER D, BENNINGHOFF P, et al. Exploiting Upper and Lower Bounds In Top-Down Query Optimization[C]//Proceedings of the International Database Engineering &amp;Amp; Applications Symposium. Washington, DC, USA: IEEE Computer Society, 2001: 20–33.</p>
</li>
<li>
<p><a id="exchange-op"></a>[7] GRAEFE G. Encapsulation of Parallelism in the Volcano Query Processing System[C]//Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data. New York, NY, USA: ACM, 1990: 102–111.</p>
</li>
<li>
<p><a id="aries"></a>[8] MOHAN C, HADERLE D, LINDSAY B, et al. ARIES: A Transaction Recovery Method Supporting Fine-granularity Locking and Partial Rollbacks Using Write-ahead Logging[J]. ACM Transactions on Database Systems, New York, NY, USA: ACM, 1992, 17(1): 94–162.</p>
</li>
<li>
<p><a id="log-opt"></a>[9] HAERDER T, REUTER A. Principles of Transaction-oriented Database Recovery[J]. ACM Comput. Surv., New York, NY, USA: ACM, 1983, 15(4): 287–317.</p>
</li>
<li>
<p><a id="gist"></a>[10] KORNACKER M, MOHAN C, HELLERSTEIN J M. Concurrency and Recovery in Generalized Search Trees[C]//Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data. New York, NY, USA: ACM, 1997: 62–72.</p>
</li>
<li>
<p><a id="system-r"></a>[11] ASTRAHAN M M, BLASGEN M W, CHAMBERLIN D D, et al. System R: Relational Approach to Database Management[J]. ACM Trans. Database Syst., New York, NY, USA: ACM, 1976, 1(2): 97–137.</p>
</li>
<li>
<p><a id="granularity-locks"></a>[12] GRAY J, LORIE R A, PUTZOLU G R, et al. Granularity of Locks and Degrees of Consistency in a Shared Data Base[C]//NIJSSEN G M. Proceeding of the {IFIP} Working Conference on Modelling in Data Base Management Systems. North-Holland, 1976: 365–394.</p>
</li>
</ul>
</div>
</div>
</div>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Shuai Zhang
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/" title="论文笔记：[FTNDB'07] Architecture of a Database System">https://hcoona.github.io/Paper-Note/architecture-of-a-database-system/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Paper-Note/" rel="tag"># Paper Note</a>
              <a href="/tags/Database/" rel="tag"># Database</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Paper-Note/percolator/" rel="prev" title="论文笔记：[OSDI'10] Large-scale Incremental Processing Using Distributed Transactions and Notifications">
                  <i class="fa fa-angle-left"></i> 论文笔记：[OSDI'10] Large-scale Incremental Processing Using Distributed Transactions and Notifications
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Paper-Note/google-slicer/" rel="next" title="论文笔记：[OSDI'16] Slicer: Auto-Sharding for Datacenter Applications">
                  论文笔记：[OSDI'16] Slicer: Auto-Sharding for Datacenter Applications <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    © 2011 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shuai Zhang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> &amp; <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>



</body></html>