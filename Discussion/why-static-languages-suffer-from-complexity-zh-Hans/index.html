<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="CE2QArf5fjsQPPRbfXjtRJhVX-T6HZ1lVgKfTFby_3A">
  <meta name="baidu-site-verification" content="code-MbGHohQ17H">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hcoona.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/config.js" defer=""></script>

    <meta name="description" content="这篇文章翻译自 Why Static Languages Suffer from Complexity，原文由 hirrolot 于 2022-01-19 发布在其个人博客。      编程语言设计社区的人们力图让语言更具“表达力”，尤其是通过强大的类型系统，以减少最终软件中的代码重复、提升易用性；然而，语言越是追求表达力，重复就越凶猛地渗入语言自身。   我称之为 静态-动态二象性（sta">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么静态语言会陷入复杂性">
<meta property="og:url" content="https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/index.html">
<meta property="og:site_name" content="HCOONa's blog">
<meta property="og:description" content="这篇文章翻译自 Why Static Languages Suffer from Complexity，原文由 hirrolot 于 2022-01-19 发布在其个人博客。      编程语言设计社区的人们力图让语言更具“表达力”，尤其是通过强大的类型系统，以减少最终软件中的代码重复、提升易用性；然而，语言越是追求表达力，重复就越凶猛地渗入语言自身。   我称之为 静态-动态二象性（sta">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/preview.jpg">
<meta property="og:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/rust-meme.png">
<meta property="og:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/chad-meme.png">
<meta property="og:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/tmp-meme.png">
<meta property="og:image" content="https://hirrolot.github.io/media/content/whats-the-point-of-the-c-preprocessor-actually/2.jpg">
<meta property="og:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/printf-meme.png">
<meta property="og:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/types-meme.png">
<meta property="article:published_time" content="2025-10-13T15:13:39.000Z">
<meta property="article:modified_time" content="2025-10-14T06:32:48.496Z">
<meta property="article:author" content="Shuai Zhang">
<meta property="article:tag" content="Programming Language">
<meta property="article:tag" content="Translation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/preview.jpg">


<link rel="canonical" href="https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/","path":"Discussion/why-static-languages-suffer-from-complexity-zh-Hans/","title":"为什么静态语言会陷入复杂性"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>为什么静态语言会陷入复杂性 | HCOONa's blog</title>
  
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FC1VDVXMFD"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-FC1VDVXMFD","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/analytics/google-analytics.js" defer=""></script>




  <script>
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "lk3wjeo70z");
</script>




  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer=""></script>
  <script src="https://unpkg.com/pangu@7.2.0/dist/browser/pangu.umd.js" integrity="sha256-JnmRRnJK7DC6RQJbAJb6AXOM9OmWzS6z8eYultk/48Y=" crossorigin="anonymous" defer=""></script>
<script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/utils.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/motion.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/sidebar.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/next-boot.js" defer=""></script><script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/pjax.js" defer=""></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://unpkg.com/pdfobject@2.3.1/pdfobject.min.js","integrity":"sha256-jI72I8ZLVflVOisZIOaLvRew3tyvzeu6aZXFm7P7dEo="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/tags/pdf.js" defer=""></script>



  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/fancybox.js" defer=""></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/math/mathjax.js" defer=""></script>


  <script src="https://unpkg.com/quicklink@3.0.1/dist/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer=""></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/"}</script>
  <script src="https://unpkg.com/hexo-theme-next@8.24.1/source/js/third-party/quicklink.js" defer=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="HCOONa's blog" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="HCOONa's blog" type="application/rss+xml">
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">HCOONa's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#_%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B_record_type%E6%95%B0%E7%BB%84_array"><span class="nav-number">1.</span> <span class="nav-text">记录类型 (Record type) — 数组 (Array)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sum-type-tree"><span class="nav-number">2.</span> <span class="nav-text">和类型 (Sum type) — 树 (Tree)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#value-associated-type"><span class="nav-number">3.</span> <span class="nav-text">值 (Value) — 关联类型 (Associated type)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recursion-type-level-induction"><span class="nav-number">4.</span> <span class="nav-text">递归 (Recursion) — 类型层归纳 (Type-level induction)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-level-logic-reified"><span class="nav-number">5.</span> <span class="nav-text">类型层逻辑实体化 (Type-level logic reified)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-unfortunate-consequences-of-being-static"><span class="nav-number">6.</span> <span class="nav-text">静态所带来的不幸后果 (The unfortunate consequences of being static)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#idris-the-way-out"><span class="nav-number">7.</span> <span class="nav-text">Idris：出路？ (Idris: The way out?)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zig-simpler-but-too-systems"><span class="nav-number">8.</span> <span class="nav-text">Zig：更简单，但过于“系统级” (Zig: Simpler, but too systems)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-words"><span class="nav-number">9.</span> <span class="nav-text">最终感言 (Final words)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#references"><span class="nav-number">10.</span> <span class="nav-text">参考文献 (References)</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shuai Zhang" src="//www.gravatar.com/avatar/80d20dde8a29396d8ec78af0289a3e88">
  <p class="site-author-name" itemprop="name">Shuai Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hcoona/" title="GitHub → https://github.com/hcoona/" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhangshuai89" title="ZhiHu → https://www.zhihu.com/people/zhangshuai89" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>ZhiHu</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_nd.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN" data-clarity-region="article">
    <link itemprop="mainEntityOfPage" href="https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//www.gravatar.com/avatar/80d20dde8a29396d8ec78af0289a3e88">
      <meta itemprop="name" content="Shuai Zhang">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HCOONa's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="为什么静态语言会陷入复杂性 | HCOONa's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          为什么静态语言会陷入复杂性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-13 23:13:39" itemprop="dateCreated datePublished" datetime="2025-10-13T23:13:39+08:00">2025-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-14 14:32:48" itemprop="dateModified" datetime="2025-10-14T14:32:48+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/Discussion/" itemprop="url" rel="index"><span itemprop="name">Discussion</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>这篇文章翻译自 <a target="_blank" rel="noopener" href="https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity.html#the-unfortunate-consequences-of-being-static">Why Static Languages Suffer from Complexity</a>，原文由 hirrolot 于 2022-01-19 发布在其个人博客。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/preview.jpg" alt="image:https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/preview"></span></p>
</div>
<div class="paragraph">
<p>编程语言设计社区的人们力图让语言更具“表达力”，尤其是通过强大的类型系统，以减少最终软件中的代码重复、提升易用性；然而，语言越是追求表达力，重复就越凶猛地渗入语言自身。</p>
</div>
<div class="paragraph">
<p>我称之为 <strong>静态-动态二象性（statics-dynamics biformity）</strong>：当你向语言引入一个新的语言学抽象时，它可能落在静态层、动态层，或者同时落在两者。前两种（只在某一层）会向语言引入 <em>不一致性</em>；后一种（两层各有一套）不可避免地引入 <em>特性二象性</em>。</p>
</div>
<div class="paragraph">
<p>在这里，<strong>静态层</strong> 是所有语言机制在编译期执行的地方；<strong>动态层</strong> 则是代码在运行期执行的地方。因此典型的控制流操作符（<code>if</code>/<code>while</code>/<code>for</code>/<code>return</code>）、数据结构与过程是动态的，而静态类型系统特性、语法宏是静态的。本质上，大多数静态语言抽象在动态空间都有对应物，反之亦然：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">动态 (Dynamics)</th>
<th class="tableblock halign-left valign-top">静态 (Statics)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Record type / Tuple / <a target="_blank" rel="noopener" href="https://beachape.com/frunk/frunk/hlist/index.html">异质列表 HList</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tree (数据结构)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sum type / <a target="_blank" rel="noopener" href="https://beachape.com/frunk/frunk/coproduct/index.html">Coproduct</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">泛型 / <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">关联类型</a> <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loop / 递归</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型层归纳 (type-level induction)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">If-then-else / 模式匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">多个 trait 实现 (multiple trait impls)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数签名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>trait F&lt;In…​&gt; { type Out; }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数实现</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>impl F&lt;…​&gt; for T { type Out = …​; }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数调用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;T as F&lt;…​&gt;&gt;::Out</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>接下来，在进一步阐述问题之前，让我展示如何用静态与动态两种方式实现逻辑等价的程序。大多数示例使用 Rust，但也适用于其它拥有足够表达力类型系统的通用语言；请记住，本文与具体实现无关，而 <strong>编程语言理论</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programming_language_theory">PLT</a>）相关。如果你很忙，可以直接跳到 <a href="#the-unfortunate-consequences-of-being-static">主章节</a> 看问题阐释。</p>
</div>
<div class="paragraph">
<p><span id="more"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_记录类型_record_type数组_array">记录类型 (Record type) — 数组 (Array)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>来看日常的记录类型操作 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=945f3a2f34937369495b3733718598a5">playground</a>):</p>
</div>
<div id="cb1" class="listingblock">
<div class="title"><code>automobile-static.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">struct</span> <span class="title class_">Automobile</span> {
    wheels: <span class="type">u8</span>,
    seats: <span class="type">u8</span>,
    manufacturer: <span class="type">String</span>,
}

<span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="keyword">let</span> <span class="variable">my_car</span> = Automobile {
        wheels: <span class="number">4</span>,
        seats: <span class="number">4</span>,
        manufacturer: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"X"</span>),
    };

    <span class="built_in">println!</span>(
        <span class="string">"My car has {} wheels and {} seats, and it was made by {}."</span>,
        my_car.wheels, my_car.seats, my_car.manufacturer
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的事可以用数组完成 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1dc3af0998b22c401a0042b081f441e1">playground</a>):</p>
</div>
<div id="cb2" class="listingblock">
<div class="title"><code>automobile-dynamic.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> std::any::Any;

<span class="meta">#[repr(usize)]</span>
<span class="keyword">enum</span> <span class="title class_">MyCar</span> {
    Wheels,
    Seats,
    Manufacturer,
}

<span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="keyword">let</span> <span class="variable">my_car</span>: [<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Any&gt;; <span class="number">3</span>] = [<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">4</span>), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">4</span>), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="string">"X"</span>)];

    <span class="built_in">println!</span>(
        <span class="string">"My car has {} wheels and {} seats, and it was made by {}."</span>,
        my_car[MyCar::Wheels <span class="keyword">as</span> <span class="type">usize</span>]
            .downcast_ref::&lt;<span class="type">i32</span>&gt;()
            .<span class="title function_ invoke__">unwrap</span>(),
        my_car[MyCar::Seats <span class="keyword">as</span> <span class="type">usize</span>].downcast_ref::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>(),
        my_car[MyCar::Manufacturer <span class="keyword">as</span> <span class="type">usize</span>]
            .downcast_ref::&lt;&amp;<span class="symbol">'static</span> <span class="type">str</span>&gt;()
            .<span class="title function_ invoke__">unwrap</span>()
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，如果对 <code>.downcast_ref</code> 指定了错误类型，就会 panic。但程序的 <strong>逻辑</strong> 不变，只是把类型检查提升到了运行期。</p>
</div>
<div class="paragraph">
<p>更进一步，我们可以用异质列表 (heterogeneous list) 来编码静态的 <code>Automobile</code>：</p>
</div>
<div id="cb3" class="listingblock">
<div class="title"><code>automobile-hlist.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> frunk::{hlist, HList};

<span class="keyword">struct</span> <span class="title class_">Wheels</span>(<span class="type">u8</span>);
<span class="keyword">struct</span> <span class="title class_">Seats</span>(<span class="type">u8</span>);
<span class="keyword">struct</span> <span class="title class_">Manufacturer</span>(<span class="type">String</span>);
<span class="keyword">type</span> <span class="title class_">Automobile</span> = HList![Wheels, Seats, Manufacturer];

<span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="keyword">let</span> <span class="variable">my_car</span>: Automobile = hlist![<span class="title function_ invoke__">Wheels</span>(<span class="number">4</span>), <span class="title function_ invoke__">Seats</span>(<span class="number">4</span>), <span class="title function_ invoke__">Manufacturer</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"X"</span>))];

    <span class="built_in">println!</span>(
        <span class="string">"My car has {} wheels and {} seats, and it was made by {}."</span>,
        my_car.get::&lt;Wheels, _&gt;().<span class="number">0</span>,
        my_car.get::&lt;Seats, _&gt;().<span class="number">0</span>,
        my_car.get::&lt;Manufacturer, _&gt;().<span class="number">0</span>
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一版本与 <code>automobile-static.rs</code> 执行了完全相同的类型检查，但还额外提供了将 <code>type Automobile</code> 当作普通集合来操作的 <a target="_blank" rel="noopener" href="https://docs.rs/frunk/0.4.0/frunk/hlist/struct.HCons.html#implementations">方法</a>！例如，我们可以反转汽车字段 <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>：</p>
</div>
<div id="cb4" class="listingblock">
<div class="content">
<pre><code class="highlight rust"><span class="built_in">assert_eq!</span>(
    my_car.<span class="title function_ invoke__">into_reverse</span>(),
    hlist![<span class="title function_ invoke__">Manufacturer</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"X"</span>)), <span class="title function_ invoke__">Seats</span>(<span class="number">4</span>), <span class="title function_ invoke__">Wheels</span>(<span class="number">4</span>)]
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者把我们的车与他们的车 zip：</p>
</div>
<div id="cb5" class="listingblock">
<div class="content">
<pre><code class="highlight rust"><span class="keyword">let</span> <span class="variable">their_car</span> = hlist![<span class="title function_ invoke__">Wheels</span>(<span class="number">6</span>), <span class="title function_ invoke__">Seats</span>(<span class="number">4</span>), <span class="title function_ invoke__">Manufacturer</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Y"</span>))];

<span class="built_in">assert_eq!</span>(
    my_car.<span class="title function_ invoke__">zip</span>(their_car),
    hlist![
        (<span class="title function_ invoke__">Wheels</span>(<span class="number">4</span>), <span class="title function_ invoke__">Wheels</span>(<span class="number">6</span>)),
        (<span class="title function_ invoke__">Seats</span>(<span class="number">4</span>), <span class="title function_ invoke__">Seats</span>(<span class="number">4</span>)),
        (<span class="title function_ invoke__">Manufacturer</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"X"</span>)), <span class="title function_ invoke__">Manufacturer</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Y"</span>)))
    ]
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>……等等。</p>
</div>
<div class="paragraph">
<p>然而，有时我们希望把类型层计算应用到普通的 <code>struct</code> 与 <code>enum</code> 上，但做不到，因为我们无法仅根据类型名称提取其定义结构（字段及其类型 / 变体及其函数签名），特别是当该类型来自外部 crate 而无法加派生宏 <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>。为解决此问题，Frunk 开发者创建了一个过程宏，通过为类型实现 <a target="_blank" rel="noopener" href="https://docs.rs/frunk/latest/frunk/generic/trait.Generic.html"><code>Generic</code></a> trait 来检查其内部结构；它有一个关联类型 <code>type Repr</code>，实现后等价于某种可操作的异质列表。尽管如此，其它没有派生该宏的类型（尤其是透明的，如 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_transfer_object">DTO</a>）仍然无法被检查，这归因于 Rust 上述的局限。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/rust-meme.png" alt="image:https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/rust-meme"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sum-type-tree">和类型 (Sum type) — 树 (Tree)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有人会觉得用和类型表示 AST 节点很好 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e5031b0c2888fe9ea336789ee1cdf049">playground</a>):</p>
</div>
<div id="cb6" class="listingblock">
<div class="title"><code>ast-static.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> std::ops::Deref;

<span class="keyword">enum</span> <span class="title class_">Expr</span> {
    <span class="title function_ invoke__">Const</span>(<span class="type">i32</span>),
    <span class="title function_ invoke__">Add</span>(<span class="type">Box</span>&lt;Expr&gt;, <span class="type">Box</span>&lt;Expr&gt;),
    <span class="title function_ invoke__">Sub</span>(<span class="type">Box</span>&lt;Expr&gt;, <span class="type">Box</span>&lt;Expr&gt;),
    <span class="title function_ invoke__">Mul</span>(<span class="type">Box</span>&lt;Expr&gt;, <span class="type">Box</span>&lt;Expr&gt;),
    <span class="title function_ invoke__">Div</span>(<span class="type">Box</span>&lt;Expr&gt;, <span class="type">Box</span>&lt;Expr&gt;),
}

<span class="keyword">use</span> Expr::*;

<span class="keyword">fn</span> <span class="title function_">eval</span>(expr: &amp;<span class="type">Box</span>&lt;Expr&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {
    <span class="keyword">match</span> expr.<span class="title function_ invoke__">deref</span>() {
        <span class="title function_ invoke__">Const</span>(x) =&gt; *x,
        <span class="title function_ invoke__">Add</span>(lhs, rhs) =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs) + <span class="title function_ invoke__">eval</span>(&amp;rhs),
        <span class="title function_ invoke__">Sub</span>(lhs, rhs) =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs) - <span class="title function_ invoke__">eval</span>(&amp;rhs),
        <span class="title function_ invoke__">Mul</span>(lhs, rhs) =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs) * <span class="title function_ invoke__">eval</span>(&amp;rhs),
        <span class="title function_ invoke__">Div</span>(lhs, rhs) =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs) / <span class="title function_ invoke__">eval</span>(&amp;rhs),
    }
}

<span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="keyword">let</span> <span class="variable">expr</span>: Expr = <span class="title function_ invoke__">Add</span>(
        <span class="title function_ invoke__">Const</span>(<span class="number">53</span>).<span class="title function_ invoke__">into</span>(),
        <span class="title function_ invoke__">Sub</span>(
            <span class="title function_ invoke__">Div</span>(<span class="title function_ invoke__">Const</span>(<span class="number">155</span>).<span class="title function_ invoke__">into</span>(), <span class="title function_ invoke__">Const</span>(<span class="number">5</span>).<span class="title function_ invoke__">into</span>()).<span class="title function_ invoke__">into</span>(),
            <span class="title function_ invoke__">Const</span>(<span class="number">113</span>).<span class="title function_ invoke__">into</span>(),
        )
        .<span class="title function_ invoke__">into</span>(),
    );

    <span class="built_in">println!</span>(<span class="string">"{}"</span>, <span class="title function_ invoke__">eval</span>(&amp;expr.<span class="title function_ invoke__">into</span>()));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的事可以用带标签的树来做 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6da60ed991ab6e6511c4572549047f62">playground</a>):</p>
</div>
<div id="cb7" class="listingblock">
<div class="title"><code>ast-dynamic.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> std::any::Any;

<span class="keyword">struct</span> <span class="title class_">Tree</span> {
    tag: <span class="type">i32</span>,
    value: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Any&gt;,
    nodes: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;Tree&gt;&gt;,
}

<span class="keyword">const</span> AST_TAG_CONST: <span class="type">i32</span> = <span class="number">0</span>;
<span class="keyword">const</span> AST_TAG_ADD: <span class="type">i32</span> = <span class="number">1</span>;
<span class="keyword">const</span> AST_TAG_SUB: <span class="type">i32</span> = <span class="number">2</span>;
<span class="keyword">const</span> AST_TAG_MUL: <span class="type">i32</span> = <span class="number">3</span>;
<span class="keyword">const</span> AST_TAG_DIV: <span class="type">i32</span> = <span class="number">4</span>;

<span class="keyword">fn</span> <span class="title function_">eval</span>(expr: &amp;Tree) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {
    <span class="keyword">let</span> <span class="variable">lhs</span> = expr.nodes.<span class="title function_ invoke__">get</span>(<span class="number">0</span>);
    <span class="keyword">let</span> <span class="variable">rhs</span> = expr.nodes.<span class="title function_ invoke__">get</span>(<span class="number">1</span>);

    <span class="keyword">match</span> expr.tag {
        AST_TAG_CONST =&gt; *expr.value.downcast_ref::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>(),
        AST_TAG_ADD =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs.<span class="title function_ invoke__">unwrap</span>()) + <span class="title function_ invoke__">eval</span>(&amp;rhs.<span class="title function_ invoke__">unwrap</span>()),
        AST_TAG_SUB =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs.<span class="title function_ invoke__">unwrap</span>()) - <span class="title function_ invoke__">eval</span>(&amp;rhs.<span class="title function_ invoke__">unwrap</span>()),
        AST_TAG_MUL =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs.<span class="title function_ invoke__">unwrap</span>()) * <span class="title function_ invoke__">eval</span>(&amp;rhs.<span class="title function_ invoke__">unwrap</span>()),
        AST_TAG_DIV =&gt; <span class="title function_ invoke__">eval</span>(&amp;lhs.<span class="title function_ invoke__">unwrap</span>()) / <span class="title function_ invoke__">eval</span>(&amp;rhs.<span class="title function_ invoke__">unwrap</span>()),
        _ =&gt; <span class="built_in">panic!</span>(<span class="string">"Out of range"</span>),
    }
}

<span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="keyword">let</span> <span class="variable">expr</span> = <span class="comment">/* Construction omitted... */</span>;

    <span class="built_in">println!</span>(<span class="string">"{}"</span>, <span class="title function_ invoke__">eval</span>(&amp;expr));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似我们对 <code>struct Automobile</code> 所做的，我们也可以用 <a target="_blank" rel="noopener" href="https://beachape.com/frunk/frunk/coproduct/enum.Coproduct.html"><code>frunk::Coproduct</code></a> 来表示 <code>enum Expr</code>。留作读者练习。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="value-associated-type">值 (Value) — 关联类型 (Associated type)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们想用标准运算符 <code>!</code> 取布尔值反 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0dea07f96037bce0e82a2c93c77898b0">playground</a>):</p>
</div>
<div id="cb8" class="listingblock">
<div class="title"><code>negate-dynamic.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="built_in">assert_eq!</span>(!<span class="literal">true</span>, <span class="literal">false</span>);
    <span class="built_in">assert_eq!</span>(!<span class="literal">false</span>, <span class="literal">true</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样可以用关联类型来完成 <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e101a1a384390a1d502aa514b21f9954">playground</a>):</p>
</div>
<div id="cb9" class="listingblock">
<div class="title"><code>negate-static.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> std::marker::PhantomData;

<span class="keyword">trait</span> <span class="title class_">Bool</span> {
    <span class="keyword">type</span> <span class="title class_">Value</span>;
}

<span class="keyword">struct</span> <span class="title class_">True</span>;
<span class="keyword">struct</span> <span class="title class_">False</span>;

<span class="keyword">impl</span> <span class="title class_">Bool</span> <span class="keyword">for</span> <span class="title class_">True</span> { <span class="keyword">type</span> <span class="title class_">Value</span> = True; }
<span class="keyword">impl</span> <span class="title class_">Bool</span> <span class="keyword">for</span> <span class="title class_">False</span> { <span class="keyword">type</span> <span class="title class_">Value</span> = False; }

<span class="keyword">struct</span> <span class="title class_">Negate</span>&lt;Cond&gt;(PhantomData&lt;Cond&gt;);

<span class="keyword">impl</span> <span class="title class_">Bool</span> <span class="keyword">for</span> <span class="title class_">Negate</span>&lt;True&gt; {
    <span class="keyword">type</span> <span class="title class_">Value</span> = False;
}

<span class="keyword">impl</span> <span class="title class_">Bool</span> <span class="keyword">for</span> <span class="title class_">Negate</span>&lt;False&gt; {
    <span class="keyword">type</span> <span class="title class_">Value</span> = True;
}

<span class="keyword">const</span> ThisIsFalse: &lt;Negate&lt;True&gt; <span class="keyword">as</span> Bool&gt;::Value = False;
<span class="keyword">const</span> ThisIsTrue: &lt;Negate&lt;False&gt; <span class="keyword">as</span> Bool&gt;::Value = True;</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，<a target="_blank" rel="noopener" href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">Rust 类型系统的图灵完备性</a> 就建立在这个原则上，再配合类型归纳（稍后可见）。每当你看到一个普通值，要知道它在类型层都有形式对应物（在计算意义上）。每当你写一个算法，它都可以在类型层用概念等价的构造来“对应”！如果你想知道 <strong>如何做到</strong>，上面那篇文章给出了 <strong>数学证明</strong>：作者先用 <em>动态层</em>（和类型、模式匹配、递归）实现一个名为 Smallfuck 的东西，再用 <em>静态层</em>（trait 逻辑、关联类型等）实现。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="recursion-type-level-induction">递归 (Recursion) — 类型层归纳 (Type-level induction)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>再看一个例子——但这次系好安全带 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4b13a54fa1a41d928508546ef741700e">playground</a>)！</p>
</div>
<div id="cb10" class="listingblock">
<div class="title"><code>peano-dynamic.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> std::ops::Deref;

<span class="meta">#[derive(Clone, Debug, PartialEq)]</span>
<span class="keyword">enum</span> <span class="title class_">Nat</span> {
    Z,
    <span class="title function_ invoke__">S</span>(<span class="type">Box</span>&lt;Nat&gt;),
}

<span class="keyword">fn</span> <span class="title function_">add</span>(lhs: &amp;<span class="type">Box</span>&lt;Nat&gt;, rhs: &amp;<span class="type">Box</span>&lt;Nat&gt;) <span class="punctuation">-&gt;</span> Nat {
    <span class="keyword">match</span> lhs.<span class="title function_ invoke__">deref</span>() {
        Nat::Z =&gt; rhs.<span class="title function_ invoke__">deref</span>().<span class="title function_ invoke__">clone</span>(), <span class="comment">// I</span>
        Nat::<span class="title function_ invoke__">S</span>(next) =&gt; Nat::<span class="title function_ invoke__">S</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">add</span>(next, rhs))), <span class="comment">// II</span>
    }
}

<span class="keyword">fn</span> <span class="title function_">main</span>() {
    <span class="keyword">let</span> <span class="variable">one</span> = Nat::<span class="title function_ invoke__">S</span>(Nat::Z.<span class="title function_ invoke__">into</span>());
    <span class="keyword">let</span> <span class="variable">two</span> = Nat::<span class="title function_ invoke__">S</span>(one.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>());
    <span class="keyword">let</span> <span class="variable">three</span> = Nat::<span class="title function_ invoke__">S</span>(two.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">into</span>());

    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(&amp;one.<span class="title function_ invoke__">into</span>(), &amp;two.<span class="title function_ invoke__">into</span>()), three);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是自然数的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Peano_axioms">Peano 编码</a>。在 <code>add</code> 函数中，我们用递归计算和，用模式匹配决定何时停止。</p>
</div>
<div class="paragraph">
<p>由于递归对应类型归纳、模式匹配对应多个实现（impl），所以同样的事可以在编译期完成 (<a target="_blank" rel="noopener" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d4c34d5ca2d4ea81c704aeb22a443e0f">playground</a>):</p>
</div>
<div id="cb11" class="listingblock">
<div class="title"><code>peano-static.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">use</span> std::marker::PhantomData;

<span class="keyword">struct</span> <span class="title class_">Z</span>;
<span class="keyword">struct</span> <span class="title class_">S</span>&lt;Next&gt;(PhantomData&lt;Next&gt;);

<span class="keyword">trait</span> <span class="title class_">Add</span>&lt;Rhs&gt; {
    <span class="keyword">type</span> <span class="title class_">Result</span>;
}

<span class="comment">// I</span>
<span class="keyword">impl</span>&lt;Rhs&gt; Add&lt;Rhs&gt; <span class="keyword">for</span> <span class="title class_">Z</span> {
    <span class="keyword">type</span> <span class="title class_">Result</span> = Rhs;
}

<span class="comment">// II</span>
<span class="keyword">impl</span>&lt;Lhs: Add&lt;Rhs&gt;, Rhs&gt; Add&lt;Rhs&gt; <span class="keyword">for</span> <span class="title class_">S</span>&lt;Lhs&gt; {
    <span class="keyword">type</span> <span class="title class_">Result</span> = S&lt;&lt;Lhs <span class="keyword">as</span> Add&lt;Rhs&gt;&gt;::<span class="type">Result</span>&gt;;
}

<span class="keyword">type</span> <span class="title class_">One</span> = S&lt;Z&gt;;
<span class="keyword">type</span> <span class="title class_">Two</span> = S&lt;One&gt;;
<span class="keyword">type</span> <span class="title class_">Three</span> = S&lt;Two&gt;;

<span class="keyword">const</span> THREE: &lt;One <span class="keyword">as</span> Add&lt;Two&gt;&gt;::<span class="type">Result</span> = <span class="title function_ invoke__">S</span>(PhantomData);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>impl …​ for Z</code> 是基例（终止条件），<code>impl …​ for S&lt; Lhs &gt;</code> 是归纳步（递归情况）——类似我们用 <code>match</code> 做的那样。归纳通过把第一个参数向 <code>Z</code> 归约来起作用：<code>&lt;Lhs as Add&lt;Rhs&gt;&gt;::Result</code> 就像 <code>add(next, rhs)</code>——再次触发“模式匹配”推进计算。注意这两个 trait 实现确实属于同一个逻辑函数；它们看似分离，是因为我们在类型层对数字 (<code>Z</code> 与 <code>S&lt;Next&gt;</code>) 做模式匹配。这与 Haskell 中的写法类似，每个模式匹配分支看上去像独立函数定义：</p>
</div>
<div id="cb12" class="listingblock">
<div class="title"><code>peano-static.hs</code></div>
<div class="content">
<pre><code class="highlight haskell"><span class="keyword">import</span> Control.Exception

<span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Z</span> | <span class="type">S</span> <span class="type">Nat</span> <span class="keyword">deriving</span> <span class="type">Eq</span></span>

<span class="title">add</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span>
<span class="title">add</span> <span class="type">Z</span> rhs = rhs <span class="comment">-- I</span>
<span class="title">add</span> (<span class="type">S</span> next) rhs = <span class="type">S</span>(add next rhs) <span class="comment">-- II</span>

<span class="title">one</span> = <span class="type">S</span> <span class="type">Z</span>
<span class="title">two</span> = <span class="type">S</span> one
<span class="title">three</span> = <span class="type">S</span> two

<span class="title">main</span> :: <span class="type">IO</span> ()
<span class="title">main</span> = assert ((add one two) == three) $ pure ()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-level-logic-reified">类型层逻辑实体化 (Type-level logic reified)</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/chad-meme.png" alt="image:https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/chad-meme"></span></p>
</div>
<div class="paragraph">
<p>本文目的只是传达静态-动态二象性的直觉，而非提供形式化证明——后者请参考一个很棒的库 <a target="_blank" rel="noopener" href="https://crates.io/crates/type-operators"><code>type-operators</code></a>（同一个实现了 Smallfuck 在类型层运行的人）。本质上，它是一个算法宏 eDSL，归结为用 trait 做类型层操作：你可以定义代数数据类型并对其执行数据操作，和你在 Rust 中常规做法类似，但最终整个代码都驻留在类型层。更多细节见其 <a target="_blank" rel="noopener" href="https://github.com/sdleffler/type-operators-rs/blob/master/src/lib.rs">翻译规则</a> 及作者写的 <a target="_blank" rel="noopener" href="https://github.com/sdleffler/type-operators-rs/blob/master/README.md">优秀指引</a>。另一个值得一提的项目是 <a target="_blank" rel="noopener" href="https://github.com/Ashymad/fortraith">Fortraith</a>，“一个在编译期把 Forth 编译为编译期 trait 表达式的‘编译期编译器’”：</p>
</div>
<div id="cb13" class="listingblock">
<div class="content">
<pre><code class="highlight rust">forth!(
    : <span class="title function_ invoke__">factorial</span> (n -- n) <span class="number">1</span> swap fact0 ;
    : <span class="title function_ invoke__">fact0</span> (n n -- n) dup <span class="number">1</span> = <span class="keyword">if</span> drop <span class="keyword">else</span> dup rot * swap pred fact0 then ;
    <span class="number">5</span> factorial .
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述代码把一个简单的阶乘实现翻译为基于 trait 与关联类型的计算。随后，你可以这样获得结果：</p>
</div>
<div id="cb14" class="listingblock">
<div class="content">
<pre><code class="highlight rust"><span class="built_in">println!</span>(
    <span class="string">"{}"</span>,
    &lt;&lt;&lt;Empty <span class="keyword">as</span> five&gt;::<span class="type">Result</span> <span class="keyword">as</span> factorial&gt;::<span class="type">Result</span> <span class="keyword">as</span> top&gt;::<span class="type">Result</span>::<span class="title function_ invoke__">eval</span>()
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>综上，无论你怎么称呼：静态还是动态，<strong>逻辑</strong> 部分保持不变。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-unfortunate-consequences-of-being-static">静态所带来的不幸后果 (The unfortunate consequences of being static)</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Are you quite sure that all those bells and whistles, all those
wonderful facilities of your so called powerful programming languages,
belong to the solution set rather than the problem set?</p>
</div>
</blockquote>
<div class="attribution">
— <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Dijkstra</a> <span class="citation">(Edsger Dijkstra, n.d.)</span>
</div>
</div>
<div class="paragraph">
<p>当今编程语言关注的不是逻辑本身，而是逻辑之下的机制；它们认为布尔取反是最简单、必须从一开始就有的操作符，但 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rfcs/issues/1834">负 trait 约束（negative trait bounds）</a> 却被视为“有很多问题”的可辩概念。大多数主流语言在标准库里支持树这种数据结构，但 sum type <a target="_blank" rel="noopener" href="https://bitbashing.io/std-visit.html">却几十年未实现</a>。我无法想象没有 <code>if</code> 的语言，但只有少数拥有完善的 trait 约束，更别提模式匹配了。这就是 <strong>不一致性</strong> ——它迫使工程师设计低质量 API：要么走动态路线只暴露少量编译期检查，要么走静态路线试图规避宿主语言根本限制，使得使用愈发晦涩。把静态与动态组合到一个工作方案里也很复杂，因为你无法在静态上下文中调用动态。套用 <a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">函数颜色</a> 的说法，动态是红色，静态是蓝色。</p>
</div>
<div class="paragraph">
<p>除了这种不一致，我们还有 <strong>特性二象性</strong>。在 C++、Haskell、Rust 等语言，这种二象性达到了最扭曲的程度；可以把任意所谓“有表达力”的语言视作两个或更多小语言拼接：C++ 语言本身与 C++ 模板/宏，Rust 语言与类型层 Rust + 声明式宏……在这种模式下，你每次在元层写点东西，都不能在宿主语言重用，反之亦然，违反 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY 原则</a>（稍后我们会看到）。此外，二象性增加学习曲线、阻碍语言演进，并最终走向特性膨胀——只有“入门教徒”才能看懂代码。看看任意 Haskell 生产代码，你会立刻看到一堆 GHC <code>#LANGUAGE</code> 子句，每一个都代表一个独立语言扩展：</p>
</div>
<div id="cb15" class="listingblock">
<div class="title"><code>feature-bloat.hs</code></div>
<div class="content">
<pre><code class="highlight haskell"><span class="meta">{-# LANGUAGE BangPatterns               #-}</span>
<span class="meta">{-# LANGUAGE CPP                        #-}</span>
<span class="meta">{-# LANGUAGE ConstraintKinds            #-}</span>
<span class="meta">{-# LANGUAGE DefaultSignatures          #-}</span>
<span class="meta">{-# LANGUAGE DeriveAnyClass             #-}</span>
<span class="meta">{-# LANGUAGE DeriveGeneric              #-}</span>
<span class="meta">{-# LANGUAGE DerivingStrategies         #-}</span>
<span class="meta">{-# LANGUAGE FlexibleContexts           #-}</span>
<span class="meta">{-# LANGUAGE FlexibleInstances          #-}</span>
<span class="meta">{-# LANGUAGE GADTs                      #-}</span>
<span class="meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="meta">{-# LANGUAGE NamedFieldPuns             #-}</span>
<span class="meta">{-# LANGUAGE OverloadedStrings          #-}</span>
<span class="meta">{-# LANGUAGE PolyKinds                  #-}</span>
<span class="meta">{-# LANGUAGE RecordWildCards            #-}</span>
<span class="meta">{-# LANGUAGE ScopedTypeVariables        #-}</span>
<span class="meta">{-# LANGUAGE TypeFamilies               #-}</span>
<span class="meta">{-# LANGUAGE UndecidableInstances       #-}</span>
<span class="meta">{-# LANGUAGE ViewPatterns               #-}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt; 改编自 <a target="_blank" rel="noopener" href="https://github.com/haskell/haskell-language-server/blob/ee0a0cc78352c961f641443eea89a26b9e1d3974/hls-plugin-api/src/Ide/Types.hs">haskell/haskell-language-server</a>。</p>
</div>
<div class="paragraph">
<p>当宿主语言没有提供足够静态能力以便于开发时，一些程序员会更加疯狂地在其之上构建全新的编译期元语言和 eDSL。于是，<strong>不一致拥有转化为二象性的诡异属性</strong>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[<strong>C++</strong>] 出现了复制 C++ 功能供元层使用的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Template_metaprogramming">模板元编程</a> 库，如 <a target="_blank" rel="noopener" href="https://github.com/boostorg/hana">Boost/Hana</a> 与 <a target="_blank" rel="noopener" href="https://github.com/boostorg/mpl">Boost/MPL</a>：</p>
<div id="cb16" class="listingblock">
<div class="title"><code>take_while.cpp</code></div>
<div class="content">
<pre><code class="highlight cpp"><span class="built_in">BOOST_HANA_CONSTANT_CHECK</span>(
    hana::<span class="built_in">take_while</span>(hana::tuple_c&lt;<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;, hana::less.<span class="built_in">than</span>(<span class="number">2</span>_c))
    ==
    hana::tuple_c&lt;<span class="type">int</span>, <span class="number">0</span>, <span class="number">1</span>&gt;
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt; 改编自 <a target="_blank" rel="noopener" href="https://github.com/boostorg/hana/blob/998033e9dba8c82e3c9496c274a3ad1acf4a2f36/example/take_while.cpp">hana/example/take_while.cpp</a>。</p>
</div>
<div id="cb17" class="listingblock">
<div class="title"><code>filter.cpp</code></div>
<div class="content">
<pre><code class="highlight cpp"><span class="keyword">constexpr</span> <span class="keyword">auto</span> is_integral =
    hana::<span class="built_in">compose</span>(hana::trait&lt;std::is_integral&gt;, hana::typeid_);

<span class="built_in">static_assert</span>(
    hana::<span class="built_in">filter</span>(hana::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4.0</span>), is_integral)
    == hana::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">3</span>), <span class="string">""</span>);
<span class="built_in">static_assert</span>(
    hana::<span class="built_in">filter</span>(hana::<span class="built_in">just</span>(<span class="number">3</span>), is_integral)
    == hana::<span class="built_in">just</span>(<span class="number">3</span>), <span class="string">""</span>);
<span class="built_in">BOOST_HANA_CONSTANT_CHECK</span>(
    hana::<span class="built_in">filter</span>(hana::<span class="built_in">just</span>(<span class="number">3.0</span>), is_integral) == hana::nothing);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt; 改编自 <a target="_blank" rel="noopener" href="https://github.com/boostorg/hana/blob/998033e9dba8c82e3c9496c274a3ad1acf4a2f36/example/filter.cpp">hana/example/filter.cpp</a>。</p>
</div>
<div id="cb18" class="listingblock">
<div class="title"><code>iter_fold.cpp</code></div>
<div class="content">
<pre><code class="highlight cpp"><span class="keyword">typedef</span> vector_c&lt;<span class="type">int</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">-5</span>, <span class="number">4</span>&gt; numbers;
<span class="keyword">typedef</span> iter_fold&lt;
    numbers,
    begin&lt;numbers&gt;::type,
    if_&lt;less&lt;deref&lt;_1&gt;, deref&lt;_2&gt;&gt;, _2, _1&gt;
&gt;::type max_element_iter;

<span class="built_in">BOOST_MPL_ASSERT_RELATION</span>(
    deref&lt;max_element_iter&gt;::type::value, ==, <span class="number">7</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt; 改编自 <a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_78_0/libs/mpl/doc/refmanual/iter-fold.html">MPL 文档</a>。</p>
</div>
</li>
<li>
<p>[<strong>C</strong>] 我自己的编译期元编程框架 <a target="_blank" rel="noopener" href="https://github.com/hirrolot/metalang99">Metalang99</a> 通过（滥）用 C 预处理器做类似事情。程度之深以至于我被迫字面意义地 <a target="_blank" rel="noopener" href="https://github.com/hirrolot/metalang99/blob/master/include/metalang99/eval/rec.h">重实现递归</a>，利用类似 Lisp 的 trampoline 与 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuation-passing_style">续延传递风格</a>（CPS）技巧。最终我在标准库里有一大堆列表函数，如 <a target="_blank" rel="noopener" href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listMap"><code>ML99_listMap</code></a>、<a target="_blank" rel="noopener" href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listIntersperse"><code>ML99_listIntersperse</code></a>、<a target="_blank" rel="noopener" href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listFoldr"><code>ML99_listFoldr</code></a>，某种意义上使 Metalang99 作为纯数据转换语言比 C 本身更“有表达力” <sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup></p>
</li>
<li>
<p>[<strong>Rust</strong>] 在第一个不一致性示例（<code>Automobile</code>）中，我们使用了 <a target="_blank" rel="noopener" href="https://docs.rs/frunk/latest/frunk/index.html">Frunk</a> 库的异质列表。不难看出 Frunk <a target="_blank" rel="noopener" href="https://github.com/lloydmeta/frunk/blob/master/core/src/hlist.rs">复制了</a> 一些集合与迭代器功能，只是为了把它们提升到类型层。若能对异质列表应用 <code>Iterator::map</code> 或 <code>Iterator::intersperse</code> 会很酷，但做不到。更糟糕的是，如果我们仍想做声明式类型层数据转换，只能维护迭代器适配器与类型层对应物的 1:1 映射；每当迭代器新增一个工具，我们的 <code>hlist</code> 就少一个工具。</p>
</li>
<li>
<p>[<strong>Rust</strong>] <a target="_blank" rel="noopener" href="https://docs.rs/typenum/latest/typenum/">Typenum</a> 是另一个流行的类型层库：通过把整数编码成泛型 <sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup> 在编译期执行整型计算。这样，语言中负责整数的部分在静态层找到了副本，引入更多二象性 <sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>。我们不能直接用 <code>(2 + 2) * 5</code> 给类型参数化，只能写成 <code>&lt;&lt;P2 as Add&lt;P2&gt;&gt;::Output as Mul&lt;P5&gt;&gt;::Output</code>！最好的办法就是写个宏替你干脏活，但那只是语法糖——你仍会面对上述 trait 带来的成堆编译错误。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/tmp-meme.png" alt="image:https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/tmp-meme"></span></p>
</div>
<div class="paragraph">
<p>有时，工程师觉得语言在动态代码里都太原始以致无法表达想法。但他们不放弃：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[<strong>Golang</strong>] <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes">Kubernetes</a>（Go 里最大代码库之一）在 <a target="_blank" rel="noopener" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime"><code>runtime</code> 包</a> 中实现了自己的 <a target="_blank" rel="noopener" href="https://medium.com/@arschles/go-experience-report-generics-in-kubernetes-25da87430301">面向对象类型系统</a>。</p>
</li>
<li>
<p>[<strong>C</strong>] <a target="_blank" rel="noopener" href="https://github.com/videolan/vlc">VLC 媒体播放器</a> 有一个基于宏的 <a target="_blank" rel="noopener" href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/include/vlc_plugin.h">插件 API</a> 来表示媒体编解码器。这里是 <a target="_blank" rel="noopener" href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/modules/codec/opus.c#L57">Opus 的定义</a>。</p>
</li>
<li>
<p>[<strong>C</strong>] <a target="_blank" rel="noopener" href="https://github.com/qemu/qemu">QEMU 模拟器</a> 构建在它的自定义 <a target="_blank" rel="noopener" href="https://github.com/qemu/qemu/tree/master/include/qapi/qmp">对象模型</a> 上：<code>QObject</code>、<code>QNum</code>、<code>QNull</code>、<code>QList</code>、<code>QString</code>、<code>QDict</code>、<code>QBool</code> 等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>回想著名的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun 第十条</a>，这种手工元语言通常“临时拼凑、非正式、漏洞百出且缓慢”，语义含糊、文档糟糕。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Metalinguistic_abstraction">元语言抽象</a> 概念根本不起作用，尽管起初“用一个高度声明式的小领域专用语言表达问题域”的理由听上去很酷。当一个问题域（或某些中间机制）用宿主语言表达时，你只需理解如何串联函数调用来完成任务——这就是所谓 API；但当该 API 用另一种语言编写时，除了调用序列，还得理解那种语言的语法与语义，这在两方面都很不幸：加重心智负担、能维护此类元语言的开发者极少。以我的经验，手工元语言倾向于迅速失控并蔓延整个代码库，使得入门更难。不仅推理受损，编译器-开发者交互也受损：你是否尝试过使用复杂的类型或宏 API？如果是，你必然熟悉那种晦涩难懂的编译器诊断，可用下面的截图概括 <sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/whats-the-point-of-the-c-preprocessor-actually/2.jpg" alt="image:https://hirrolot.github.io/media/content/whats-the-point-of-the-c-preprocessor-actually/2"></span></p>
</div>
<div class="paragraph">
<p>悲哀的是，如今“有表达力”的语言似乎意味着：“嗨，我把特性数量搞得一团糟，但没关系！”</p>
</div>
<div class="paragraph">
<p>最后，还得提一下在宿主语言里的元编程。借助 <a target="_blank" rel="noopener" href="https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial">Template Haskell</a> 与 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/procedural-macros.html">Rust 过程宏</a> 之类的模板系统，我们能用同样的语言操作宿主语言的 AST <sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>，这对减少二象性是好事，却加剧一般语言不一致。宏不是函数：我们不能对宏做部分应用并得到一个部分应用的函数（或反之），因为它们就是不同概念——如果你要设计一个泛型、易用的库 API，这会很痛。就个人而言，我确实认为 Rust 的过程宏是一个 <strong>巨大的设计失误</strong>，与 C 里的 <code>#define</code> 宏相提并论：除了纯语法外，宏系统对被操纵的语言一无所知；你得到的不是一个优雅扩展语言的工具，而只是稍微增强的文本替换而已 <sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup>。例如，设想有一个枚举 <code>Either</code>，定义如下：</p>
</div>
<div id="cb19" class="listingblock">
<div class="title"><code>either.rs</code></div>
<div class="content">
<pre><code class="highlight rust"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Either</span>&lt;L, R&gt; {
    <span class="title function_ invoke__">Left</span>(L),
    <span class="title function_ invoke__">Right</span>(R),
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&gt;&gt; 改编自 <a target="_blank" rel="noopener" href="https://docs.rs/either/latest/either/enum.Either.html">either::Either</a>。</p>
</div>
<div class="paragraph">
<p>现在设想有任意一个 trait <code>Foo</code>，我们想为 <code>Either&lt;L, R&gt;</code> 实现它，前提是 <code>L</code> 与 <code>R</code> 都实现了 <code>Foo</code>。事实是，我们不能仅凭名称给 <code>Either</code> 加一个为其实现此 trait 的派生宏，因为宏必须知道 <code>Foo</code> 的所有签名。更糟糕的是，<code>Foo</code> 可能定义在另一个库里，意味着我们无法在其定义上添加额外元信息以支持对 <code>Either&lt;L, R&gt;</code> 的派生。虽看似少见，其实并非如此；强烈建议看看 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-util/latest/tokio_util/">tokio-util</a> 的 <a target="_blank" rel="noopener" href="https://docs.rs/tokio-util/latest/tokio_util/either/enum.Either.html"><code>Either</code></a>——它与上面枚举 <strong>完全相同</strong>，但实现了 Tokio 特定的 trait，如 <code>AsyncRead</code>、<code>AsyncWrite</code>、<code>AsyncSeek</code> 等 <sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup> <span class="line-through">现在想象你的项目里来自不同库的五个不同 <code>Either</code>——那才是真正的集成噩梦！</span> <sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup> 虽然类型内省可能是折中方案，但它依旧会让语言比现在更复杂。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="idris-the-way-out">Idris：出路？ (Idris: The way out?)</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>One of the most fundamental features of Idris is that types and
expressions are part of the same language — you use the same syntax for
both.</p>
</div>
</blockquote>
<div class="attribution">
— <a target="_blank" rel="noopener" href="https://www.type-driven.org.uk/edwinb/">Edwin Brady</a>, the author of <a target="_blank" rel="noopener" href="https://www.idris-lang.org/">Idris</a> <span class="citation">(Edwin Brady, n.d.)</span>
</div>
</div>
<div class="paragraph">
<p>让我们想一想怎样绕开问题。如果我们让语言彻底动态化，可以消灭二象性与不一致性 <sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>，但会立即失去编译期验证的乐趣，最终在午夜调试程序。动态类型系统的悲惨众所周知。</p>
</div>
<div class="paragraph">
<p>唯一的途径是做一门语言，使其特性同时既是静态又是动态，而不要把同一个特性拆成两半。因此，理想的语言学抽象应当同时具备静态与动态；然而它仍是单一概念，而不是两个逻辑相似但接口不同的概念 <sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup>。一个完美例子是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Compile-time_function_execution">CTFE</a>，俗称 <code>constexpr</code>：同一份代码可以在静态上下文里于编译期执行，也可以在动态上下文里（例如从 <code>stdin</code> 请求用户输入时）运行；因此，我们不用为编译期（静态）与运行期（动态）各写一份代码，而是使用同一表示。</p>
</div>
<div class="paragraph">
<p>我见过的一个可能方案是依赖类型（dependent types）。借助依赖类型，我们可以令类型参数化不只是其它类型，还能是值。在一门依赖类型语言 <a target="_blank" rel="noopener" href="https://www.idris-lang.org/">Idris</a> 中，有一个类型叫 <code>Type</code>——代表“所有类型的类型”，从而 <strong>弱化类型层与值层的二分</strong>。拥有如此强大的东西，我们可以表达 <strong>有类型的</strong> 抽象，它们通常要么内建在语言编译器/环境，要么通过宏实现。或许最常见、最具描述性的例子是一个类型安全的 <code>printf</code>，它可即席计算其参数类型，让我们在 Idris 中享受掌握它的乐趣 <sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>！</p>
</div>
<div class="paragraph">
<p>首先，定义一个归纳数据类型 <code>Fmt</code> 及从格式字符串得到它的方法：</p>
</div>
<div id="cb20" class="listingblock">
<div class="content">
<pre><code class="highlight idris">data Fmt = FArg Fmt | FChar Char Fmt | FEnd

toFmt : (fmt : List Char) -&gt; Fmt
toFmt ('*' :: xs) = FArg (toFmt xs)
toFmt (  x :: xs) = FChar x (toFmt xs)
toFmt [] = FEnd</code></pre>
</div>
</div>
<div class="paragraph">
<p>稍后我们会用它为 <code>printf</code> 生成类型。语法很像 Haskell，读者应易于理解。</p>
</div>
<div class="paragraph">
<p>现在最有趣的部分：</p>
</div>
<div id="cb21" class="listingblock">
<div class="content">
<pre><code class="highlight idris">PrintfType : (fmt : Fmt) -&gt; Type
PrintfType (FArg fmt) = ({ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType fmt)
PrintfType (FChar _ fmt) = PrintfType fmt
PrintfType FEnd = String</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个函数做什么？它 <strong>基于输入参数</strong> <code>fmt</code> <strong>计算一个类型</strong>。像往常一样，我们把 <code>fmt</code> 拆成三个情形分别处理：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>(FArg fmt)</code>。由于 <code>FArg</code> 表示我们需要提供一个可打印实参，该分支生成一个额外参数的类型签名：</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>{ty : Type}</code> 表示 Idris 将自动推导该实参的类型 <code>ty</code>（<a target="_blank" rel="noopener" href="https://docs.idris-lang.org/en/latest/tutorial/miscellany.html#implicit-arguments">隐式参数</a>）。</p>
</li>
<li>
<p><code>Show ty</code> 是类型约束，声明 <code>ty</code> 必须实现 <code>Show</code>。</p>
</li>
<li>
<p><code>(obj : ty)</code> 是我们必须提供给 <code>printf</code> 的可打印实参。</p>
</li>
<li>
<p><code>PrintfType fmt</code> 是递归调用，处理剩余输入 <code>fmt</code>。在 Idris 中，归纳数据由归纳函数管理！</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>(FChar _ fmt)</code>。<code>FChar</code> 表示格式字符串中的普通字符，所以这里我们直接忽略它并继续 <code>PrintfType fmt</code>。</p>
</li>
<li>
<p><code>FEnd</code>。这是输入结束。我们希望 <code>printf</code> 产生 <code>String</code>，因此返回普通类型 <code>String</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在假设格式字符串为 "*x*"，即 <code>FArg (FChar ('x' (FArg FEnd)))</code>；<code>PrintfType</code> 会生成什么类型？简单：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>FArg</code>：<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType (FChar ('x' (FArg FEnd)))</code></p>
</li>
<li>
<p><code>FChar</code>：<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType (FArg FEnd)</code></p>
</li>
<li>
<p><code>FArg</code>：<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; {ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType FEnd</code></p>
</li>
<li>
<p><code>FEnd</code>：<code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; {ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; String</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>很酷，现在到了编写梦寐以求 <code>printf</code> 的时候：</p>
</div>
<div id="cb22" class="listingblock">
<div class="content">
<pre><code class="highlight idris">printf : (fmt : String) -&gt; PrintfType (toFmt $ unpack fmt)
printf fmt = printfAux (toFmt $ unpack fmt) [] where
    printfAux : (fmt : Fmt) -&gt; List Char -&gt; PrintfType fmt
    printfAux (FArg fmt) acc = \obj =&gt; printfAux fmt (acc ++ unpack (show obj))
    printfAux (FChar c fmt) acc = printfAux fmt (acc ++ [c])
    printfAux FEnd acc = pack acc</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以看到，<code>PrintfType (toFmt $ unpack fmt)</code> 出现在类型签名中，意味着整个 <code>printf</code> 的类型 <strong>依赖于输入参数</strong> <code>fmt</code>！但 <code>unpack fmt</code> 是什么？由于 <code>printf</code> 接受 <code>fmt : String</code>，我们应先把它转换为 <code>List Char</code>，因为在 <code>toFmt</code> 中我们要匹配该字符串；据我所知 Idris 不能用同样方式直接匹配普通 <code>String</code>。同理，在调用 <code>printfAux</code> 前也要 <code>unpack fmt</code>，因为它也以 <code>List Char</code> 作为结果累加器。</p>
</div>
<div class="paragraph">
<p>来查看 <code>printfAux</code> 的实现：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>(FArg fmt)</code>。这里返回一个 lambda，接收 <code>obj</code> 并对其调用 <code>show</code>，然后用 <code>++</code> 运算符追加到 <code>acc</code>。</p>
</li>
<li>
<p><code>(FChar c fmt)</code>。只需把 <code>c</code> 追加到 <code>acc</code> 并再次对 <code>fmt</code> 调用 <code>printfAux</code>。</p>
</li>
<li>
<p><code>FEnd</code>。由于 <code>acc</code> 类型是 <code>List Char</code> 而我们必须返回 <code>String</code>（根据 <code>PrintfType</code> 的最后一个分支），所以对它调用 <code>pack</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>最后，测试 <code>printf</code>：</p>
</div>
<div id="cb23" class="listingblock">
<div class="title"><code>printf.idr</code></div>
<div class="content">
<pre><code class="highlight idris">main : IO ()
main = putStrLn $ printf "Mr. John has * contacts in *." 42 "New York"</code></pre>
</div>
</div>
<div class="paragraph">
<p>它输出 <code>Mr. John has 42 contacts in "New York".</code>。但如果我们不提供 <code>42</code> 呢？</p>
</div>
<div id="cb24" class="listingblock">
<div class="content">
<pre><code class="highlight code">Error: While processing right hand side of main. When unifying:
    ?ty -&gt; PrintfType (toFmt [assert_total (prim__strIndex "Mr. John has * contacts in *." (prim__cast_IntegerInt (natToInteger (length "Mr. John has * contacts in *.")) - 1))])
and:
    String
Mismatch
between: ?ty -&gt; PrintfType (toFmt [assert_total (prim__strIndex "Mr. John has * contacts in *." (prim__cast_IntegerInt (natToInteger (length "Mr. John has * contacts in *.")) - 1))]) and String.

test:21:19--21:68
 17 |     printfAux (FChar c fmt) acc = printfAux fmt (acc ++ [c])
 18 |     printfAux FEnd acc = pack acc
 19 |
 20 | main : IO ()
 21 | main = putStrLn $ printf "Mr. John has * contacts in *." "New York"
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Warning: compiling hole Main.main</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，Idris 发现错误并产生类型不匹配！这基本上就是你用一等类型实现类型安全 <code>printf</code> 的方式。如果你好奇 Rust 中的同样东西，请看看 <a target="_blank" rel="noopener" href="https://willcrichton.net/notes/type-safe-printf/">Will Crichton 的尝试</a>，它严重依赖我们上文看到的异质列表。这种做法的缺点现在应该非常清楚：在 Rust 中，类型系统的语言与主语言不同；而在 Idris 中，它确实是同一套——这就是为什么我们可以自由地把类型层函数定义为返回 <code>Type</code> 的常规函数，并在类型签名中调用它们。此外，因为 Idris 是依赖类型的，甚至可以基于某个运行期参数计算一个类型，这在 <a target="_blank" rel="noopener" href="https://ziglang.org/">Zig</a> 之类的语言中是不可能的。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/printf-meme.png" alt="image:https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/printf-meme"></span></p>
</div>
<div class="paragraph">
<p>我已经预见了问题：用宏实现 <code>printf</code> 有什么问题？毕竟 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> 在 Rust 里运行得很好。问题在于宏。想想：为何一门编程语言需要重量级宏？因为我们可能想扩展它。我们为何想扩展它？因为语言无法满足需求：我们无法用常规语言学抽象表达某些东西，所以决定用特设元抽象扩展语言。在主体部分，我已经论述了这种方式为何糟糕——因为宏系统对被操作语言一无所知；事实上，Rust 的过程宏只是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/M4_(computer_language)">M4 预处理器</a> 的花哨名字。你们把 M4 集成进语言。当然，这 <a href="whats-the-point-of-the-c-preprocessor-actually.html">比外部 M4 好</a>，但仍是 20 世纪的方法；过程宏甚至不能操作一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象语法树</a>，因为 <a target="_blank" rel="noopener" href="https://docs.rs/syn/latest/syn/enum.Item.html"><code>syn::Item</code></a>——写过程宏常用结构——确切说是一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parse_tree">具体语法树</a>，或“解析树”。另一方面，类型是宿主语言的自然组成部分，这就是为什么如果我们能用类型表达一个程序抽象，我们就在 <strong>重用</strong> 语言学抽象，而非求助特设机械。理想情况下，语言应该没有宏，或只有轻量语法改写规则（比如 Scheme 的 <a target="_blank" rel="noopener" href="https://www2.ccs.neu.edu/racket/pubs/lasc1990-sf.pdf"><code>extend-syntax</code></a> 或 Idris 的 <a target="_blank" rel="noopener" href="https://docs.idris-lang.org/en/latest/tutorial/syntax.html">语法扩展</a>），以保持一致性并适合解决预期任务。</p>
</div>
<div class="paragraph">
<p>这么说来，Idris 通过引入 “所有类型的类型” <code>Type</code>，抹去了第一层“值-泛型”的二象性。这样也解决了许多其它对应，如递归 vs. 类型层归纳、函数 vs. trait 机制，等等；这反过来让我们即便在高度泛型代码中，也尽可能用同一门语言编程。比如，你甚至可以把类型列表表示为 <code>List Type</code>，就像 <code>List Nat</code> 或 <code>List String</code>，并照常处理！这是由于一个 <a target="_blank" rel="noopener" href="https://docs.idris-lang.org/en/latest/faq/faq.html#does-idris-have-universe-polymorphism-what-is-the-type-of-type">累积宇宙层级</a>：简单说，<code>Type</code> 的类型是 <code>Type 1</code>，<code>Type 1</code> 的类型是 <code>Type 2</code>，以此类推。由于 <a target="_blank" rel="noopener" href="https://github.com/idris-lang/Idris2/blob/0d58282087a8dce89a036e31e192af13b9199850/libs/prelude/Prelude/Basics.idr#L164"><code>Data.List</code></a> 的泛型参数 <code>a</code> “隐式” 类型为 <code>Type</code>，它既可以是 <code>Nat</code>、<code>String</code> 也可以是 <code>Type</code>；在后者情况下，<code>a</code> 会被推导为 <code>Type 1</code>。这种无限类型序列是为了避免 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Russell%27s_paradox">罗素悖论</a> 的变体，使得一个值在结构上“比它的类型更小”。</p>
</div>
<div class="paragraph">
<p>然而，Idris 并不简单。我们那二十行的 <code>printf</code> 示例已经用到“一整套特性”，诸如归纳数据类型、依赖模式匹配、隐式参数、类型约束等。此外 Idris 还具备 <a target="_blank" rel="noopener" href="http://docs.idris-lang.org/en/latest/effects/index.html">计算效应</a>、<a target="_blank" rel="noopener" href="http://docs.idris-lang.org/en/latest/elaboratorReflection/index.html">elaborator 反射</a>、余归纳（coinductive）数据类型以及用于定理证明的大量工具。面对如此繁多的类型设施，你往往在摆弄语言机器，而不是做有意义的工作。我几乎不相信以当前状态，依赖类型会在生产中大规模使用；目前在编程世界里，它们还不过是 PL 研究者与随机爱好者的玩具。仅有依赖类型实在太底层了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zig-simpler-but-too-systems">Zig：更简单，但过于“系统级” (Zig: Simpler, but too systems)</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>In Zig, types are first-class citizens. They can be assigned to
variables, passed as parameters to functions, and returned from
functions.</p>
</div>
</blockquote>
<div class="attribution">
— The Zig manual <span class="citation">(Zig developers, n.d.)</span>
</div>
</div>
<div class="paragraph">
<p>最后一位“病人”是 <a target="_blank" rel="noopener" href="https://ziglang.org/">Zig</a> 编程语言。下面是一个 Zig 的编译期 <code>printf</code> 实现（抱歉暂时没有高亮）：</p>
</div>
<div id="cb25" class="listingblock">
<div class="title"><code>printf.zig</code></div>
<div class="content">
<pre><code class="highlight zig">const std = @import("std");

fn printf(comptime fmt: []const u8, args: anytype) anyerror!void {
    const stdout = std.io.getStdOut().writer();

    comptime var arg_idx: usize = 0;

    inline for (fmt) |c| {
        if (c == '*') {
            try printArg(stdout, args[arg_idx]);
            arg_idx += 1;
        } else {
            try stdout.print("{c}", .{c});
        }
    }

    comptime {
        if (args.len != arg_idx) {
            @compileError("Unused arguments");
        }
    }
}

fn printArg(stdout: std.fs.File.Writer, arg: anytype) anyerror!void {
    if (@typeInfo(@TypeOf(arg)) == .Pointer) {
        try stdout.writeAll(arg);
    } else {
        try stdout.print("{any}", .{arg});
    }
}

pub fn main() !void {
    try printf("Mr. John has * contacts in *.\n", .{ 42, "New York" });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，我们使用了一个特性 <a target="_blank" rel="noopener" href="https://kristoff.it/blog/what-is-zig-comptime/"><code>comptime</code></a>：一个标记为 <code>comptime</code> 的函数参数 <strong>必须</strong> 在编译时已知。它不仅允许激进的优化，还打开了一座“元编程”英灵殿（Valhalla），尤其是不需要独立的宏层或类型层子语言。以上代码无需更多解释——平凡直接的逻辑对每个程序员都很清晰，不像看起来像“疯癫天才幻想产物”的 <code>printf.idr</code>。</p>
</div>
<div class="paragraph">
<p>如果我们省略 <code>42</code>，Zig 会报编译错误：</p>
</div>
<div id="cb26" class="listingblock">
<div class="content">
<pre><code class="highlight code">An error occurred:
/tmp/playground2454631537/play.zig:10:38: error: field index 1 outside tuple 'struct:33:52' which has 1 fields
            try printArg(stdout, args[arg_idx]);
                                     ^
/tmp/playground2454631537/play.zig:33:15: note: called from here
    try printf("Mr. John has * contacts in *.\n", .{ "New York" });
              ^
/tmp/playground2454631537/play.zig:32:21: note: called from here
pub fn main() !void {
                    ^</code></pre>
</div>
</div>
<div class="paragraph">
<p>我在编写 <code>printf</code> 时唯一的不便是那些 <a target="_blank" rel="noopener" href="https://gist.github.com/hirrolot/504dfe97627895c9f8f82697e27bb142">巨量错误……</a> 很像 C++ 模板。不过我承认这可以通过更显式的类型约束来解决（或至少规避）。总体上，Zig 的类型系统设计是合理的：有一个称为 <code>type</code> 的“所有类型的类型”，并且借助 <code>comptime</code>，我们可以在编译期通过普通变量、循环、过程等 <a target="_blank" rel="noopener" href="https://ikrima.dev/dev-notes/zig/zig-metaprogramming/">计算类型</a>。我们甚至可以通过内建的 <a target="_blank" rel="noopener" href="https://ziglang.org/documentation/master/#typeInfo"><code>@typeInfo</code></a>、<a target="_blank" rel="noopener" href="https://ziglang.org/documentation/master/#typeName"><code>@typeName</code></a> 与 <a target="_blank" rel="noopener" href="https://ziglang.org/documentation/master/#TypeOf"><code>@TypeOf</code></a> 做类型反射！是的，我们不再能依赖运行期值，但如果你不需要一个定理证明器，完整的依赖类型可能就是杀鸡用牛刀。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/types-meme.png" alt="image:https://hirrolot.github.io/media/content/why-static-languages-suffer-from-complexity/types-meme"></span></p>
</div>
<div class="paragraph">
<p>一切都很好，除了 Zig 是一门系统语言。在 <a target="_blank" rel="noopener" href="https://ziglang.org/">官网</a> 上，Zig 被描述为“一门通用编程语言”，但我很难同意。是的，你几乎可以用 Zig 写任何软件，但 <strong>该不该</strong>？我在 Rust 与 C99 中维护高层代码的经验告诉我：<strong>不该</strong>。第一，安全性：如果你把一门系统语言做“安全”，你会让程序员与借用检查器（borrow checker）和所有权（或等价机制）周旋——这与业务逻辑毫无关系（相信我，我懂那种痛）；否则，若你选择 C 式手工内存管理，你会让程序员花长时间调试，只希望 <code>-fsanitize=address</code> 能给点有用信息。此外，如果你想在指针之上构建新抽象，最后会得到 <code>&amp;str</code>、<code>AsRef&lt;str&gt;</code>、<code>Borrow&lt;str&gt;</code>、<code>Box&lt;str&gt;</code> 等等。拜托，我只想要一个 UTF-8 字符串；大多数时候并不关心是哪种变体。</p>
</div>
<div class="paragraph">
<p>第二个理由涉及语言运行时 <sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup>：为了使语言是“系统级”的，并避免隐藏的性能惩罚，它应当有最小化的 runtime——没有默认 GC、没有默认事件循环等，但对于特定应用（比如异步）却可能需要 runtime——因此你实际上 <strong>必须</strong> 以某种方式处理自定义 runtime 代码。这里我们会遇到一整套关于 <a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">函数颜色</a> 的问题 <sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>：例如，语言里有了 <code>async</code> 却没有工具去 <strong>抽象覆盖</strong> 同步与异步函数，这意味着你把语言分裂成两个部分：同步与异步；于是如果你有一个泛型高阶库，它将不可避免被标记为 <code>async</code> 以接受各种用户回调。要解决这个问题，你需要实现某种 <a target="_blank" rel="noopener" href="http://docs.idris-lang.org/en/latest/effects/index.html">效应多态</a>（例如 monad 或代数效应），而这仍是研究课题。高级语言天生要处理的问题更少，这就是为什么大多数软件写在 Java、C#、Python、JavaScript；在 Golang 中，概念上每个函数都是 <code>async</code>，从而 <strong>默认</strong> 促进一致性，而无需诉诸复杂类型特性。相反，Rust 已经被视为复杂语言，却仍没有标准方式编写真正泛型的异步代码。</p>
</div>
<div class="paragraph">
<p>Zig 仍可用于大型系统项目，比如浏览器、解释器与操作系统内核——没人希望这些东西意外挂起。Zig 的低层编程特性能方便地操作内存与硬件设备，而其理性的元编程方式（用得好）会孕育结构清晰的代码。把它带到高层代码只会增加心智负担而没有显著收益。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Progress is possible only if we train ourselves to think about programs
without thinking of them as pieces of executable code.</p>
</div>
</blockquote>
<div class="attribution">
— <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Dijkstra</a>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="final-words">最终感言 (Final words)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>静态语言强制编译期检查；这很好。但它们饱受特性二象性与不一致性之苦——这很糟。动态语言在这方面的痛苦较轻，但缺乏编译期检查。一个假设的解决方案应当兼取两者之长。</p>
</div>
<div class="paragraph">
<p>编程语言理应被重新思考。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">参考文献 (References)</h2>
<div class="sectionbody">
<div id="ref-dijkstra-pl-quote" class="paragraph">
<p>Edsger Dijkstra. n.d. “On the Teaching of Programming, i.e. On the Teaching of Thinking.”
<a target="_blank" rel="noopener" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD473.html" class="bare">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD473.html</a>.</p>
</div>
<div id="ref-type-dd-with-idris" class="paragraph">
<p>Edwin Brady. n.d. “Type-Driven Development with Idris.” Manning Publications Co.
<a target="_blank" rel="noopener" href="https://www.manning.com/books/type-driven-development-with-idris" class="bare">https://www.manning.com/books/type-driven-development-with-idris</a>.</p>
</div>
<div id="ref-zig-comptime-params" class="paragraph">
<p>Zig developers. n.d. “Introducing the Compile-Time Concept.”
<a target="_blank" rel="noopener" href="https://ziglang.org/documentation/0.9.0/#Introducing-the-Compile-Time-Concept" class="bare">https://ziglang.org/documentation/0.9.0/#Introducing-the-Compile-Time-Concept</a>.</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 在诸如 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Calculus_of_constructions">构造演算</a> 这样的系统中，多态函数把泛型当作 kind 为 *（“所有类型的 kind”）的普通函数参数来接受。
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. 需要给字段类型加上 <code>#[derive(Debug, PartialEq)]</code>
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. 除了不可扩展性之外，派生宏还带来 <em>紧耦合</em>：如果 <code>DeriveX</code> 放在 <code>Foo</code> 上，那么 <code>foo.rs</code> 不可避免地依赖 <code>DeriveX</code>。这会使组件迁移复杂化、拖慢编译时间并导致合并冲突。
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. 我们甚至可以在 <code>Cond</code> 上把这两个 <code>Negate</code> 实现泛化，但由于 Rust 类型系统的一个 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/20400">已知 bug</a> 目前做不到。
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. 在 C++ 社区有类似库 <a target="_blank" rel="noopener" href="http://boost.org/libs/preprocessor">Boost/Preprocessor</a>。
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. 还记得“变量-泛型”对应吗？
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. 不久前，最小可用的 <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/issues/44580">const generics</a> 已稳定。理论上可用相同整数表示替换 Typenum。
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. 写 <a target="_blank" rel="noopener" href="https://github.com/teloxide/teloxide">teloxide</a> 时遇到的，记不清了。
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. 严格来说，Rust 不能操作其真实 AST，但稍后再说。
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. <em>更新：我的意思是你可以操纵语法，但对语义一无所知。当然，Rust 宏比 C 宏方便得多，但在概念上两者几乎一样。</em>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. 更好笑的是，最初我写了一个三方 crate <a target="_blank" rel="noopener" href="https://github.com/hirrolot/tokio-either">tokio-either</a>，只包含那个 <code>Either</code> + 若干 trait 实现。后来 Tokio 维护者 <a target="_blank" rel="noopener" href="https://github.com/tokio-rs/tokio/pull/2821">决定</a> 把它移到 <code>tokio-util</code>。
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. <em>更新：我不知道 Tokio 为什么不直接为 <code>either::Either</code> 实现其 trait，就像对 <code>tokio-either</code> 那样。不管怎样，这都不能消除必须手工“派生”的混乱。</em>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. Terra 是一个很好的简单动态语言例子。在 <a target="_blank" rel="noopener" href="https://terralang.org/#simplicity">“Simplicity” 小节</a>，他们展示了静态语言特性如何以库形式在动态语言中实现。
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. 多重人格障碍？🤨
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. 完整代码见 <a target="_blank" rel="noopener" href="https://gist.github.com/hirrolot/b5b23af0dcb68cf7e87e72baf6da6ef6">我的 gist</a>。我用的是 Idris2，可在 <a target="_blank" rel="noopener" href="https://idris2.readthedocs.io/en/latest/tutorial/starting.html">这里</a> 下载。
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. 在此语境下，语言运行时是把语言语义（即其抽象机）映射到真实执行器语义的隐藏机制。
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. <em>更新：有人讨论 Zig 是否 <a target="_blank" rel="noopener" href="https://kristoff.it/blog/zig-colorblind-async-await/">无颜色</a> 或 <a target="_blank" rel="noopener" href="https://gavinhoward.com/2022/04/i-believe-zig-has-function-colors/">有颜色</a>。然而，即便 Zig 解决了函数着色问题，这也不改变我最初所说：在设计或编写系统语言时，你仍需处理在高级语言中微不足道的问题。</em>
</div>
</div>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Shuai Zhang
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/" title="为什么静态语言会陷入复杂性">https://hcoona.github.io/Discussion/why-static-languages-suffer-from-complexity-zh-Hans/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Programming-Language/" rel="tag"># Programming Language</a>
              <a href="/tags/Translation/" rel="tag"># Translation</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Discussion/orgdown-translation-zh-hans/" rel="prev" title="[翻译]Orgdown —— 文本文档全新轻量级标记标准">
                  <i class="fa fa-angle-left"></i> [翻译]Orgdown —— 文本文档全新轻量级标记标准
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    © 2011 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shuai Zhang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> &amp; <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>



</body></html>