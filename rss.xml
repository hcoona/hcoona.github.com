<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>HCOONa&#39;s blog</title>
    <link>http://hcoona.github.io/</link>
    
    <atom:link href="http://hcoona.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 28 Aug 2025 05:45:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[翻译] Monadic parsing in Haskell</title>
      <link>http://hcoona.github.io/Parser-Combinators/monadic-parsing-in-haskell-translation/</link>
      <guid>http://hcoona.github.io/Parser-Combinators/monadic-parsing-in-haskell-translation/</guid>
      <pubDate>Tue, 26 Aug 2025 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;这是对 &lt;a href=&quot;https://doi.org/10.1017/S0956796898003050&quot;&gt;&lt;em&gt;Monadic parsing in Haskell&lt;/em&gt;&lt;/a&gt; 一文的翻译。&lt;/p&gt;
&lt;h2 id=&quot;引言（Introduction）&quot;&gt;&lt;a href=&quot;#引言（Introduction）&quot; class=&quot;headerlink&quot; title=&quot;引言（Introduction）&quot;&gt;&lt;/a&gt;引言（Introduction）&lt;/h2&gt;&lt;p&gt;本文是一篇关于在 Haskell 中定义递归下降解析器（recursive descent parsers）的教程。秉持“一站式服务”的精神，文章把三个领域的材料整合到一个来源中。这三个领域分别是函数式解析器（functional parsers）（Burge, 1975; Wadler, 1985; Hutton, 1992; Fokker, 1995）、使用单子（monads）来组织函数式程序（Wadler, 1990, 1992a, 1992b），以及在 Haskell 中用于单子程序的特殊语法（Jones, 1995; Peterson 等, 1996）。更具体地说，本文展示了如何在 Haskell 中使用 &lt;code&gt;do&lt;/code&gt; 记法（&lt;code&gt;do&lt;/code&gt; notation）来定义单子解析器。&lt;/p&gt;
&lt;p&gt;当然，手写的递归下降解析器在效率上不如由工具生成的自底向上解析器（Aho 等, 1986; Mogensen, 1993; Gill 与 Marlow, 1995）。然而，对于许多研究型应用，一个简单的递归下降解析器已足够。此外，解析器生成器通常仅提供一套固定的组合子（combinators）来描述文法，而本文的方法则完全可扩展：解析器是第一类值（first-class values），我们可以充分利用 Haskell 的能力来为特定应用定义新的组合子。该方法也是展示函数式编程优雅性的一个极佳例子。&lt;/p&gt;
&lt;p&gt;本文的目标读者是熟悉 Haskell 并且学过“文法与解析”课程的优秀本科生。具备一些函数式解析器的知识会有帮助，但不要求具备单子方面的经验。基于本文而来的一个 Haskell 库可在网页上获取： &lt;a href=&quot;http://www.cs.nott.ac.uk/Department/Staff/gmh/bib.html#pearl&quot;&gt;http://www.cs.nott.ac.uk/Department/Staff/gmh/bib.html#pearl&lt;/a&gt;（链接已失效）&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这是对 <a href="https://doi.org/10.1017/S0956796898003050"><em>Monadic parsing in Haskell</em></a> 一文的翻译。</p><h2 id="引言（Introduction）"><a href="#引言（Introduction）" class="headerlink" title="引言（Introduction）"></a>引言（Introduction）</h2><p>本文是一篇关于在 Haskell 中定义递归下降解析器（recursive descent parsers）的教程。秉持“一站式服务”的精神，文章把三个领域的材料整合到一个来源中。这三个领域分别是函数式解析器（functional parsers）（Burge, 1975; Wadler, 1985; Hutton, 1992; Fokker, 1995）、使用单子（monads）来组织函数式程序（Wadler, 1990, 1992a, 1992b），以及在 Haskell 中用于单子程序的特殊语法（Jones, 1995; Peterson 等, 1996）。更具体地说，本文展示了如何在 Haskell 中使用 <code>do</code> 记法（<code>do</code> notation）来定义单子解析器。</p><p>当然，手写的递归下降解析器在效率上不如由工具生成的自底向上解析器（Aho 等, 1986; Mogensen, 1993; Gill 与 Marlow, 1995）。然而，对于许多研究型应用，一个简单的递归下降解析器已足够。此外，解析器生成器通常仅提供一套固定的组合子（combinators）来描述文法，而本文的方法则完全可扩展：解析器是第一类值（first-class values），我们可以充分利用 Haskell 的能力来为特定应用定义新的组合子。该方法也是展示函数式编程优雅性的一个极佳例子。</p><p>本文的目标读者是熟悉 Haskell 并且学过“文法与解析”课程的优秀本科生。具备一些函数式解析器的知识会有帮助，但不要求具备单子方面的经验。基于本文而来的一个 Haskell 库可在网页上获取： <a href="http://www.cs.nott.ac.uk/Department/Staff/gmh/bib.html#pearl">http://www.cs.nott.ac.uk/Department/Staff/gmh/bib.html#pearl</a>（链接已失效）</p><span id="more"></span><h2 id="解析器的类型（A-type-for-parsers）"><a href="#解析器的类型（A-type-for-parsers）" class="headerlink" title="解析器的类型（A type for parsers）"></a>解析器的类型（A type for parsers）</h2><p>我们先为解析器（parser）定义一个类型：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Parser</span> a = <span class="type">Parser</span> (<span class="type">String</span> -&gt; [(<span class="title">a</span>,<span class="type">String</span>)])</span></span><br></pre></td></tr></table></figure><p>也就是说，解析器是一个以字符字符串为参数并返回结果列表的函数。约定是：空结果列表表示解析器失败，而非空列表表示成功。成功时，每个结果是一个二元组，其第一分量是通过解析和处理参数字符串前缀得到的类型为 <code>a</code> 的值，第二分量是未被解析的参数字符串后缀。返回结果列表使我们能够为二义性文法（ambiguous grammars）构建解析器：当参数字符串可被多种方式解析时，将返回多个结果。</p><h2 id="一个解析器的单子（A-monad-of-parsers）"><a href="#一个解析器的单子（A-monad-of-parsers）" class="headerlink" title="一个解析器的单子（A monad of parsers）"></a>一个解析器的单子（A monad of parsers）</h2><p>我们定义的第一个解析器是 <code>item</code>：如果参数字符串非空，它会成功地消费第一个字符；否则失败：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">item</span> :: <span class="type">Parser</span> <span class="type">Char</span></span><br><span class="line"><span class="title">item</span>  = <span class="type">Parser</span> (\cs -&gt; <span class="keyword">case</span> cs <span class="keyword">of</span></span><br><span class="line">                          <span class="string">&quot;&quot;</span> -&gt; []</span><br><span class="line">                          (c:cs) -&gt; [(c,cs)])</span><br></pre></td></tr></table></figure><p>接着我们定义两个反映解析器单子本质的组合子。在 Haskell 中，“单子（monad）”这一概念由一个内置的类定义来刻画：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">   return :: a -&gt; m a</span><br><span class="line">   (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure><p>也就是说，如果一个类型构造器（type constructor）<code>m</code>配备了具有上述类型的 <code>return</code> 与 <code>(&gt;&gt;=)</code> 函数，那么它就是类 <code>Monad</code> 的成员。类型构造器 <code>Parser</code> 可以如下成为 <code>Monad</code> 类的一个实例（instance）：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Parser</span> <span class="keyword">where</span></span></span><br><span class="line">   return a = <span class="type">Parser</span> (\cs -&gt; [(a,cs)])</span><br><span class="line">   p &gt;&gt;= f = <span class="type">Parser</span> (\cs -&gt; concat [parse (f a) cs&#x27; |</span><br><span class="line">                               (a,cs&#x27;) &lt;- parse p cs])</span><br></pre></td></tr></table></figure><p>解析器 <code>return a</code> 在不消费任何参数字符串的情况下成功，并返回单个值 <code>a</code>。操作符 <code>(&gt;&gt;=)</code> 是解析器的一个“序列操作符（sequencing operator）”。使用由 <code>parse (Parser p) = p</code> 定义的解析器解构函数（deconstructor），解析器 <code>p &gt;&gt;= f</code> 首先将解析器 <code>p</code> 应用于参数字符串 <code>cs</code>，得到形如 <code>(a,cs&#39;)</code> 的结果列表，其中 <code>a</code> 是一个值，<code>cs&#39;</code> 是一个字符串。对每个这样的二元组，<code>f a</code> 是一个解析器，被应用到字符串 <code>cs&#39;</code> 上。结果是一个列表的列表，随后被拼接（concatenate）为最终的结果列表。</p><p>用于解析器的 <code>return</code> 与 <code>(&gt;&gt;=)</code> 满足一些简单的定律：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">           return a &gt;&gt;= f ＝ f a</span><br><span class="line">             p &gt;&gt;= return ＝ p</span><br><span class="line">p &gt;&gt;= (\a -&gt; (f a &gt;&gt;= g)) ＝ (p &gt;&gt;= (\a -&gt; f a)) &gt;&gt;= g</span><br></pre></td></tr></table></figure><p>事实上，这些定律对任何单子都必须成立，而不仅仅是解析器这个特例。这些定律断言 —— 忽略右参数传给 <code>(&gt;&gt;=)</code> 时涉及绑定（binding）这一事实 —— <code>return</code> 是 <code>(&gt;&gt;=)</code> 的左、右单位（单位律），并且 <code>(&gt;&gt;=)</code> 具有结合律。单位律允许我们对某些解析器进行化简，而结合律允许在多次串接时省略括号。</p><h2 id="do-记法（The-do-notation）"><a href="#do-记法（The-do-notation）" class="headerlink" title="do 记法（The do notation）"></a>do 记法（The do notation）</h2><p>使用 <code>(&gt;&gt;=)</code> 构造的典型解析器具有如下结构：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">p1 &gt;&gt;= \a1 -&gt;</span><br><span class="line">p2 &gt;&gt;= \a2 -&gt;</span><br><span class="line">...</span><br><span class="line">pn &gt;&gt;= \an -&gt;</span><br><span class="line">f a1 a2 ... an</span><br></pre></td></tr></table></figure><p>这样的解析器有一个很自然的操作性解读：先应用解析器 <code>p1</code> 并把其结果值记为 <code>a1</code>；然后应用 <code>p2</code>，把其结果值记为 <code>a2</code>；……；接着应用 <code>pn</code>，把其结果值记为 <code>an</code>；最后通过应用一个语义动作（semantic action）<code>f</code> 来组合所有结果。对大多数解析器而言，语义动作通常为 <code>return (g a1 a2 ... an)</code>（其中 <code>g</code> 是某个函数），但并不总是如此。例如，可能需要在返回结果之前解析更多的参数字符串，稍后定义的组合子 <code>chainl1</code> 就是这种情况。</p><p>Haskell 为上述形状的解析器提供了特殊语法，使它们可以用如下更易读的形式来表达：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> a1 &lt;- p1</span><br><span class="line">   a2 &lt;- p2</span><br><span class="line">   ...</span><br><span class="line">   an &lt;- pn</span><br><span class="line">   f a1 a2 ... an</span><br></pre></td></tr></table></figure><p>如果愿意，这种记法也可以写在单行里，通过使用圆括号与分号来实现：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123;a1 &lt;- p1; a2 &lt;- p2; ...; an &lt;- pn; f a1 a2 ... an&#125;</span><br></pre></td></tr></table></figure><p>实际上，Haskell 中的 do 记法可以用于任何单子，不仅仅是解析器。子表达式 <code>ai &lt;- pi</code> 被称为“生成器（generator）”，因为它们为变量 <code>ai</code> 生成值。在一个特殊情形下，如果我们并不关心生成器 <code>ai &lt;- pi</code> 产生的值，那么这个生成器可以简写为仅仅 <code>pi</code>。</p><p>示例（Example）。一个消费三个字符、丢弃第二个字符，并把另外两个作为一对返回的解析器可以定义如下：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">p</span> :: <span class="type">Parser</span> (<span class="type">Char</span>,<span class="type">Char</span>)</span><br><span class="line"><span class="title">p</span> = <span class="keyword">do</span> &#123;c &lt;- item; item; d &lt;- item; return (c,d)&#125;</span><br></pre></td></tr></table></figure><h2 id="选择组合子（Choice-combinators）"><a href="#选择组合子（Choice-combinators）" class="headerlink" title="选择组合子（Choice combinators）"></a>选择组合子（Choice combinators）</h2><p>我们现在定义两个扩展解析器单子特性的组合子。在 Haskell 中，“带零元的单子（monad with a zero）”以及“带零元与加法的单子（monad with a zero and a plus）”由两个内置类定义来刻画：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadZero</span> m <span class="keyword">where</span></span></span><br><span class="line">   zero :: m a</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">MonadZero</span> m =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></span><br><span class="line">   (++) :: m a -&gt; m a -&gt; m a</span><br></pre></td></tr></table></figure><p>也就是说，如果一个类型构造器 <code>m</code> 是类 <code>Monad</code> 的成员，且还配备了类型如上所示的值 <code>zero</code>，那么 <code>m</code> 就是类 <code>MonadZero</code> 的成员。类似地，类 <code>MonadPlus</code> 在 <code>MonadZero</code> 的基础上添加了一个具有所示类型的 <code>(++)</code> 运算。类型构造器 <code>Parser</code> 可以如下成为这两个类的实例：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadZero</span> <span class="type">Parser</span> <span class="keyword">where</span></span></span><br><span class="line">   zero = <span class="type">Parser</span> (\cs -&gt; [])</span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> <span class="type">Parser</span> <span class="keyword">where</span></span></span><br><span class="line">   p ++ q = <span class="type">Parser</span> (\cs -&gt; parse p cs ++ parse q cs)</span><br></pre></td></tr></table></figure><p>解析器 <code>zero</code> 对所有参数字符串都失败，返回空结果。操作符 <code>(++)</code> 是解析器的（非确定性（non-deterministic））选择操作符（choice operator）。解析器 <code>p ++ q</code> 将两个解析器 <code>p</code> 与 <code>q</code> 都应用到参数字符串上，并把它们的结果列表相连接。</p><p>用于解析器的 <code>zero</code> 与 <code>(++)</code> 满足一些简单的定律：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    zero ++ p ＝ p</span><br><span class="line">    p ++ zero ＝ p</span><br><span class="line">p ++ (q ++ r) ＝ (p ++ q) ++ r</span><br></pre></td></tr></table></figure><p>事实上，这些定律对任何“带零元与加法的单子”都必须成立。这些定律断言 <code>zero</code> 是 <code>(++)</code> 的左、右单位元，且 <code>(++)</code> 具有结合律。对于解析器这一特例，还可以表明 —— 忽略与 <code>(&gt;&gt;=)</code> 相关的绑定 —— <code>zero</code> 是 <code>(&gt;&gt;=)</code> 的左、右零元，<code>(&gt;&gt;=)</code> 在右侧对 <code>(++)</code> 满足分配律，并且（如果我们忽略解析器返回结果的顺序）<code>(&gt;&gt;=)</code> 在左侧对 <code>(++)</code> 也满足分配律：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">              zero &gt;&gt;= f ＝ zero</span><br><span class="line">        p &gt;&gt;= const zero ＝ zero</span><br><span class="line">          (p ++ q) &gt;&gt;= f ＝ (p &gt;&gt;= f) ++ (q &gt;&gt;= f)</span><br><span class="line">p &gt;&gt;= (\a -&gt; f a ++ g a) ＝ (p &gt;&gt;= f) ++ (p &gt;&gt;= g)</span><br></pre></td></tr></table></figure><p>零元律允许我们化简某些解析器，而分配律允许我们提升某些解析器的效率。</p><p>使用 <code>(++)</code> 构造的解析器，如果参数字符串可以用多种方式解析，将返回多个结果。实际上，我们通常只对第一个结果感兴趣。因此，我们定义一个（确定性的（deterministic））选择操作符 <code>(+++)</code>，其行为与 <code>(++)</code> 相同，但至多返回一个结果：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(+++) :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">p</span> +++ q = <span class="type">Parser</span> (\cs -&gt; <span class="keyword">case</span> parse (p ++ q) cs <span class="keyword">of</span></span><br><span class="line">                            [] -&gt; []</span><br><span class="line">                            (x:xs) -&gt; [x])</span><br></pre></td></tr></table></figure><p>上面给出的关于 <code>(++)</code> 的所有定律同样也适用于 <code>(+++)</code>。此外，对于 <code>(+++)</code>，左分配律的前提条件会自动满足。</p><p>解析器 <code>item</code> 无条件地消费单个字符。为了支持条件解析，我们定义一个组合子 <code>sat</code>，它接受一个谓词（predicate），并产生一个解析器：若单个字符满足该谓词则消费之，否则失败：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sat</span> :: (<span class="type">Char</span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Parser</span> <span class="type">Char</span></span><br><span class="line"><span class="title">sat</span> p = <span class="keyword">do</span> &#123;c &lt;- item; <span class="keyword">if</span> p c <span class="keyword">then</span> return c <span class="keyword">else</span> zero&#125;</span><br></pre></td></tr></table></figure><p>示例（Example）。一个用于特定字符的解析器可以如下定义：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">char</span> :: <span class="type">Char</span> -&gt; <span class="type">Parser</span> <span class="type">Char</span></span><br><span class="line"><span class="title">char</span> c = sat (c ==)</span><br></pre></td></tr></table></figure><p>以类似方式，通过给 <code>sat</code> 提供合适的谓词，我们可以定义针对数字、小写字母、大写字母等的解析器。</p><h2 id="递归组合子（Recursion-combinators）"><a href="#递归组合子（Recursion-combinators）" class="headerlink" title="递归组合子（Recursion combinators）"></a>递归组合子（Recursion combinators）</h2><p>许多有用的解析器组合子可以通过递归来定义。其中大多数组合子事实上可以为任意“带零元与加法的单子”来定义，但为了清晰起见，下面仅针对解析器这一特例来定义。</p><ul><li><p>解析特定字符串：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">string</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></span><br><span class="line"><span class="title">string</span> <span class="string">&quot;&quot;</span> = return <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="title">string</span> (c:cs) = <span class="keyword">do</span> &#123;char c; string cs; return (c:cs)&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析解析器 <code>p</code> 的重复应用；<code>many</code> 允许零次或多次应用 <code>p</code>，而 <code>many1</code> 允许一次或多次：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">many</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> [a]</span><br><span class="line"><span class="title">many</span> p = many1 p +++ return []</span><br><span class="line"></span><br><span class="line"><span class="title">many1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> [a]</span><br><span class="line"><span class="title">many1</span> p = <span class="keyword">do</span> &#123;a &lt;- p; <span class="keyword">as</span> &lt;- many p; return (a:<span class="keyword">as</span>)&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析解析器 <code>p</code> 的重复应用，应用之间由解析器 <code>sep</code> 的应用分隔，且 <code>sep</code> 的结果值被丢弃：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sepby</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> b -&gt; <span class="type">Parser</span> [a]</span><br><span class="line"><span class="title">p</span> `sepby` sep = (p `sepby1` sep) +++ return []</span><br><span class="line"></span><br><span class="line"><span class="title">sepby1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> b -&gt; <span class="type">Parser</span> [a]</span><br><span class="line"><span class="title">p</span> `sepby1` sep = <span class="keyword">do</span> a &lt;- p</span><br><span class="line">                    <span class="keyword">as</span> &lt;- many (<span class="keyword">do</span> &#123;sep; p&#125;)</span><br><span class="line">                    return (a:<span class="keyword">as</span>)</span><br></pre></td></tr></table></figure></li><li><p>解析解析器 <code>p</code> 的重复应用，应用之间由解析器 <code>op</code> 的应用分隔，其中 <code>op</code> 的结果值是一个被假定为左结合（associate to the left）的运算符，并用于组合来自 <code>p</code> 的结果：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">chainl</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> (a -&gt; a -&gt; a) -&gt; a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">chainl</span> p op a = (p `chainl1` op) +++ return a</span><br><span class="line"></span><br><span class="line"><span class="title">chainl1</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> (a -&gt; a -&gt; a) -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">p</span> `chainl1` op = <span class="keyword">do</span> &#123;a &lt;- p; rest a&#125;</span><br><span class="line">                 <span class="keyword">where</span></span><br><span class="line">                    rest a = (<span class="keyword">do</span> f &lt;- op</span><br><span class="line">                                 b &lt;- p</span><br><span class="line">                                 rest (f a b))</span><br><span class="line">                             +++ return a</span><br></pre></td></tr></table></figure><p>  假定解析到的运算符右结合（associate to the right）的组合子 <code>chainr</code> 与 <code>chainr1</code> 也可用类似方式定义。</p></li></ul><h2 id="词法组合子（Lexical-combinators）"><a href="#词法组合子（Lexical-combinators）" class="headerlink" title="词法组合子（Lexical combinators）"></a>词法组合子（Lexical combinators）</h2><p>传统上，解析通常由一个词法阶段（lexical phase）先行，该阶段把参数字符串转换为一串记号（tokens）。然而，我们可以通过定义合适的组合子来避免单独的词法阶段。本节我们定义处理参数字符串中各记号之间空白（space）的组合子。用于处理其它词法问题（例如注释与关键字）的组合子也很容易定义。</p><ul><li><p>解析由空格、制表符与换行组成的字符串：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">space</span> :: <span class="type">Parser</span> <span class="type">String</span></span><br><span class="line"><span class="title">space</span> = many (sat isSpace)</span><br></pre></td></tr></table></figure></li><li><p>使用解析器 <code>p</code> 解析一个记号，并丢弃任何“尾随（trailing）”空白：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">token</span> :: <span class="type">Parser</span> a -&gt; <span class="type">Parser</span> a</span><br><span class="line"><span class="title">token</span> p = <span class="keyword">do</span> &#123;a &lt;- p; space; return a&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析一个符号记号：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">symb</span> :: <span class="type">String</span> -&gt; <span class="type">Parser</span> <span class="type">String</span></span><br><span class="line"><span class="title">symb</span> cs = token (string cs)</span><br></pre></td></tr></table></figure></li><li><p>应用解析器 <code>p</code>，并丢弃任何“前导（leading）”空白：</p>  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">apply</span> :: <span class="type">Parser</span> a -&gt; <span class="type">String</span> -&gt; [(a,<span class="type">String</span>)]</span><br><span class="line"><span class="title">apply</span> p = parse (<span class="keyword">do</span> &#123;space; p&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="示例（Example）"><a href="#示例（Example）" class="headerlink" title="示例（Example）"></a>示例（Example）</h2><p>我们用一个简单示例来说明本文定义的组合子。考虑由单个数字与运算符 +、-、*、&#x2F; 以及圆括号构成的算术表达式的标准文法（Aho 等, 1986）：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">expr ::= expr addop term | term</span><br><span class="line">term ::= term mulop factor | factor</span><br><span class="line">factor ::= digit | ( expr )</span><br><span class="line">digit ::= 0 | 1 | ... | 9</span><br><span class="line">addop ::= + | -</span><br><span class="line">mulop ::= * | /</span><br></pre></td></tr></table></figure><p>使用 <code>chainl1</code> 组合子来实现 <code>expr</code> 与 <code>term</code> 的左递归产生式规则，这个文法可以被直接翻译成一个 Haskell 程序，该程序解析表达式并把它们求值为整数：</p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">addop</span> :: <span class="type">Parser</span> (<span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line"><span class="title">mulop</span> :: <span class="type">Parser</span> (<span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> = term `chainl1` addop</span><br><span class="line"><span class="title">term</span> = factor `chainl1` mulop</span><br><span class="line"><span class="title">factor</span> = digit +++ <span class="keyword">do</span> &#123;symb <span class="string">&quot;(&quot;</span>; n &lt;- expr; symb <span class="string">&quot;)&quot;</span>; return n&#125;</span><br><span class="line"><span class="title">digit</span> = <span class="keyword">do</span> &#123;x &lt;- token (sat isDigit); return (ord x - ord <span class="string">&#x27;0&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">addop</span> = <span class="keyword">do</span> &#123;symb <span class="string">&quot;+&quot;</span>; return (+)&#125; +++ <span class="keyword">do</span> &#123;symb <span class="string">&quot;-&quot;</span>; return (-)&#125;</span><br><span class="line"><span class="title">mulop</span> = <span class="keyword">do</span> &#123;symb <span class="string">&quot;*&quot;</span>; return (*)&#125; +++ <span class="keyword">do</span> &#123;symb <span class="string">&quot;/&quot;</span>; return (div)&#125;</span><br></pre></td></tr></table></figure><p>例如，对 <code>apply expr &quot; 1 - 2 * 3 + 4 &quot;</code> 求值将得到单元素结果列表 <code>[(-1,&quot;&quot;)]</code>，这正是我们期望的行为。</p><h2 id="致谢（Acknowledgements）"><a href="#致谢（Acknowledgements）" class="headerlink" title="致谢（Acknowledgements）"></a>致谢（Acknowledgements）</h2><p>感谢 Luc Duponcheel、Benedict Gaster、Mark P. Jones、Colin Taylor 以及 Philip Wadler 对本文诸多草稿提出的宝贵意见。</p><h2 id="参考文献（References）"><a href="#参考文献（References）" class="headerlink" title="参考文献（References）"></a>参考文献（References）</h2><ul><li>Aho, A., Sethi, R. and Ullman, J. (1986) Compilers – Principles, Techniques and Tools. Addison-Wesley.</li><li>Burge, W, H. (1975) Recursive Programming Techniques. Addison-Wesley.</li><li>Fokker, J. (1995) Functional parsers. Lecture Notes of the Baastad Spring School on Functional Programming.</li><li>Gill, A. and Marlow, S. (1995) Happy: the parser generator for Haskell. University of Glasgow. Hutton, G. (1992) Higher-order functions for parsing. J. Functional Programming, 2(3), 323–343.</li><li>Jones, M. P. (1995) A system of constructor classes: overloading and implicit higher-order polymorphism. J. Functional Programming, 5(1), 1–35.</li><li>Mogensen, T. (1993) Ratatosk: A parser generator and scanner generator for Gofer. University of Copenhagen (DIKU).</li><li>Peterson, J. et al. (1996) The Haskell Language Report, version 1.3. Research report YALEU&#x2F;DCS&#x2F;RR-1106, Yale University.</li><li>Wadler, P. (1985) How to replace failure by a list of successes. Proc. Conf. on Functional Programming and Computer Architecture. Springer-Verlag.</li><li>Wadler, P. (1990) Comprehending monads. Proc. ACM Conf. on Lisp and Functional Pro- gramming.</li><li>Wadler, P. (1992a) The essence of functional programming. Proc. Principles of Programming Languages.</li><li>Wadler, P. (1992b) Monads for functional programming. In: Broy, M. (ed.), Proc. Marktober- dorf Summer School on Program Design Calculi. Springer-Verlag.</li></ul><h2 id="术语对照表（Glossary）"><a href="#术语对照表（Glossary）" class="headerlink" title="术语对照表（Glossary）"></a>术语对照表（Glossary）</h2><ul><li>单子（monad）</li><li>do 记法（do notation）</li><li>解析器（parser）</li><li>组合子（combinator）</li><li>递归下降解析器（recursive descent parser）</li><li>二义性文法（ambiguous grammar）</li><li>非确定性（non-deterministic）</li><li>确定性（deterministic）</li><li>生成器（generator）</li><li>语义动作（semantic action）</li><li>序列操作符（sequencing operator）</li><li>选择操作符（choice operator）</li><li>左结合（associate to the left）&#x2F; 右结合（associate to the right）</li><li>词法阶段（lexical phase）</li><li>记号（token）&#x2F; 符号记号（symbolic token）</li><li>尾随空白（trailing space）&#x2F; 前导空白（leading space）</li><li>类型构造器（type constructor）</li><li>解构函数（deconstructor）</li><li>带零元的单子（monad with a zero）</li><li>带零元与加法的单子（monad with a zero and a plus）</li><li>单位律（unit law）</li><li>结合律（associativity law）</li><li>分配律（distributivity law）</li></ul>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Parser-Combinators/">Parser Combinators</category>
      
      
      <category domain="http://hcoona.github.io/tags/Haskell/">Haskell</category>
      
      <category domain="http://hcoona.github.io/tags/Parser-Combinators/">Parser Combinators</category>
      
      
      <comments>http://hcoona.github.io/Parser-Combinators/monadic-parsing-in-haskell-translation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 Azure Container Registry 缓存 Docker Hub 镜像</title>
      <link>http://hcoona.github.io/Tips/azure-container-registry-cache-dockerhub/</link>
      <guid>http://hcoona.github.io/Tips/azure-container-registry-cache-dockerhub/</guid>
      <pubDate>Sat, 08 Jun 2024 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;这篇文章介绍如何使用 ACR (Azure Container Registry) 缓存 Docker Hub 和 GitHub Container Registry 的镜像。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这篇文章介绍如何使用 ACR (Azure Container Registry) 缓存 Docker Hub 和 GitHub Container Registry 的镜像。</p><span id="more"></span><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><ol><li>登录 Azure portal</li><li>Create a resource</li><li>搜索 Container Registry 并创建</li><li>大陆地区建议选择 East Asia (Hong Kong)，Southeast Asia (Singapore) 或者 Japan East，其他随意</li><li>打开创建好的 Container Registry</li><li>展开左边的 Services，点 Cache</li><li>Create rule 配置规则<ol><li>Rule name: dockerio</li><li>Source: Docker Hub</li><li>Repository path: <code>docker.io/*</code></li><li>New ACR repository namespace: <code>dockerio/*</code></li></ol></li><li>按需配置其他源，例如 <code>ghcr.io/*</code> -&gt; <code>ghcrio/*</code></li><li>如果你就在 Azure 的环境内用，或者可以用 Azure CLI 登录，例如 <code>az acr login</code>，就不用搞下面的 Token 了，直接去 Access Control (IAM) 配一下权限 (AcrPull) 就行了</li><li>展开左边的 Repository permissions，点 Token</li><li>Add，Token (name) 写一个你能区分出来的名字，Scope 选 <code>_repositories_pull</code></li><li>password1 右边的 Actions 点一下就能生成一个 Token 出来用，同时还给你一条命令用于 Docker client 登录 ACR 用，一定要记住这个密码，关了之后就看不到了</li></ol><h2 id="镜像替换"><a href="#镜像替换" class="headerlink" title="镜像替换"></a>镜像替换</h2><p>全都弄完了并且让你的 Docker client 登录之后，按照你配置的规则进行镜像替换，比如按照我上面的规则</p><ol><li><code>library/redis:6.2</code> -&gt; <code>xxxxx.azurecr.io/dockerio/library/redis:6.2</code></li><li><code>tensorchord/pgvecto-rs:pg14-v0.2.0</code> -&gt; <code>xxxxx.azurecr.io/dockerio/tensorchord/pgvecto-rs:pg14-v0.2.0</code></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://azure.microsoft.com/en-us/explore/global-infrastructure/geographies/">Choose the Right Azure Region for You | Microsoft Azure</a></li><li><a href="https://aka.ms/acr/cache">Artifact cache in Azure Container Registry</a></li></ol>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Azure/">Azure</category>
      
      <category domain="http://hcoona.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://hcoona.github.io/Tips/azure-container-registry-cache-dockerhub/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C# 命令行应用使用 MSAL 和 Web Account Manager 机制验证用户身份</title>
      <link>http://hcoona.github.io/Tips/csharp-console-app-login-msal-wam/</link>
      <guid>http://hcoona.github.io/Tips/csharp-console-app-login-msal-wam/</guid>
      <pubDate>Mon, 03 Jun 2024 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;工作场景通常需要有身份认证机制保护的 API，客户端在调用这些 API 之前，就需要先进行身份验证，然后使用身份验证得到的 Access Token 去访问这些 API。这篇文章告诉你如何让控制台应用进行交互式身份验证，然后请求受保护的 API。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>工作场景通常需要有身份认证机制保护的 API，客户端在调用这些 API 之前，就需要先进行身份验证，然后使用身份验证得到的 Access Token 去访问这些 API。这篇文章告诉你如何让控制台应用进行交互式身份验证，然后请求受保护的 API。</p><span id="more"></span><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>见文档 <a href="https://learn.microsoft.com/en-us/entra/msal/dotnet/getting-started/scenarios#desktop-app-that-calls-a-web-api-on-behalf-of-a-signed-in-user">Desktop app that calls a web API on behalf of a signed-in user</a></p><h2 id="在-EntraId-中创建应用注册"><a href="#在-EntraId-中创建应用注册" class="headerlink" title="在 EntraId 中创建应用注册"></a>在 EntraId 中创建应用注册</h2><p>概念和解释见相关文档</p><ol><li><a href="https://learn.microsoft.com/en-us/security/zero-trust/develop/app-registration">Register applications</a></li><li><a href="https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app">Quickstart: Register an application with the Microsoft identity platform</a></li></ol><p>详细步骤如下</p><ol><li>进入 Azure Portal</li><li>进入 Microsoft Entra ID</li><li>左侧导航栏找到 App registrations。可能需要展开 Manage 才能看到，如果还是看不到，需要管理员在 Entra ID Portal 里面配置一下。</li><li>New registration</li><li>给个名字，剩下全都默认，然后注册即可</li><li>找到你刚写的 app 名字，点进去</li><li>记下来 Application (client) ID 和 Directory (tenant) ID，之后在代码中要用</li><li>展开左边 Manage，点 Authentication</li><li>Add a platform，选 Mobile and desktop applications</li><li>在 Redirect URIs 里面添加自定义 URL: ms-appx-web:&#x2F;&#x2F;microsoft.aad.brokerplugin&#x2F;<client id>。这里 client id 就是前面记下来的 Application (client) ID。</li><li>保存</li></ol><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><p>新建一个 C# Console App，添加包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.Graph&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;5.55.0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.Identity.Client.Broker&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;4.61.2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>编辑 <code>.csproj</code> 文件</p><ol><li>将 <code>TargetFramework</code> 里面的 <code>net8.0</code> 改成 <code>net8.0-windows</code></li><li>在 <code>PropertyGroup</code> 里面增加 <code>&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;</code>，Interop 获取 Console Window native handle 的时候用</li></ol><h3 id="辅助类-Interop"><a href="#辅助类-Interop" class="headerlink" title="辅助类 Interop"></a>辅助类 <code>Interop</code></h3><p>这个类用于获取当前窗口（即便是 Console App）的 Windows native 句柄，Web Account Manager 需要用到这个。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OboClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Interop</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="built_in">enum</span> GetAncestorFlags</span><br><span class="line">        &#123;</span><br><span class="line">            GetParent = <span class="number">1</span>,</span><br><span class="line">            GetRoot = <span class="number">2</span>,</span><br><span class="line">            GetRootOwner = <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">LibraryImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">partial</span> IntPtr <span class="title">GetAncestor</span>(<span class="params">IntPtr hwnd, GetAncestorFlags flags</span>)</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">LibraryImport(<span class="string">&quot;kernel32.dll&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">partial</span> IntPtr <span class="title">GetConsoleWindow</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> IntPtr <span class="title">GetConsoleOrTerminalWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            IntPtr consoleHandle = GetConsoleWindow();</span><br><span class="line">            IntPtr handle = GetAncestor(consoleHandle, GetAncestorFlags.GetRootOwner);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-Client"><a href="#配置-Client" class="headerlink" title="配置 Client"></a>配置 Client</h3><p>ClientId 和 TenantId 就是之前在注册 Application 的时候记下来的两条数据。原则上应该从配置文件里读，这里为了简化示例就硬编码进来了。如果你用的不是 Azure 公有云，而是国家云或者世纪互联什么的，需要调整 <code>AzureCloudInstance.AzurePublic</code> 这个参数。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scopes = <span class="keyword">new</span>[] &#123; <span class="string">&quot;User.Read&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> applicationClientId = <span class="string">&quot;&lt;client id&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> tenantId = <span class="string">&quot;&lt;tenant id&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">BrokerOptions options = <span class="keyword">new</span>(BrokerOptions.OperatingSystems.Windows)</span><br><span class="line">&#123;</span><br><span class="line">    Title = <span class="string">&quot;&lt;arbitrary application name display to end user&gt;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IPublicClientApplication app = PublicClientApplicationBuilder</span><br><span class="line">    .Create(applicationClientId)</span><br><span class="line">    .WithAuthority(AzureCloudInstance.AzurePublic, tenantId)</span><br><span class="line">    .WithDefaultRedirectUri()</span><br><span class="line">    .WithParentActivityOrWindow(Interop.GetConsoleOrTerminalWindow)</span><br><span class="line">    .WithBroker(options)</span><br><span class="line">    .Build();</span><br></pre></td></tr></table></figure><p>如果对 Public Client 的概念感兴趣可以看文档 <a href="https://learn.microsoft.com/en-us/entra/identity-platform/msal-client-applications">Public client and confidential client applications</a>。</p><h3 id="使用-Client-认证用户身份"><a href="#使用-Client-认证用户身份" class="headerlink" title="使用 Client 认证用户身份"></a>使用 Client 认证用户身份</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IEnumerable&lt;IAccount&gt; accounts = <span class="keyword">await</span> app.GetAccountsAsync();</span><br><span class="line">IAccount? existingAccount = accounts.FirstOrDefault();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (existingAccount != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="keyword">await</span> app</span><br><span class="line">            .AcquireTokenSilent(scopes, existingAccount)</span><br><span class="line">            .ExecuteAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="keyword">await</span> app</span><br><span class="line">            .AcquireTokenSilent(scopes, PublicClientApplication.OperatingSystemAccount)</span><br><span class="line">            .ExecuteAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can&#x27;t get a token silently, try with interactive</span></span><br><span class="line"><span class="keyword">catch</span> (MsalUiRequiredException)</span><br><span class="line">&#123;</span><br><span class="line">    result = <span class="keyword">await</span> app</span><br><span class="line">        .AcquireTokenInteractive(scopes)</span><br><span class="line">        .ExecuteAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>result</code> 里面包含 <code>AccessToken</code> 可以用于访问受保护的 API，但是需要注意，这个 Token 是有过期时间限制的，过期之后需要再次获取。所以简单来说，每次你需要用 Token 的时候，都需要走一遍上面的流程。这个流程貌似（我没试验过）会在本地 cache Token，并且检查过期，见文档 <a href="https://learn.microsoft.com/en-us/entra/msal/dotnet/acquiring-tokens/acquire-token-silently#desktop-command-line-and-mobile-applications">Get a token from the token cache using MSAL.NET — Desktop, command-line, and mobile applications</a>。</p><h3 id="使用-AccessToken-访问受保护的-API"><a href="#使用-AccessToken-访问受保护的-API" class="headerlink" title="使用 AccessToken 访问受保护的 API"></a>使用 AccessToken 访问受保护的 API</h3><p>这里以 Microsoft Graph RESTful API 为例，其他应用大同小异。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DefaultRequestHeaders =</span><br><span class="line">    &#123;</span><br><span class="line">        Authorization = <span class="keyword">new</span> AuthenticationHeaderValue(<span class="string">&quot;Bearer&quot;</span>, result.AccessToken)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">GraphServiceClient graphServiceClient = <span class="keyword">new</span>(httpClient);</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">await</span> graphServiceClient.Me.GetAsync();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Hello <span class="subst">&#123;user?.DisplayName&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://learn.microsoft.com/en-us/entra/msal/dotnet/acquiring-tokens/desktop-mobile/wam">Using MSAL.NET with Web Account Manager (WAM)</a> 注意，截止至成文时这个文档的例子走不通（2024 年 6 月 4 日），已经反馈。</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/CSharp/">CSharp</category>
      
      <category domain="http://hcoona.github.io/tags/MSAL/">MSAL</category>
      
      <category domain="http://hcoona.github.io/tags/Authentication/">Authentication</category>
      
      
      <comments>http://hcoona.github.io/Tips/csharp-console-app-login-msal-wam/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ASP.NET Core 让 OpenTelemetry 适配自定义 HTTP Header</title>
      <link>http://hcoona.github.io/Tips/aspnetcore-opentelemetry-adapt-custom-trace-id/</link>
      <guid>http://hcoona.github.io/Tips/aspnetcore-opentelemetry-adapt-custom-trace-id/</guid>
      <pubDate>Thu, 30 May 2024 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://www.w3.org/TR/trace-context-1/&quot;&gt;W3C TraceContext V1 标准&lt;/a&gt; 直到 2021 年 11 月才发布。在此之前，很多系统使用自定义的 HTTP Header 字段进行请求和调用链路的追踪。例如 AWS S3 使用 &lt;code&gt;X-Amzn-Trace-Id&lt;/code&gt; 进行跟踪。这篇文章告诉你在 ASP.NET 中如何把旧系统中的 &lt;code&gt;X-Request-Id&lt;/code&gt; 和 &lt;code&gt;X-Trace-Id&lt;/code&gt; 嫁接到最新的 OpenTelemetry 框架上。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.w3.org/TR/trace-context-1/">W3C TraceContext V1 标准</a> 直到 2021 年 11 月才发布。在此之前，很多系统使用自定义的 HTTP Header 字段进行请求和调用链路的追踪。例如 AWS S3 使用 <code>X-Amzn-Trace-Id</code> 进行跟踪。这篇文章告诉你在 ASP.NET 中如何把旧系统中的 <code>X-Request-Id</code> 和 <code>X-Trace-Id</code> 嫁接到最新的 OpenTelemetry 框架上。</p><span id="more"></span><p>显然你总是能在某个地方读 HTTP Request Header 中的 <code>X-Request-Id</code> 和 <code>X-Trace-Id</code> 字段，然后自己生成一个 <code>traceparent</code> 字段的。问题主要是在什么地方做这个事情。显然这个事情应该发生在 ASP.NET 及 OpenTelemetry 框架开始处理 <code>traceparent</code> 字段之前。那么对我们来说，这个转换操作越早进行越好，毕竟我们是增加新信息，不会造成信息损耗或丢失。</p><p>如果你的程序前面还有一层 SLB（Software Load Balancer），例如 Nginx，那你完全可以在这一层实现这个转换逻辑。</p><p>如果你的程序前面没有 SLB 了，在 ASP.NET 框架内需要处理这个问题，该怎么进行呢？</p><p>经过一番调研，发现 <code>HttpContextFactory</code> 是一个比较合适的地方。<code>HttpContextFactory</code> 创建了 <code>HttpContext</code>，然后 ASP.NET 才开始进行 pipeline 处理。相关文档参考 <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0">ASP.NET Core Middleware</a>。当然你在 pipeline 的最开始跑一个自己的 Middleware 干这个事情应该也是可以的，但是别人一不小心在你前面又注册个 Middleware 可能就出问题了，还是使用自定义的 <code>HttpContextFactory</code> 比较靠谱。</p><p>接下来考虑一下转换的逻辑。在 <a href="https://www.w3.org/TR/trace-context-1/#traceparent-header">W3C TraceContext V1 标准 3.2 Traceparent Header</a> 中有详细含义的解释。这里摘取一下其中给出的例子看一下。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Value = 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01</span><br><span class="line">base16(version) = 00</span><br><span class="line">base16(trace-id) = 4bf92f3577b34da6a3ce929d0e0e4736</span><br><span class="line">base16(parent-id) = 00f067aa0ba902b7</span><br><span class="line">base16(trace-flags) = 01  // sampled</span><br><span class="line"></span><br><span class="line">Value = 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00</span><br><span class="line">base16(version) = 00</span><br><span class="line">base16(trace-id) = 4bf92f3577b34da6a3ce929d0e0e4736</span><br><span class="line">base16(parent-id) = 00f067aa0ba902b7</span><br><span class="line">base16(trace-flags) = 00  // not sampled</span><br></pre></td></tr></table></figure><p>我们使用的 <code>X-Request-Id</code> 其实并不能完美的对应上这里的 <code>parent-id</code>，但是在此时能获取到的最接近 <code>parent-id</code> 的含义就是它了。通常，我们在系统中使用的 <code>X-Trace-Id</code> 和 <code>X-Parent-Id</code> 都是 UUID。这里 <code>X-Trace-Id</code> 正好符合 <code>trace-id</code> 的要求，都是 32 个 HEX。但是 <code>X-Parent-Id</code> 的长度就远远超出了 <code>parent-id</code> 的要求，可以考虑截取其中的高 16 位或者低 16 位。</p><p>样例代码</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http.Features;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.Azure.Compute.Specialized.HpcAi</span>..<span class="title">PlatformController.Middlewares</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpContextFactory</span> : <span class="title">IHttpContextFactory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> DefaultHttpContextFactory _defaultHttpContextFactory;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpContextFactory</span>(<span class="params">IServiceProvider serviceProvider</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _defaultHttpContextFactory = <span class="keyword">new</span> DefaultHttpContextFactory(serviceProvider);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpContext <span class="title">Create</span>(<span class="params">IFeatureCollection featureCollection</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> context = _defaultHttpContextFactory.Create(featureCollection);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If request header has traceparent, it follows the W3C Trace Context specification.</span></span><br><span class="line">            <span class="comment">// Else we generate traceparent from X--TraceId.</span></span><br><span class="line">            <span class="keyword">if</span> (context.Request.Headers.ContainsKey(<span class="string">&quot;traceparent&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                context.Items[<span class="string">&quot;Has-W3C-Trace-Context&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> context;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            context.Items[<span class="string">&quot;Has-W3C-Trace-Context&quot;</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!context.Request.Headers.TryGetValue(<span class="string">&quot;X-TraceId&quot;</span>, <span class="keyword">out</span> <span class="keyword">var</span> traceId))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> context;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Guid.TryParse(traceId, CultureInfo.InvariantCulture, <span class="keyword">out</span> <span class="keyword">var</span> _))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> context;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!context.Request.Headers.TryGetValue(<span class="string">&quot;X-RequestId&quot;</span>, <span class="keyword">out</span> <span class="keyword">var</span> requestId))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> context;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Guid.TryParse(requestId, CultureInfo.InvariantCulture, <span class="keyword">out</span> <span class="keyword">var</span> _))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> context;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            context.Request.Headers.TraceParent = <span class="string">$&quot;00-<span class="subst">&#123;traceId.ToString().Replace(<span class="string">&quot;-&quot;</span>, <span class="built_in">string</span>.Empty)&#125;</span>-<span class="subst">&#123;requestId.ToString().Replace(<span class="string">&quot;-&quot;</span>, <span class="built_in">string</span>.Empty)[<span class="number">15.</span>.]&#125;</span>-01&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params">HttpContext httpContext</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _defaultHttpContextFactory.Dispose(httpContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你正确配置了 OpenTelemetry，这些字段可以在后面用 <code>HttpContext.Features.Get&lt;IHttpActivityFeature&gt;()!.Activity</code> 中的 <code>TraceId</code> 和 <code>ParentId</code> 提取出来。</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/CSharp/">CSharp</category>
      
      <category domain="http://hcoona.github.io/tags/ASP-NET/">ASP.NET</category>
      
      <category domain="http://hcoona.github.io/tags/OpenTelemetry/">OpenTelemetry</category>
      
      
      <comments>http://hcoona.github.io/Tips/aspnetcore-opentelemetry-adapt-custom-trace-id/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>让 .NET 的 Logger 结构化的打印 Scope</title>
      <link>http://hcoona.github.io/Tips/dotnet-structure-log-scope/</link>
      <guid>http://hcoona.github.io/Tips/dotnet-structure-log-scope/</guid>
      <pubDate>Wed, 29 May 2024 16:00:00 GMT</pubDate>
      
      <description>Microsoft.Extensions.Logging 打印 Scope 的时候默认是个字符串，这篇文章告诉你如何让其保持 Scope 的结构化输出</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 <code>Microsoft.Extensions.Logging</code> 中使用 <code>JsonConsoleFormatter</code> 打印日志时，如果使用 <code>BeginScope&lt;TState&gt;(state)</code> 方法，输出的时候 Scope 会是一个字符串而非传入的 <code>state</code> 对象 JSON 序列化后的结果（即不是预期中的 JSON Object）。</p><p>示例代码如下</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (logger.BeginScope(<span class="keyword">new</span> &#123; SessionId = <span class="string">&quot;123&quot;</span>, TraceId = <span class="string">&quot;456&quot;</span>, SpanId = <span class="string">&quot;789&quot;</span> &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    logger.LogInformation(<span class="string">&quot;Hello &#123;name&#125;!&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-05-30T13:38:39.108Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;EventId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;State&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;World&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&#123;OriginalFormat&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello &#123;name&#125;!&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Scopes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;&#123; SessionId = 123, TraceId = 456, SpanId = 789 &#125;&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="问题比较和追查"><a href="#问题比较和追查" class="headerlink" title="问题比较和追查"></a>问题比较和追查</h2><p>经过调研，发现 <code>Activity</code> 里面的 <code>TraceId</code> 和 <code>SpanId</code> 就能正常打印出结构来。</p><p>样例代码</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loggerFactory = LoggerFactory.Create(builder =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    builder.ClearProviders();</span><br><span class="line">    builder.AddJsonConsole(options =&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    builder.Configure(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.ActivityTrackingOptions = ActivityTrackingOptions.TraceId | ActivityTrackingOptions.SpanId;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger = loggerFactory.CreateLogger(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> activitySource = <span class="keyword">new</span> ActivitySource(</span><br><span class="line">    Assembly.GetExecutingAssembly().FullName ?? <span class="keyword">typeof</span>(Program).FullName ?? <span class="keyword">nameof</span>(Program));</span><br><span class="line">ActivitySource.AddActivityListener(<span class="keyword">new</span> ActivityListener()</span><br><span class="line">&#123;</span><br><span class="line">    ShouldListenTo = _ =&gt; <span class="literal">true</span>,</span><br><span class="line">    Sample = (<span class="keyword">ref</span> ActivityCreationOptions&lt;ActivityContext&gt; options) =&gt; ActivitySamplingResult.AllData,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> activity = activitySource.StartActivity(ActivityKind.Internal, name: <span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.LogInformation(<span class="string">&quot;Hello &#123;name&#125;!&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-05-30T13:45:28.480Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;EventId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;State&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;World&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&#123;OriginalFormat&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello &#123;name&#125;!&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Scopes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SpanId:a9563a12d6c1c82d, TraceId:62031742f61da3361b63ef75c11c0be8&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SpanId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a9563a12d6c1c82d&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;TraceId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;62031742f61da3361b63ef75c11c0be8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>跑到 <code>Microsoft.Extensions.Logging</code> 源代码仓库里一找，发现只要继承自 <code>IReadOnlyList&lt;KeyValuePair&lt;string, object?&gt;&gt;</code> 或者 <code>IEnumerable&lt;KeyValuePair&lt;string, object?&gt;&gt;</code> 就能解决这个问题。相关源代码见 <a href="https://github.com/dotnet/runtime/blob/v8.0.6/src/libraries/Microsoft.Extensions.Logging/src/LoggerFactoryScopeProvider.cs#L131">LoggerFactoryScopeProvider.cs#L131</a>。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>样例代码</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = loggerFactory.CreateLogger(<span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (logger.BeginScope(<span class="keyword">new</span> TracingContext(SessionId: <span class="string">&quot;123&quot;</span>, TraceId: <span class="string">&quot;456&quot;</span>, SpanId: <span class="string">&quot;789&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    logger.LogInformation(<span class="string">&quot;Hello &#123;name&#125;!&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">record</span> <span class="keyword">class</span> <span class="title">TracingContext</span>(<span class="params"><span class="built_in">string</span> SessionId, <span class="built_in">string</span> TraceId, <span class="built_in">string</span> SpanId</span>)</span></span><br><span class="line"><span class="function">    : IEnumerable&lt;KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">object</span>?&gt;&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IEnumerator&lt;KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">object</span>?&gt;&gt; GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span>(<span class="params"><span class="keyword">nameof</span>(SessionId</span>), SessionId)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span>(<span class="params"><span class="keyword">nameof</span>(TraceId</span>), TraceId)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span>(<span class="params"><span class="keyword">nameof</span>(SpanId</span>), SpanId)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(SessionId)&#125;</span>: <span class="subst">&#123;SessionId&#125;</span>, <span class="subst">&#123;<span class="keyword">nameof</span>(TraceId)&#125;</span>: <span class="subst">&#123;TraceId&#125;</span>, <span class="subst">&#123;<span class="keyword">nameof</span>(SpanId)&#125;</span>: <span class="subst">&#123;SpanId&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-05-30T13:53:05.767Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;EventId&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;LogLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Information&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;State&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;World&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;&#123;OriginalFormat&#125;&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello &#123;name&#125;!&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Scopes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SessionId:123, TraceId:456, SpanId:789&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SessionId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;TraceId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;456&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;SpanId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;789&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/CSharp/">CSharp</category>
      
      
      <comments>http://hcoona.github.io/Tips/dotnet-structure-log-scope/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MSBuild 总结</title>
      <link>http://hcoona.github.io/Build-System/msbuild-summary/</link>
      <guid>http://hcoona.github.io/Build-System/msbuild-summary/</guid>
      <pubDate>Tue, 26 Jul 2022 16:00:00 GMT</pubDate>
      
      <description>总结 MSBuild 的基本概念和扩展方法</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近又要开始搞 Visual Studio 的项目了，可能还要把之前一些老构建流程的项目迁移过来，所以在看看 MSBuild 的相关资料，整理一下学习笔记。</p><p>这次的话会写得简单一些，因为有些基础概念已经都掌握了。</p><p>官方文档见 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild?view=vs-2022">MSBuild - MSBuild</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>参考 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-concepts?view=vs-2022">MSBuild Concepts - MSBuild</a></p><ul><li>Property：约等于 Variable 的概念</li><li>Item：会展示在 IDE 中的文件</li><li>Target：执行构建工作流的节点</li><li>Task：实际执行的动作，一个 Target 可以包含多个 Tasks</li></ul><h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><p>用 <code>$(&lt;name&gt;)</code> 来使用。</p><p>主要是要知道有些内建的 Properties：<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-reserved-and-well-known-properties?view=vs-2022">MSBuild Reserved and Well-known Properties - MSBuild</a></p><p>然后是环境变量也能当成 Property 用：<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/how-to-use-environment-variables-in-a-build?view=vs-2022">How to: Use Environment Variables in a Build - MSBuild</a></p><p>可以用一些特定的函数对 Property 进行计算：<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/property-functions?view=vs-2022">Property Functions - MSBuild</a></p><h2 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h2><p>用 <code>@(&lt;name&gt;)</code> 来使用 Item，用 <code>%(&lt;name&gt;)</code> 来使用其 Metadata。</p><p>Metadata 是 Attach 到 Item 上的属性，有一些内建的 Metadata 可用：<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-well-known-item-metadata?view=vs-2022">MSBuild Well-known Item Metadata - MSBuild</a></p><p>可以用一些特定的函数对 Metadata 进行计算：<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/item-functions?view=vs-2022">Item Functions - MSBuild</a></p><p>可以用 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-transforms?view=vs-2022">MSBuild Transforms - MSBuild</a> 这样一种语法对 Item 列表基于 Metadata 来进行一些变换（类似于 Mapping 操作）。</p><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>默认的 Targets 有这些 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets?view=vs-2022#default-build-targets">MSBuild Targets - MSBuild</a></p><p>如何确定 Target 的执行顺序见 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/target-build-order?view=vs-2022#determine-the-target-build-order">Target Build Order - MSBuild</a></p><p>这里比较容易引起困惑的是 DependsOnTargets 和 AfterTargets，他们的区别见 <a href="https://github.com/MicrosoftDocs/visualstudio-docs/issues/2994#issuecomment-480017831">DependsOnTargets Vs AfterTargets · Issue #2994 · MicrosoftDocs&#x2F;visualstudio-docs</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Target Name=&quot;x&quot; DependsOnTargets=&quot;y&quot; /&gt; means:</span><br><span class="line"></span><br><span class="line">If something wants to run x, y must run first.</span><br><span class="line"></span><br><span class="line">&lt;Target Name=&quot;a&quot; AfterTargets=&quot;b&quot; /&gt; means:</span><br><span class="line"></span><br><span class="line">If something runs b, then run a after it.</span><br><span class="line"></span><br><span class="line">They differ in a couple of ways. BeforeTargets and AfterTargets are</span><br><span class="line">generally used for *extending* the build: &quot;I have a custom target I</span><br><span class="line">want to run after ResolveReferences&quot;. The target that&#x27;s being</span><br><span class="line">hooked onto doesn&#x27;t need to know anything about the new target.</span><br><span class="line"></span><br><span class="line">In contrast, DependsOnTargets is the basic building block of the</span><br><span class="line">target-dependency graph. When authoring a target, use</span><br><span class="line">DependsOnTargets to ensure that all of your inputs (both file and</span><br><span class="line">MSBuild item/property) have already been brought up to date.</span><br></pre></td></tr></table></figure><p>空的 <code>proj</code> 就没有 Target，但是一般我们都用 <code>vcxproj</code> 什么的，通过 SDK 就给注入了一堆 target。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>内置的 Task 有这些 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task-reference?view=vs-2022#in-this-section">MSBuild Task Reference - MSBuild</a>（定义于 Microsoft.Common.CurrentVersion.Targets）</p><table><thead><tr><th><code>.targets</code> file</th><th>Description</th></tr></thead><tbody><tr><td>Microsoft.Common.targets</td><td>Defines the steps in the standard build process for Visual Basic and C# projects.<br>Imported by the <code>Microsoft.CSharp.targets</code> and <code>Microsoft.VisualBasic.targets</code> files, which include the following statement: <code>&lt;Import Project=&quot;Microsoft.Common.targets&quot; /&gt;</code></td></tr><tr><td>Microsoft.CSharp.targets</td><td>Defines the steps in the standard build process for Visual C# projects.<br>Imported by Visual C# project files (<code>.csproj</code>), which include the following statement: <code>&lt;Import Project=&quot;$(MSBuildToolsSpeed)\Microsoft.CSharp.targets&quot; /&gt;</code></td></tr><tr><td>Microsoft.VisualBasic.targets</td><td>Defines the steps in the standard build process for Visual Basic projects.<br>Imported by Visual Basic project files (<code>.vbproj</code>), which include the following statement: <code>&lt;Import Project=&quot;$(MSBuildToolsSpeed)\Microsoft.VisualBasic.targets&quot; /&gt;</code></td></tr></tbody></table><p>C++ 的好像是 <code>Microsoft.Cpp.targets</code> 看起来好像跟 <code>Microsoft.Commons.targets</code> 没关系（看这里的可能更靠谱 <code>C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\Microsoft.Common.tasks</code>）。</p><p>如果需要自定义 Task 可以参考 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/task-writing?view=vs-2022">Task Writing - MSBuild</a> 和 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/tutorial-custom-task-code-generation?view=vs-2022">Create a custom task - MSBuild</a>。如果只需要嵌入非常简单的小段代码，可以考虑 <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-inline-tasks?view=vs-2022">MSBuild Inline Tasks - MSBuild</a>。</p><h2 id="Directory-Build-props"><a href="#Directory-Build-props" class="headerlink" title="Directory.Build.props"></a>Directory.Build.props</h2><h3 id="递归引用的小技巧"><a href="#递归引用的小技巧" class="headerlink" title="递归引用的小技巧"></a>递归引用的小技巧</h3><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/how-to-use-project-sdk?view=vs-2022">https://docs.microsoft.com/zh-cn/visualstudio/msbuild/how-to-use-project-sdk?view=vs-2022</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Import</span> <span class="attr">Project</span>=<span class="string">&quot;$([MSBuild]::GetDirectoryNameOfFileAbove(&#x27;$(MSBuildThisFileDirectory)..&#x27;, &#x27;Directory.Build.props&#x27;))\Directory.Build.props&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MSBuildSdks"><a href="#MSBuildSdks" class="headerlink" title="MSBuildSdks"></a>MSBuildSdks</h3><p><a href="https://github.com/microsoft/MSBuildSdks">https://github.com/microsoft/MSBuildSdks</a></p><p><a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/how-to-use-project-sdk?view=vs-2022">https://docs.microsoft.com/zh-cn/visualstudio/msbuild/how-to-use-project-sdk?view=vs-2022</a></p><p>这里面搞了几个比较有用的扩展：</p><ol><li><a href="https://github.com/microsoft/MSBuildSdks/blob/main/src/Traversal">Microsoft.Build.Traversal</a> 一般用来搞一个 <code>dirs.proj</code>，递归的引用子目录中的其他项目。这样方便在一个特别大的仓库中组织几百个项目。最终可以用 SlnGen 工具生成 <code>sln</code> 文件使用 IDE 进行开发。这么搞的原因是大型 <code>sln</code> 文件性能比较差。</li><li><a href="https://github.com/microsoft/MSBuildSdks/blob/main/src/CentralPackageVersions">Microsoft.Build.CentralPackageVersions</a> 中心化配置依赖版本，这样就能将整个仓库中所有项目使用的依赖版本对齐了，互相引用和链接的时候也不会出什么依赖版本不一致的问题。</li><li><a href="https://github.com/microsoft/MSBuildSdks/blob/main/src/NoTargets">Microsoft.Build.NoTargets</a> Build 过程为空，这样方便在编译时期处罚一些自定义的任务，比如说 <code>robocopy</code> 什么的。</li><li><a href="https://github.com/microsoft/MSBuildSdks/blob/main/src/Artifacts">Microsoft.Build.Artifacts</a> 把项目产物放到一个集中的地方，方便比如说 Azure DevOps Pipeline 编译完了之后把所有产物收集起来（Azure Artifacts）。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="XML-文件-Schema"><a href="#XML-文件-Schema" class="headerlink" title="XML 文件 Schema"></a>XML 文件 Schema</h3><p><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-project-file-schema-reference?view=vs-2022">https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-project-file-schema-reference?view=vs-2022</a></p><blockquote><p>The schema link in an MSBuild project file is not required in Visual Studio 2017 and later. If present, it should be <code>http://schemas.microsoft.com/developer/msbuild/2003</code> regardless of the version of Visual Studio.</p></blockquote><p>但是看现在 SDK 的项目自动都把 Schema 抹掉了，也不知道是为啥。</p><h3 id="一般把扩展拆成-props-和-targets-两个文件"><a href="#一般把扩展拆成-props-和-targets-两个文件" class="headerlink" title="一般把扩展拆成 .props 和 .targets 两个文件"></a>一般把扩展拆成 .props 和 .targets 两个文件</h3><p><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022#choose-between-adding-properties-to-a-props-or-targets-file">https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022#choose-between-adding-properties-to-a-props-or-targets-file</a></p><p>说这个主要是写 nuget 包的时候会用到。</p><blockquote><p>When using explicit imports, you can import from a <code>.props</code> or <code>.targets</code> file at any point. Here is the widely used convention:</p><ul><li><code>.props</code> files are imported early in the import order.</li><li><code>.targets</code> files are imported late in the build order.</li></ul></blockquote><h3 id="根根据项目类型自定义配置"><a href="#根根据项目类型自定义配置" class="headerlink" title="根根据项目类型自定义配置"></a>根根据项目类型自定义配置</h3><p><a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022#custom-configuration-based-on-project-language">https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022#custom-configuration-based-on-project-language</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(MSBuildProjectExtension)&#x27; == &#x27;.vbproj&#x27;&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Put VB-only property definitions here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(MSBuildProjectExtension)&#x27; == &#x27;.fsproj&#x27;&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Put F#-only property definitions here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(MSBuildProjectExtension)&#x27; == &#x27;.csproj&#x27;&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- Put C#-only property definitions here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从-proj-文件生成-sln-文件"><a href="#从-proj-文件生成-sln-文件" class="headerlink" title="从 proj 文件生成 sln 文件"></a>从 <code>proj</code> 文件生成 <code>sln</code> 文件</h3><p><a href="https://microsoft.github.io/slngen/">https://microsoft.github.io/slngen/</a></p><h3 id="编译-NET-Framework-目标工程"><a href="#编译-NET-Framework-目标工程" class="headerlink" title="编译 .NET Framework 目标工程"></a>编译 .NET Framework 目标工程</h3><p>可以用这个 <a href="https://github.com/Microsoft/dotnet/tree/master/releases/reference-assemblies">https://github.com/Microsoft/dotnet/tree/master/releases/reference-assemblies</a> 而不安装 .NET Framework SDK</p><h3 id="C-SDK"><a href="#C-SDK" class="headerlink" title="C++ SDK"></a>C++ SDK</h3><p><a href="https://www.nuget.org/packages/Microsoft.Windows.SDK.NET.Ref/">https://www.nuget.org/packages/Microsoft.Windows.SDK.NET.Ref/</a></p><p><a href="https://www.nuget.org/packages/Microsoft.Windows.SDK.CPP/">https://www.nuget.org/packages/Microsoft.Windows.SDK.CPP/</a></p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Build-System/">Build System</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/MSBuild/">MSBuild</category>
      
      <category domain="http://hcoona.github.io/tags/Build-System/">Build System</category>
      
      
      <comments>http://hcoona.github.io/Build-System/msbuild-summary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ 侵入式链表总结</title>
      <link>http://hcoona.github.io/Data-Structure/instrusive-linked-list-summary/</link>
      <guid>http://hcoona.github.io/Data-Structure/instrusive-linked-list-summary/</guid>
      <pubDate>Sat, 04 Jun 2022 16:00:00 GMT</pubDate>
      
      <description>总结侵入式链表的主要优缺点和在 C++ 语言参考实现</description>
      
      
      
      <content:encoded><![CDATA[<p>最近突然想要看一看性能相关的优化，正好看到了侵入式链表这部分，在此做一个简单的总结。</p><p>这里简单的说一下什么是侵入式链表，方便读者快速决定是否需要继续读下去。一个常见的非侵入式链表是这样的：</p><figure class="highlight cxx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">  ListNode* prev;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  T value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以说，非侵入式链表的实现方式是，链表节点中包含数据。侵入式链表的实现方式与之相反，是业务数据结构中包含链表节点结构：</p><figure class="highlight cxx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntrusiveListNode</span> &#123;</span><br><span class="line">  IntrusiveListNode* prev;</span><br><span class="line">  IntrusiveListNode* next;</span><br><span class="line">  T* owner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserData</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  InstruiveListNode list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>侵入式链表的常见使用场景是对比 <code>std::list&lt;T*&gt;</code> 这样的使用方法的，其他场景一般不适用于侵入式链表。例如在实现 LRU 时，需要把 entry 同时加入 HashMap 和 List 中，使用前者提供 $O(1)$ 复杂度的查询，使用后者维持 Recency 序关系。由于一个值对象不能同时属于两个非侵入式容器，所以其中一个容器必然保存的是指针或者迭代器。此时，拿到一个 Entry 的时候就可以操作这个 Entry 所在的链表，非常方便，而且效率也比较高。</p><p><strong>侵入式的好处</strong></p><p>关于侵入式和非侵入式的对比，见 <a href="https://www.boost.org/doc/libs/1_79_0/doc/html/intrusive/intrusive_vs_nontrusive.html">https://www.boost.org/doc/libs/1_79_0/doc/html/intrusive/intrusive_vs_nontrusive.html</a></p><p>一般来说，大家都会优先选择使用非侵入式的实现。因为侵入式实现需要将一些逻辑耦合到业务代码中，因此为人所不喜。但是在背景介绍中提到的场景下，侵入式实现有显著的好处，从而使得侵入式实现被广泛的使用。我们在此不再强调侵入式与非侵入式的区别，主要考虑一下侵入式链表的优势有哪些。</p><p><strong>更好的 Data Locality</strong></p><p><code>std::list&lt;T*&gt;</code> 在遍历的过程中还需要对 <code>T*</code> 进行解引用才能访问 <code>T</code> 内部的数据。但是侵入式链表的 <code>next</code> 和 <code>T</code> 内部的数据是放在一起的，因此无需额外的解引用。而且由于内存 layout 就是在一起的，所以也会获得更好的 Data Locality。</p><p><strong>更友好的 API</strong></p><p>对于侵入式链表，我们拿到数据就可以将这个节点从链表中摘除，而无需再去定位其 iterator，然后再去找到对应的容器 erase 这个 iterator。</p><p><strong>脱离容器进行生命周期管理</strong></p><p>最主要的应用场景是同一份对象需要在多个容器中共享，例如在背景介绍中提到的实现 LRU 的场景，又例如需要将同一份数据加入多个链表中。因此侵入式链表需要用户自己管理数据节点生命周期的特性在这里就成为了一个优点。</p><p><strong>一些实现方式分析</strong></p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><a href="https://github.com/torvalds/linux/blob/v5.18/include/linux/list.h">https://github.com/torvalds/linux/blob/v5.18/include/linux/list.h</a></p><p>如其注释所说，其实现了一个双向循环链表。</p><p><img data-src="/images/circular-doubly-linked-list.png" alt="circular doubly linked list"></p><p>侵入式链表结构的定义见 <a href="https://github.com/torvalds/linux/blob/v5.18/include/linux/types.h">https://github.com/torvalds/linux/blob/v5.18/include/linux/types.h</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用上的相关方法见 <a href="https://github.com/torvalds/linux/blob/v5.18/include/linux/list.h">https://github.com/torvalds/linux/blob/v5.18/include/linux/list.h</a></p><p>在使用时，以调度模块为例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/torvalds/linux/blob/v5.18/kernel/sched/sched.h#L376</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> &#123;</span></span><br><span class="line">  <span class="comment">// 省略一些业务逻辑</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/torvalds/linux/blob/v5.18/kernel/sched/core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default task group.</span></span><br><span class="line"><span class="comment"> * Every task in system belongs to this group at bootup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> <span class="title">root_task_group</span>;</span></span><br><span class="line">LIST_HEAD(task_groups);</span><br><span class="line"></span><br><span class="line">list_add(&amp;root_task_group.<span class="built_in">list</span>, &amp;task_groups);</span><br></pre></td></tr></table></figure><p>这里的问题在于 <code>struct list_head</code> 中的指针也都是 <code>struct list_head</code> 类型的，怎么拿到用户类型的数据？考虑到 C 语言中所有结构体内部数据都是按照约定好的 layout 排布的。我们可以通过 <code>offsetof</code> 计算偏移量来找到用户结构体的起始位置了，再进行一下类型强制转换就可以了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/torvalds/linux/blob/v5.18/include/linux/list.h#L519</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment"> * @ptr:        the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment"> * @type:       the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:     the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">        container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/torvalds/linux/blob/v5.18/include/linux/container_of.h#L17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment"> * @ptr:          the pointer to the member.</span></span><br><span class="line"><span class="comment"> * @type:         the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:       the name of the member within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                            \</span></span><br><span class="line"><span class="meta">        void *__mptr = (void *)(ptr);                                 \</span></span><br><span class="line"><span class="meta">        static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||     \</span></span><br><span class="line"><span class="meta">                      __same_type(*(ptr), void),                      \</span></span><br><span class="line"><span class="meta">                      <span class="string">&quot;pointer type mismatch in container_of()&quot;</span>);     \</span></span><br><span class="line"><span class="meta">        ((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br></pre></td></tr></table></figure><p>注意，offsetof 只能对 Standard Layout 的类型起作用。例如 virtual inheritance 的场景就不适用。所以在 C++ 中使用这个技巧要十分谨慎。</p><p><a href="https://stackoverflow.com/questions/1129894/why-cant-you-use-offsetof-on-non-pod-structures-in-c">https://stackoverflow.com/questions/1129894/why-cant-you-use-offsetof-on-non-pod-structures-in-c</a></p><h3 id="Doom3"><a href="#Doom3" class="headerlink" title="Doom3"></a>Doom3</h3><p><a href="https://github.com/Edgarins29/Doom3/blob/d80c4d8341a35a8d9bc71324dcfc2be583295c03/neo/idlib/containers/LinkList.h">https://github.com/Edgarins29/Doom3/blob/d80c4d8341a35a8d9bc71324dcfc2be583295c03/neo/idlib/containers/LinkList.h</a></p><p>上面已经介绍了 Linux 是如何实现一个侵入式链表的，并且提出了这种方法对于 C++ 语言来说有一些限制，不能用于 non-standard layout 的数据结构。大部分情况下我们都不会遇到这样的限制，但是一旦真的遇到了该怎么解决呢？Doom 代码中也有一个类似的实现，其通过添加一个额外的 <code>owner</code> 成员来解决这一问题。</p><figure class="highlight cxx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">idLinkList</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  idLinkList* head;</span><br><span class="line">  idLinkList* next;</span><br><span class="line">  idLinkList* prev;</span><br><span class="line">  type*       owner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用的时候类似于这样：</p><figure class="highlight cxx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">idEntity</span> &#123;</span><br><span class="line">  idLinkList&lt;idEntity&gt; spawnNode;  <span class="comment">// for being linked into spawnedEntities list</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">idEntity::<span class="built_in">idEntity</span>() &#123;</span><br><span class="line">  spawnNode.<span class="built_in">SetOwner</span>( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">================</span></span><br><span class="line"><span class="comment">idLinkList&lt;type&gt;::InsertBefore</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Places the node before the existing node in the list.  If the existing node is the head,</span></span><br><span class="line"><span class="comment">then the new node is placed at the end of the list.</span></span><br><span class="line"><span class="comment">================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;</span><br><span class="line"><span class="type">void</span> idLinkList&lt;type&gt;::<span class="built_in">InsertBefore</span>(idLinkList &amp;node) &#123;</span><br><span class="line">  <span class="built_in">Remove</span>();</span><br><span class="line"></span><br><span class="line">  next       = &amp;node;</span><br><span class="line">  prev       = node.prev;</span><br><span class="line">  node.prev  = <span class="keyword">this</span>;</span><br><span class="line">  prev-&gt;next = <span class="keyword">this</span>;</span><br><span class="line">  head       = node.head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">================</span></span><br><span class="line"><span class="comment">idLinkList&lt;type&gt;::AddToEnd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Adds node at the end of the list</span></span><br><span class="line"><span class="comment">================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;</span><br><span class="line"><span class="type">void</span> idLinkList&lt;type&gt;::<span class="built_in">AddToEnd</span>(idLinkList &amp;node) &#123;</span><br><span class="line">  <span class="built_in">InsertBefore</span>(*node.head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ent-&gt;spawnNode.<span class="built_in">AddToEnd</span>(spawnedEntities);</span><br></pre></td></tr></table></figure><h3 id="Boost-Intrusive"><a href="#Boost-Intrusive" class="headerlink" title="Boost Intrusive"></a>Boost Intrusive</h3><p><a href="https://www.boost.org/doc/libs/1_79_0/doc/html/intrusive/list.html">https://www.boost.org/doc/libs/1_79_0/doc/html/intrusive/list.html</a></p><p>Boost 的侵入式容器为通用性做了很多考虑，搞得代码特别复杂。如果你的场景比较简单，个人建议还是谨慎考虑是否直接使用 Boost 的侵入式容器。如何需要混合使用多种类型的非侵入式容器（链表，哈希表，b树等等），再考虑一下要不要使用 Boost。</p><p>Boost 提供了两种制造侵入式容器的方法，一种和上面提到的做法差不多，就是使用 member hook，缺点就是不能处理虚继承关系；另一种则是使用 base hook，通过继承关系来注入侵入式容器的相关变量，然后通过继承时配置不同的 tag 来区分不同的侵入式容器。</p><p>总体来说，感觉 Boost 的做法要比上面强行加一个 <code>owner</code> 字段的方式要干净一些。因为用户在使用的时候，肯定就得为 Standard Layout 的对象使用 member hook，而对非 Standard Layout 的对象使用 base hook。而 base hook 是可以拿到 <code>this</code> 指针的，所以也就不需要 owner 字段存储 <code>this</code> 了。</p><p><strong>Google QUICHE</strong></p><p><a href="https://github.com/google/quiche/blob/977f5bf82a47fb833ab8e5a5cea2c8a593fb6add/quiche/spdy/core/spdy_intrusive_list.h">https://github.com/google/quiche/blob/977f5bf82a47fb833ab8e5a5cea2c8a593fb6add/quiche/spdy/core/spdy_intrusive_list.h</a></p><p>这个实现和 Boost 的 base hook 差不多，但是因为不用考虑那么多 case，实现上要”干净”不少，而且目测和 STL 的兼容程度更高一些。</p><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p><a href="https://llvm.org/docs/ProgrammersManual.html?highlight=ilist#llvm-adt-ilist-h">https://llvm.org/docs/ProgrammersManual.html?highlight=ilist#llvm-adt-ilist-h</a></p><p><a href="https://github.com/llvm/llvm-project/blob/llvmorg-14.0.4/llvm/include/llvm/ADT/ilist.h">https://github.com/llvm/llvm-project/blob/llvmorg-14.0.4/llvm/include/llvm/ADT/ilist.h</a></p><p>这个实现和 Boost 的 base hook 是一个意思。但是把一些逻辑抽出来放到 <code>ilist_traits</code> 里面了，以及对于是否去设置哨兵元素做了一些处理。</p><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><h3 id="Unrolled-linked-lists"><a href="#Unrolled-linked-lists" class="headerlink" title="Unrolled linked lists"></a>Unrolled linked lists</h3><p><a href="https://www.wikiwand.com/en/Unrolled_linked_list">https://www.wikiwand.com/en/Unrolled_linked_list</a></p><h3 id="不用链表"><a href="#不用链表" class="headerlink" title="不用链表"></a>不用链表</h3><p><code>vector</code> 和删除标记，延迟 compaction。但是不能保证 <code>iterator</code> 不失效。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.boost.org/doc/libs/1_79_0/doc/html/intrusive/intrusive_vs_nontrusive.html">https://www.boost.org/doc/libs/1_79_0/doc/html/intrusive/intrusive_vs_nontrusive.html</a></li><li><a href="https://www.gamedeveloper.com/programming/in-depth-intrusive-lists">https://www.gamedeveloper.com/programming/in-depth-intrusive-lists</a></li><li><a href="https://news.ycombinator.com/item?id=8795745">https://news.ycombinator.com/item?id=8795745</a> They moved away from intrusive lists to vectors in the BFG edition for performance reasons.</li><li><a href="https://stackoverflow.com/questions/1129894/why-cant-you-use-offsetof-on-non-pod-structures-in-c">https://stackoverflow.com/questions/1129894/why-cant-you-use-offsetof-on-non-pod-structures-in-c</a></li></ol>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Data-Structure/">Data Structure</category>
      
      
      <comments>http://hcoona.github.io/Data-Structure/instrusive-linked-list-summary/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[SOSP&#39;01] SEDA: An Architecture for Well-Conditioned, Scalable Internet Services</title>
      <link>http://hcoona.github.io/Paper-Note/seda/</link>
      <guid>http://hcoona.github.io/Paper-Note/seda/</guid>
      <pubDate>Mon, 28 Feb 2022 14:36:11 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;staged event-driven architecture (SEDA) 框架在建模的时候就将负载和资源瓶颈考虑在内，从而可以在高负载的情况下也能工作良好，并且有效防止服务过载。SEDA 架构的基本思想是将业务逻辑切分成一系列通过 queues 连接起来的 stages，组合成一个 data flow 网络去执行。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;很久之前就看到过 SEDA 的论文，当时没有太过在意，因为这个 idea 实在是太简单了。最近这几年在多租户系统的隔离性，延迟稳定性方面进行了一些比较深入的工作，又加上最近看到了比较相关的论文和文章之后，突然又产生了一些触动，决定把这篇文章再捞起来写上几句。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>staged event-driven architecture (SEDA) 框架在建模的时候就将负载和资源瓶颈考虑在内，从而可以在高负载的情况下也能工作良好，并且有效防止服务过载。SEDA 架构的基本思想是将业务逻辑切分成一系列通过 queues 连接起来的 stages，组合成一个 data flow 网络去执行。</p></div><div class="paragraph"><p>很久之前就看到过 SEDA 的论文，当时没有太过在意，因为这个 idea 实在是太简单了。最近这几年在多租户系统的隔离性，延迟稳定性方面进行了一些比较深入的工作，又加上最近看到了比较相关的论文和文章之后，突然又产生了一些触动，决定把这篇文章再捞起来写上几句。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>我们接下来还是先跟着论文的思路走，然后再补充一些其他相关资料。</p></div><div class="sect1"><h2 id="_相关工作">相关工作</h2><div class="sectionbody"><div class="sect2"><h3 id="_基于线程并发">基于线程并发</h3><div class="paragraph"><p>最简单直接的方式就是每来一个请求就启动一个线程去处理。这么做的好处是编程模型极其简单，调度隔离之类的问题都交给操作系统来保证了，也比较可靠。缺点是在负载较高的时候，会产生不可忽视的开销。因为物理资源是有限的，尽管操作系统层面做了一层抽象，使得看起来我们可以获得非常多的资源，但是这都是假象，在高负载情况下会暴露无遗。每个线程分到的时间片都是有限的，非常多的线程在频繁的进行上下文切换，缓存在不断的抖动，线程调度的开销随着问题规模增加而增加，锁资源争用，这些因素都会带来性能的急剧下降。而且线程频繁创建和销毁也会带来可观的开销。从作者给的图表来看，超过系统承载能力之后再持续加压，会导致系统性能下降。我们预期通过某些手段能够自保，从而维持在巅峰性能附近。</p></div><div id="per-thread-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/seda-fig-1-2.png" alt="线程并发架构"></div><div class="title">Figure 1. 线程并发架构</div></div></div><div class="sect2"><h3 id="_基于线程池并发">基于线程池并发</h3><div class="paragraph"><p>一个简单的改进方法就是使用线程池。这样的话至少可以解决线程数量过多带来的问题。作者在这里提到，在高负载情况下，这样会带来公平性问题。</p></div><div class="paragraph"><p>公平性问题在多租户系统中确实是一个非常重要的问题，也是系统规模做到一定程度时必须面对的一个问题。这里稍微啰嗦一下，展开说两句。简单来说，多租户服务的资源利用率是远高于单租户服务的。租户足够多，且足够多样性的情况下，有的用户在忙的时候，通常也有一些用户在空闲。这样就带来了整体利用率上的提升。首先我们要做到公平，这样就不会因为有一个人意外使用了特别多的资源，而影响到其他正常使用服务的用户。否则由于用户体验的下降，用户会拒绝使用你的服务。更进一步的，也许我们需要对用户进行分级服务，高优先级的用户可以抢占使用低优先级用户的资源，当然定价可能也是分级的。</p></div><div class="paragraph"><p>作者提到的公平性问题发生在这样的场景下。负载特别高的情况下，我们处理请求的速度跟不上产生请求的速度。大量的请求堆积在任务分发队列，甚至是网络协议栈上。在这种情况下新来的一个请求，其整体延迟应该是排队等待的延迟加上实际执行处理的延迟。而排队等待延迟是不可控的，并且由于过载的问题没有办法得到妥善的调度，因此有违公平性。</p></div><div class="paragraph"><p>这里我部分同意作者的结论。从纯理论的角度上看这个问题，确实没有一个非常完美的解决方法。从比较符合实际情况的角度来看，我们其实还是有些事情可以做的，并且在一些情况下能够取得很好的效果。如果考虑 DoS（Denial of Service）攻击，那别说你的服务了，可能连网络设备都给你打爆了，这种情况下我们已经没办法从软件层面很好的进行一个处理了。更常规的情况是，有部分用户的请求量异常，超出他们自己的配额，但是没有超出整个服务的承载能力，或者超出了整个服务的承载能力，但是不是特别夸张，比如说只超出了一两倍（取决于你业务逻辑的复杂程度）。对于前者，我们通过配额管理，可以在这个请求被调度进行处理的时候，将这个请求拒绝掉，从而避免了执行业务逻辑的负担。通过这种方式，我们可以一定程度上提高我们系统的承载能力。如果负载进一步上升，可能我们拒绝的速度都追不上产生请求的速度，这种情况下，也许我们可以采取网卡队列管理的一些策略，例如 Random Early Discard，进一步提升我们系统的承载能力（但是已经是有损的了）。</p></div><div class="paragraph"><p>作者也举例了一种比较有意思的场景。比如说空闲的时候来了几个比较大的请求，把线程池里面的线程都用上了（但是没有后续排队的请求）；然后突然来了一堆小请求，尽管我们如果多一个空闲线程就能处理过来，但是现在没有任何一个活动线程能来得及干这个事情，然后就把等待队列打爆了。这可能需要 case-by-case 的去做一些更精细的策略调整，比如说对请求大小进行分类，避免一种请求把所有活动线程都占了。</p></div><div class="paragraph"><p>这篇论文写的还比较早，而且主要是和 HTTP Server 相关的调研，感觉确实可能模型和数据处理上都比较简单。所以很多时候说线程池模型的时候真的可能就是直接把请求塞到线程池里直接跑，而没有考虑更多的设计。</p></div></div><div class="sect2"><h3 id="_基于事件驱动并发">基于“事件驱动”并发</h3><div class="paragraph"><p>从作者的大致描述来看，感觉就是一个传统的使用 epoll 驱动的事件模型。几乎所有的 blocking I/O 都被转化成了 event，然后再被投递到各个子模块中继续处理。每个子模块自己使用状态机管理状态，这样 request context 就被状态机管理起来，而不是直接放到 thread context 上了。这个模型显而易见的比多线程模型要复杂得多。</p></div><div class="olist arabic"><ol class="arabic"><li><p>每个子模块需要小心的维护 request context</p></li><li><p>所有的业务逻辑需要尽可能地避免 blocking，否则可能阻塞 event dispatcher</p></li><li><p>每新增一个子模块可能就需要修改 event dispatcher 的逻辑，特别是调度 event 的逻辑（比如说同一类 event 聚合一波一起处理可能会增加缓存命中率进而提高效率）</p></li></ol></div><div id="event-driven-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/seda-fig-3-4.png" alt="事件驱动并发架构"></div><div class="title">Figure 2. 事件驱动并发架构</div></div></div><div class="sect2"><h3 id="_structured_event_queues">Structured event queues</h3><div class="paragraph"><p>这里就是介绍了一些对 event driven concurrency 的改进工作吧，就大概说了说，我也没看出什么比较有价值的东西，先略过了。</p></div></div></div></div><div class="sect1"><h2 id="_the_staged_event_driven_architecture">The Staged Event-Driven Architecture</h2><div class="sectionbody"><div class="paragraph"><p>所以总的来说，就是 event-driven 的架构是性能上更好的，但是编程的复杂度也大大上升。是否有可能搞一个模型兼顾性能和开发便利性呢，这就是作者提出来的 SEDA。SEDA 考虑了这些方面：</p></div><div class="olist arabic"><ol class="arabic"><li><p>支持大并发量高负载（尽可能使用 event-driven 带来的性能优势）</p></li><li><p>简化系统构建难度</p></li><li><p>系统可以感知当前的负载并以此做出调整（例如降级部分请求等等）</p></li><li><p>系统拥有一定的自我调节能力（例如每个阶段所使用的线程池大小，不是静态指定的，而是根据负载等情况自动调整出来的）</p></li></ol></div><div id="event-driven-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/seda-fig-5-6-7.png" alt="事件驱动并发架构"></div><div class="title">Figure 3. 事件驱动并发架构</div></div><div class="paragraph"><p>然后这个架构本身没什么太多可说的，因为论文中也没说怎么去划分 stage 合理，大家凭感觉吧……按照我个人的理解，可能在这些地方是需要划分 stage 的。</p></div><div class="olist arabic"><ol class="arabic"><li><p>需要的并发度不同</p></li><li><p>需要逻辑分叉</p></li><li><p>需要内部重试，但是内部存在异步操作，所以只能通过类似 requeue 的方式来做</p></li><li><p>逻辑上需要在这里拆开</p></li></ol></div><div class="paragraph"><p>这种做法有点类似于 actor model（这里就不展开介绍了 actor model 了，感兴趣的可以看看 akka 的文档和 erlang）。但是传统的 actor model 是把线程 attach 到 actor 上而非 mailbox 上的。但是确实看起来把运算资源 attach 到 queues 或者说 scheduler 上可能更合理一些。Apache Hadoop 和 Microsoft Orleans 貌似都是这么做的。</p></div><div class="paragraph"><p>作者在论文里提到了，在 stage 之间是搞一个 event queue 比较好，还是直接做 subroutine call 比较好。论文中说主要是为了解耦。但是后面 retrospective <a href="#2">[2]</a> 的时候又说，这里其实才是精髓，要把 load &amp; resource bottlenecks 建模在架构上（也就是这里的 event queue），才能解决 load 高 resource 不足的时候系统行为异常的问题。个人十分认同这一点。</p></div><div class="paragraph"><p>论文里还提到了线程池是可以自我调节的，这里提到了可以调节线程池的线程数和一次执行时候的批大小。带自动伸缩功能的线程池其实不算太少见，但是在设计 API 的时候就考虑批执行的 API 还是比较少见的。以个人的经验来看，批执行确实有可能显著的提升计算能力，主要考虑这些方面。</p></div><div class="olist arabic"><ol class="arabic"><li><p>更少的锁争用（拿一次锁可以跑一批数据而非只跑一条数据）</p></li><li><p>更好复用一些临时资源</p></li><li><p>更好的缓存利用</p></li><li><p>可能从 SIMD 指令集中受益</p></li></ol></div><div class="paragraph"><p>在一些特殊的场景中也有可能使用更复杂的策略。例如在 <a href="#3">[3]</a> 中就使用了更复杂的全局策略来优化整体（end-to-end）的计算延迟。</p></div><div class="paragraph"><p>论文后面的部分还有一些细节地方，比如异步 I/O，降级策略等等，和这个核心思想关联性不强，就不展开说了。</p></div></div></div><div class="sect1"><h2 id="_a_retrospective_on_seda">A Retrospective on SEDA</h2><div class="sectionbody"><div class="paragraph"><p>一开始简单地说了一下历史，主要是说当时论文关注的点和现在大家关注的点可能有些地方不太一样。另外就是说这个论文是个关于架构而非实现的论文，所以大家不要用梨和苹果对比。</p></div><div class="sect2"><h3 id="_哪里做错了">哪里做错了</h3><div class="paragraph"><p>首先是 stage 的抽象没问题，很好的隔离了不同的模块。但是不是每个 stage 都需要和线程池绑定起来，有些地方可能把 stage 组合起来放到一个线程池上（concurrency boundaries）再去跑更合理。不需要线程池的地方也就不需要 event queue 了，直接方法调用效率更高。这我觉得可能也不需要太多解释，主要就是平时都是在低负载情况下的，没事搞好几个线程池和 event queue 本来就挺奇怪的。而且 stage 这个抽象本身就是逻辑上的抽象，非得跟线程池绑定起来也很奇怪。</p></div><div class="paragraph"><p>然后说了一些实现细节，当时 Java 还没有 non-blocking I/O。总之这方面不关键，就不说了。</p></div></div><div class="sect2"><h3 id="_哪里做对了">哪里做对了</h3><div class="paragraph"><p>用 Java 写太对了（日常迫害 C/C&#43;&#43;）!</p></div><div class="paragraph"><p>在建模的时候就考虑 load &amp; resource bottlenecks。一个原因是你能很直观的看出来瓶颈在哪儿（只需要看看队列哪儿长）。另一个原因是，你的服务不能只在低负载下正常跑，负载逼近极限就凉凉了。</p></div></div><div class="sect2"><h3 id="_其他">其他</h3><div class="paragraph"><p>然后还说了说测试集也很重要，有些测试集也压根就没考虑高负载的情况。而且也没考虑到测试内存瓶颈，I/O瓶颈，Socket 压力等等。反正就是吐槽了一下测试设计吧，大家做性能测试的时候引以为戒，也不要轻信这种特定场景下得出的测试数据，参考价值比较有限。</p></div></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="seda"></a>[1] Welsh M, Culler D, Brewer E. SEDA: An architecture for well-conditioned, scalable internet services[J]. ACM SIGOPS operating systems review, 2001, 35(5): 230-243.</p></li><li><p><a id="seda-retro"></a>[2] Welsh M. A Retrospective on SEDA. <a href="https://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html" class="bare">https://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html</a></p></li><li><p><a id="cameo"></a>[3] Xu L, Venkataraman S, Gupta I, et al. Move fast and meet deadlines: Fine-grained real-time stream processing with cameo[C]//18th USENIX Symposium on Networked Systems Design and Implementation (NSDI 21). 2021: 389-405.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Architecture/">Architecture</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/seda/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[EDBT&#39;16] Designing Access Methods: The RUM Conjecture</title>
      <link>http://hcoona.github.io/Paper-Note/rum-conjecture/</link>
      <guid>http://hcoona.github.io/Paper-Note/rum-conjecture/</guid>
      <pubDate>Thu, 07 May 2020 13:59:54 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;RUM 猜想指的是在 &lt;strong&gt;R&lt;/strong&gt;ead Overhead，&lt;strong&gt;U&lt;/strong&gt;pdate Overhead 和 &lt;strong&gt;M&lt;/strong&gt;emory (or Storage) Overhead 中，同时优化 2 项时需要以剩余的 1 项劣化作为代价。论文原作者进一步解释了一下，在一定程度以内（还没有达到最优的情况下）优化，不遵循 RUM 猜想，但是达到一定阈值后，就需要付出代价才能进一步进行优化。这里的 Update Overhead 只考虑写放大，不考虑写时寻址的代价。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The RUM Conjecture: Read, Update, Memory – Optimize Two at the Expense of the Third.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;designing access methods that set an upper bound for two of the
RUM overheads, leads to a hard lower bound for the third overhead
which cannot be further reduced.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;论文原作者解释，提出这一猜想不是说大家啥都不用干了，而是说在达到优化阈值后，如果不想付出某一项性能劣化的代价，应当考虑自适应调整之类的方法，根据数据的特征在这三个重要的参数之间进行平衡。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;RUM-Aware Access Method Design. Accepting that a perfect access
method does not exist, does not mean the research community
should stop striving to improve; quite the opposite. The RUM Conjecture
opens the path for exciting research challenges towards the
goal of creating RUM-aware and RUM-adaptive access methods.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;P.S. 这篇论文也由相同的作者在 SIGMOD&#39;16 上发表了几乎相同的内容&lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>RUM 猜想指的是在 <strong>R</strong>ead Overhead，<strong>U</strong>pdate Overhead 和 <strong>M</strong>emory (or Storage) Overhead 中，同时优化 2 项时需要以剩余的 1 项劣化作为代价。论文原作者进一步解释了一下，在一定程度以内（还没有达到最优的情况下）优化，不遵循 RUM 猜想，但是达到一定阈值后，就需要付出代价才能进一步进行优化。这里的 Update Overhead 只考虑写放大，不考虑写时寻址的代价。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>The RUM Conjecture: Read, Update, Memory – Optimize Two at the Expense of the Third.</p></div></blockquote></div><div class="quoteblock"><blockquote><div class="paragraph"><p>designing access methods that set an upper bound for two of theRUM overheads, leads to a hard lower bound for the third overheadwhich cannot be further reduced.</p></div></blockquote></div><div class="paragraph"><p>论文原作者解释，提出这一猜想不是说大家啥都不用干了，而是说在达到优化阈值后，如果不想付出某一项性能劣化的代价，应当考虑自适应调整之类的方法，根据数据的特征在这三个重要的参数之间进行平衡。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>RUM-Aware Access Method Design. Accepting that a perfect accessmethod does not exist, does not mean the research communityshould stop striving to improve; quite the opposite. The RUM Conjectureopens the path for exciting research challenges towards thegoal of creating RUM-aware and RUM-adaptive access methods.</p></div></blockquote></div><div class="paragraph"><p>P.S. 这篇论文也由相同的作者在 SIGMOD'16 上发表了几乎相同的内容<a href="#2">[2]</a>。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>先来看几个极端情况：</p></div><div class="olist arabic"><ol class="arabic"><li><p>\(\min(RO) = 1.0 \implies UO = 2.0 \,\text&#123;and&#125;\, MO \to \infty\)</p></li><li><p>\(\min(UO) = 1.0 \implies RO \to \infty \,\text&#123;and&#125;\, MO \to \infty\)</p></li><li><p>\(\min(MO) = 1.0 \implies RO = N \,\text&#123;and&#125;\, UO = 1.0\)</p></li></ol></div><div class="paragraph"><p>第 1 种情况是我们将读性能优化到极致，类似于哈希表的极端情况，即我们穷举所有可能的 Key Space，为每一个 Key 安排一个固定的空间。这种情况下存储空间的使用量是无界的（或者说实际意义上无界的），因为穷举整个 Key Space 并为每个 Key 预留 Value 大小的空间在大多数情况下是不实际的。</p></div><div class="paragraph"><p>第 2 种情况为写性能优化到极致，简单来说就是一个 Append-Only 的写请求日志。由于我们从来不实际上删除任何内容，所以存储空间是无界的。而写请求需要遍历全部日志，因此也是无界的。</p></div><div class="paragraph"><p>第 3 种情况为将存储空间优化到极致。类似于第 2 种情况但是所有的更新操作都在原地进行。</p></div><div class="paragraph"><p>显然这 3 种只优化一个目标的极端情况都是不实用的。接下来我们考虑同时优化 2 种目标的情况。论文作者提出这样一种假设：在 RUM 中同时优化任意 2 个目标，都需要付出降低剩下的 1 个指标为代价。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>The RUM Conjecture. An access method that can set an upperbound for two out of the read, update, and memory overheads, alsosets a lower bound for the third overhead.</p></div></blockquote></div><div class="paragraph"><p>一些常见的 Access Methods 在 RUM 中的视角如 <a href="#popular-in-rum">常见的 Access Methods 在 RUM 中的视角</a> 所示，他们的时间复杂度（大O表示法）如 <a href="#popular-in-rum-bigo">常见的 Access Methods 的时间复杂度</a> 所示。</p></div><div id="popular-in-rum" class="imageblock text-center"><div class="content"><img data-src="/images/popular-in-rum.png" alt="常见的 Access Methods 在 RUM 中的视角"></div><div class="title">Figure 1. 常见的 Access Methods 在 RUM 中的视角</div></div><div id="popular-in-rum-bigo" class="imageblock text-center"><div class="content"><img data-src="/images/popular-in-rum-bigo.png" alt="常见的 Access Methods 的时间复杂度"></div><div class="title">Figure 2. 常见的 Access Methods 的时间复杂度</div></div><div class="paragraph"><p>直觉上考虑一下这个问题。为了读性能优化的数据结构类似于上面第 1 种极端情况的思路，就是在写的时候多做点事情，同时多付出一些冗余的存储空间记录一些辅助查询的信息。为了写性能优化的数据结构类似于上面第 2 种极端情况的思路，在写的时候少做点事情，增加了查询时候的负担。为了给查询减负，又在时间上进行均摊，将本应该在一次写请求中做完的事情拆成上半部和下半部，在非关键路径上执行下半部，将写日志进行重整合并。为了存储空间优化的主要思路是压缩或者牺牲精度，一般都需要同时损失一些读写性能。</p></div><div class="sect1"><h2 id="_参考文献">参考文献</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="rum-conjecture"></a>[1] ATHANASSOULIS M, KESTER M, MAAS L, et al. Designing Access Methods: The RUM Conjecture[C]//International Conference on Extending Database Technology (EDBT). Bordeaux, France: 2016.</p></li><li><p><a id="tradeoffs"></a>[2] ATHANASSOULIS M, IDREOS S. Design Tradeoffs of Data Access Methods[C]//Proceedings of the 2016 International Conference on Management of Data. New York, NY, USA: Association for Computing Machinery, 2016: 2195–2200.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Database/">Database</category>
      
      <category domain="http://hcoona.github.io/tags/Storage-Engine/">Storage Engine</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/rum-conjecture/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>自制分布式存储系统入门篇：系统概要设计</title>
      <link>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-3/</link>
      <guid>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-3/</guid>
      <pubDate>Sat, 08 Feb 2020 05:01:05 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p><span id="more"></span></p></div><div class="sect2"><h3 id="_最终用户_api">最终用户 API</h3><div class="paragraph"><p>最简单的 Key-Value 存储只需要实现 Put 和 Get 方法就可以了，但是如果只提供这 2 个 API，在遇到一些比较复杂的场景时，就会给调用方带来比较大的负担。甚至于一些需要一致性保证的场景下，无法单靠调用方来完成这些功能。</p></div><div class="paragraph"><p>Redis 是一个比较成熟的，得到广泛应用的 NoSQL 存储，我们可以参考 Redis 的接口设计，实现其中利用率比较高的一些 API。</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">方法名</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">含义</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Get by key</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">GETSET</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set, returning old value</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MGET</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Get multiple</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set by key</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SETNX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set if doesn&#8217;t exist</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SETXX</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set if exist</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">MSET</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Set multiple</p></td></tr></tbody></table><div class="paragraph"><p>除此之外再加上一个 Exists 判断给定的 Key 是否存在但不返回其内容。</p></div><div class="paragraph"><p>这里需要特别注意的是，MSET 应该具有原子性——要么都成功，要么都失败。MGET 和 MSET 这 2 个成对的操作理应满足一定的一致性原则，例如不应该出现 fractured reads <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>，但是这样做的实现难度较高，我们暂时先不考虑。</p></div></div><div class="sect2"><h3 id="_整体架构">整体架构</h3><div class="paragraph"><p>目标系统的架构如<a href="#architecture-diagram">系统架构图</a>所示：</p></div><div id="architecture-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/系统架构图.svg" alt="系统架构图"></div><div class="title">Figure 1. 系统架构图</div></div><div class="paragraph"><p>所有的用户请求首先进入 API Server，然后由 API Server 处理系统内部的逻辑。API Server 周期性的与 MetadataServer 同步数据的拓扑信息，例如哪些 DataServer 持有哪些数据，然后将用户的请求转发给对应的 DataServer。DataServer 是数据的真正持有者，服务的真正提供者。DataServer 与 MetadataServer 周期性的进行同步，向 MetadataServer 汇报自己的状态信息，接受 MetadataServer 的控制指令。</p></div></div><div class="sect2"><h3 id="_主要流程">主要流程</h3><div class="sect3"><h4 id="_用户进行_mget_请求">用户进行 MGET 请求</h4><div id="mget-sequence-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/用户MGET请求时序图.svg" alt="用户MGET请求时序图"></div><div class="title">Figure 2. 用户MGET请求时序图</div></div><div class="paragraph"><p>用户进行 MGET 请求时，首先将请求发送给 API Server。API Server 周期性的与 Metadata Server 进行消息同步，以获取整个集群中的拓扑关系，这一关系中含有哪些数据存放在哪些 Data Server 的映射关系。API Server 将请求发送给对应的一个或多个 Data Server，将获取到的数据进行聚合后，回复给用户。</p></div></div><div class="sect3"><h4 id="_用户进行_put_请求">用户进行 PUT 请求</h4><div id="put-sequence-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/用户PUT请求时序图.svg" alt="用户PUT请求时序图"></div><div class="title">Figure 3. 用户PUT请求时序图</div></div><div class="paragraph"><p>用户进行 PUT 请求时，首先将请求发送给 API Server。API Server 将数据写入对应的 Data Server 中，然后向该数据分片的主节点请求提交该请求。主从节点内部协调后，向 API Server 返回协调后的结果。API Server 向用户返回该结果。</p></div><div class="paragraph"><p>如果 PUT 的 Value 特别小的话，随着控制指令进行主从协调可以节省一些消息交互。但是更多的情况下，Value 没有这么小。此时由 API Server 进行数据复制，比主节点进行复制更合理，因为 API Server 的数量是随着请求负载增长而增长的，但是主节点的数量并不具有这样的关系，因此这样做可以降低主节点的压力。</p></div></div></div><div id="footnotes"><hr><div class="footnote" id="_footnotedef_1"><a href="#_footnoteref_1">1</a>. 见<a href="https://zhuanlan.zhihu.com/p/67077901">论文笔记：[CONCUR'15] A Framework for Transactional Consistency Models with Atomic Visibility</a> 中的 Read Atomic 一致性模型。</div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Distributed-Storage-From-Scratch-Easy/">Distributed Storage From Scratch(Easy)</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Hands-on-Lab/">Hands-on Lab</category>
      
      
      <comments>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>自制分布式存储系统入门篇：背景介绍</title>
      <link>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-2/</link>
      <guid>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-2/</guid>
      <pubDate>Sat, 28 Dec 2019 04:52:50 GMT</pubDate>
      
      <description>&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_文件系统和关系型数据库系统&quot;&gt;文件系统和关系型数据库系统&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;提到存储系统，就绕不开成名已久的两大系统：文件系统和关系型数据库系统。这两大系统切实的解决了用户的关键问题，并且演进的比较成熟，是我们实现分布式存储系统的重要参考。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="sect2"><h3 id="_文件系统和关系型数据库系统">文件系统和关系型数据库系统</h3><div class="paragraph"><p>提到存储系统，就绕不开成名已久的两大系统：文件系统和关系型数据库系统。这两大系统切实的解决了用户的关键问题，并且演进的比较成熟，是我们实现分布式存储系统的重要参考。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect3"><h4 id="_传统磁碟硬盘">传统磁碟硬盘</h4><div class="paragraph"><p>首先，我们需要了解一下磁盘的物理特性，这是传统磁盘文件系统的基础。机械磁盘的物理结构大致如<a href="#hard-disk">传统机械磁盘物理结构示意图</a>所示。</p></div><div id="hard-disk" class="imageblock text-center text-center"><div class="content"><img data-src="/images/hard-disk.png" alt="传统机械磁盘物理结构示意图"></div><div class="title">Figure 1. 传统机械磁盘物理结构示意图</div></div><div class="paragraph"><p>每一个硬盘小黑盒内，都由一组磁盘片组成，每个盘片配套一个机械臂和磁头用于读取盘片上的数据。磁盘运行起来就像是老式留声机一样：</p></div><div class="olist arabic"><ol class="arabic"><li><p>盘片持续不断的转动</p></li><li><p>首先机械臂抬起，移动到恰当的磁道位置上</p></li><li><p>然后机械臂落下，磁头读取盘片上记录的数据</p></li></ol></div><div class="paragraph"><p>显而易见的，磁盘读取数据时，需要花费比较大的代价才能够找到自己要读取的数据的位置，这里面的主要开销有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>机械臂抬起，移动到目标磁道，再落下</p></li><li><p>等待盘片转动到目标数据所在的起始位置</p></li></ol></div><div class="paragraph"><p>但是一旦找到了要读取的数据的位置，读取一段连续的数据的开销比较小。</p></div><div class="paragraph"><p>相关对比数据如<a href="#latency-numbers">每个程序员都应该知道的延迟数据（2019 年）</a>所示<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>。</p></div><div id="latency-numbers" class="imageblock text-center"><div class="content"><img data-src="/images/latency-numbers.png" alt="每个程序员都应该知道的延迟数据（2019 年）"></div><div class="title">Figure 2. 每个程序员都应该知道的延迟数据（2019 年）</div></div></div><div class="sect3"><h4 id="_传统磁盘文件系统">传统磁盘文件系统</h4><div class="paragraph"><p>我假设大家对于文件系统提供的接口已经比较熟悉了，在此不过多介绍文件系统接口方面的知识。<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></div><div class="paragraph"><p>传统磁盘文件系统主要解决的是如何在机械磁盘上组织数据，能够安全，方便，快速的存取数据的问题。其基本原理如下<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>：</p></div><div class="olist arabic"><ol class="arabic"><li><p>将磁盘视为一堆连续的块，每个块有固定的大小（如<a href="#ext2-physical-layout">EXT2 文件系统的物理结构</a>所示）</p></li><li><p>将其中一些块用于存放目录数据，另一些块用于存放实际数据</p></li><li><p>文件被视为目录数据中的叶子节点，其内容为一系列 指向实际数据块的指针（如<a href="#ext2-directory">EXT2 目录</a>所示）</p></li></ol></div><div id="ext2-physical-layout" class="imageblock text-center"><div class="content"><img data-src="/images/ext2-physical-layout.gif" alt="EXT2 文件系统的物理结构"></div><div class="title">Figure 3. EXT2 文件系统的物理结构</div></div><div id="ext2-directory" class="imageblock text-center"><div class="content"><img data-src="/images/ext2-directory.gif" alt="EXT2 目录"></div><div class="title">Figure 4. EXT2 目录</div></div><div class="paragraph"><p>我们在设计存储系统时，也可以参考这一思路，将实际数据存储在一系列数据块中；然后建立这些数据的索引，用于快速访问实际数据。</p></div></div><div class="sect3"><h4 id="_传统关系型数据库系统">传统关系型数据库系统</h4><div class="paragraph"><p>传统关系型数据库的整体架构大致如<a href="#database-architecture">数据库系统架构图</a>所示。</p></div><div id="database-architecture" class="imageblock text-center"><div class="content"><img data-src="/images/fntdb07-1-1.png" alt="数据库系统架构图"></div><div class="title">Figure 5. 数据库系统架构图</div></div><div class="paragraph"><p>以一次对数据库的请求为例：</p></div><div class="olist arabic"><ol class="arabic"><li><p>首先需要和数据库建立持续的连接，这部分由最上面的组件 Client Communications Manager 负责。通常数据库需要支持不同的协议，例如 ODBC 和 JDBC，TCP 和本地 Pipe。</p></li><li><p>用户连接建立后，需要对其是否有权限访问目标资源进行检验（Admission Control），如果通过，则为其分配线程资源（Dispatch and Scheduling）</p></li><li><p>接下来用户的请求进入数据库的核心部分，通过组件 Relational Query Processor 进行处理。</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>用户的 SQL 查询首先被解析成为内部表示形式，通常是对应于关系代数的表达式树。</p></li><li><p>接下来 SQL 查询会被进行优化，在此之前一般会有一个 Rewrite 的步骤对 Query 进行一些预处理以简化 Optimizer 的逻辑。</p></li><li><p>经过优化后的 SQL 查询可能包含多个 Operator，这些 Operator 运算的结果还需要组合和串联，这部分工作由 Plan Executor 来执行。</p></li></ol></div></li><li><p>Operator 的执行需要数据库底层进行支持，这部分功能由最下面的组件 Transactional Storage Manager 负责。</p></li></ol></div><div class="paragraph"><p>整个请求处理期间，可能需要从 Catalog Manager 获取表结构，表内容的统计信息等元数据信息。</p></div><div class="paragraph"><p>在我们预计实现的目标系统中，需要关注的点有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>访问权限控制（Admission Control），这里面包含几个方面</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>避免用户操作不属于自己的数据</p></li><li><p>避免一个用户占用太多资源，导致其他用户不能正常访问数据</p></li></ol></div></li><li><p>请求的分发和调度（Dispatch and Scheduling）</p></li><li><p>元信息的管理（Catalog Manager）</p></li><li><p>整个存储的管理（Transactional Storage Manager）</p></li></ol></div><div class="paragraph"><p>限于篇幅，暂不在此展开讨论，有兴趣的同学可以参考一下<a href="https://zhuanlan.zhihu.com/p/72585869">论文笔记：[FTNDB'07] Architecture of a Database System</a></p></div></div></div><div class="sect2"><h3 id="_nosql_和_newsql">NoSQL 和 NewSQL</h3><div class="paragraph"><p>传统的关系型数据经历了相当长的一段繁荣时期。但是随着时代的发展，我们产生和需要处理的数据量急剧增长。根据 <a href="https://www.domo.com/learn/data-never-sleeps-7#/">DOMO 公司的统计</a>，互联网人口数量增长情况如<a href="#internet-population-growth">互联网人口增长趋势</a>所示。数据量的增长带来的一个问题是，这些数据难以（不能）在单一机器上得到有效的存储和处理。</p></div><div id="internet-population-growth" class="imageblock text-center"><div class="content"><img data-src="/images/internet-population-growth.png" alt="互联网人口增长趋势"></div><div class="title">Figure 6. 互联网人口增长趋势</div></div><div class="paragraph"><p>一个比较常见的思路是将数据分布在多台机器上进行存储和处理。传统数据库的分布式方案，江湖俗称分库分表，实际上涉及到两种截然不同的拆分形式：</p></div><div class="olist arabic"><ol class="arabic"><li><p>将同一个数据库中的不同表放在不同的机器上</p></li><li><p>将同一个表的不同行放在不同的机器上</p></li></ol></div><div class="paragraph"><p>前者只要不进行跨表查询，例如 Join 操作，就可以像单机数据库一样使用。遗憾的是，使用传统数据库的主要场景就是基于表之间的关系做查询的，这样的限制还是比较大的。另一方面，随着数据的进一步增长，我们还是面临着一台机器放一张表也有困难的场景，此时就需要将表中的不同行放在不同的机器上。这样做之后，即便是一些简单的 Scan 操作，也需要在多台机器上执行，然后将结果进行一些汇总（聚合）后，再进行使用。</p></div><div class="paragraph"><p>这样的做法表面上好像解决了问题，实际上完全破坏了 SQL 查询接口提供的封装特性。本来我们只需要提供 SQL 语句，数据库系统内部会自动对 SQL 语句进行优化，并完成整套查询操作。但是现在我们不仅要提供 SQL 语句，还要去完成 SQL 执行中的一些功能，例如任务的分发和聚合，而这些功能原本都应该由 SQL 执行引擎（例如 Spark SQL，Flink SQL 等等）去完成。上面说的还都只涉及到普通的查询功能，没有涉及到数据的写入和事务。</p></div><div class="paragraph"><p>这意味着，实际上我们已经不需要单机的系统提供 SQL 层的功能了。我们只需要单机存储系统提供存储相关的功能即可，所有 SQL 层面的工作都应该由所谓的数据库中间件来完成。</p></div><div class="paragraph"><p>另一方面，我们对于单机存储系统又提出了新的要求。由于我们使用更多的机器存放我们的数据并提供服务，整个系统的故障率上升了（\(1 - (1 - \text&#123;单机故障率&#125;)^\text&#123;机器数&#125; &gt; \text&#123;单机故障率&#125;\)，为了照顾数学不好的同学提示一下，当 \(0 &lt; n &lt; 1\) 时 \(n^k &lt; n\)）。我们需要单机存储系统能够组成互备的系统，当一台机器发生故障时，能够自动从另一台机器上恢复数据。</p></div><div class="paragraph"><p>基于这样的背景，NoSQL 运动如火如荼的展开了。表面上看来，大家完全抛弃了 SQL 这一已被证明非常实用的已经发展的比较成熟的存储体系，整体倒退到裸用存储设备的年代。实际上，是整个存储系统从单机系统走向分布式系统的一次涅槃重生。</p></div><div class="paragraph"><p>整体基调虽然确定了，但是具体的实现方式却各有不同。有的人选择实现一个分布式文件系统，理想情况下分布式文件系统的性能和本地文件系统的性能相当，这样的话上层应用几乎无需什么改动，直接跑在分布式文件系统上，就能享受几乎无限大的存储空间。然而遗憾的是，这样的系统在随机访问时的性能仍然难以和本地文件系统相当，更别提 SSD 横空出世后进一步拉大了这一差距。另一方面，即便存储方面的问题得以解决，单机的计算性能仍然难以满足这样的数据量的需求。有的人选择实现一个分布式共享内存系统，这一要求实际上相较于分布式文件系统更为苛刻，因此也因为类似的原因失败了。有的人选择实现分布式对象存储系统（或者叫 Key-Value 存储系统）。这一模型足够简单，但是实际上暗合了磁碟硬盘的模型，即存储空间由一系列 Blocks 组成，因此也得到了较为广泛的应用和很好的发展。</p></div><div class="paragraph"><p>上面说的这些，实际上都是人们还没来得及实现 SQL 时的妥协方案。实际上是先抛开 SQL，解决更原始的问题，之后还是想要把 SQL 加回来的。对于这些方案，称之为 NoSQL 并没有什么不妥。但是在新的时代也确实涌现出了一些新的方法，这些显著不同的方法宣称自己是 NewSQL 或者是 Not only SQL。例如列式存储数据库在部分查询分析场景下的性能可能是传统数据库的 10-100 倍，全内存数据库的 TPS（Transactions Per Second）性能可能是传统数据库的 10-100 倍，等等<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>。</p></div></div><div id="footnotes"><hr><div class="footnote" id="_footnotedef_1"><a href="#_footnoteref_1">1</a>. <a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html">Latency Numbers Every Programmer Should Know</a></div><div class="footnote" id="_footnotedef_2"><a href="#_footnoteref_2">2</a>. <a href="https://www.doc.ic.ac.uk/~pg/publications/Ntzik2017Reasoning.pdf">Reasoning About POSIX File Systems</a></div><div class="footnote" id="_footnotedef_3"><a href="#_footnoteref_3">3</a>. <a href="http://www.science.unitn.it/~fiorella/guidelinux/tlk/node95.html">The Second Extended File system (EXT2)</a>, <a href="http://web.mit.edu/tytso/www/linux/ext2intro.html">Design and Implementation of the Second Extended Filesystem</a></div><div class="footnote" id="_footnotedef_4"><a href="#_footnoteref_4">4</a>. <a href="https://ieeexplore.ieee.org/document/1410100">"One size fits all": an idea whose time has come and gone</a></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Distributed-Storage-From-Scratch-Easy/">Distributed Storage From Scratch(Easy)</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Hands-on-Lab/">Hands-on Lab</category>
      
      
      <comments>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>自制分布式存储系统入门篇：序章</title>
      <link>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-1/</link>
      <guid>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-1/</guid>
      <pubDate>Thu, 26 Dec 2019 04:52:50 GMT</pubDate>
      
      <description>&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_新的开始&quot;&gt;新的开始&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;近几年，随着互联网规模的扩大，我们需要处理的数据也变得越来越多；随着机器学习的发展，我们的数据也变得越来越有价值。在这一时代背景下，大规模分布式系统变得越来越重要。遗憾的是，这一领域由于出现的比较晚，相关的学习资料比较少，大家对这一领域的认识和了解都比较有限。我认识的一些名校毕业名企工作的非常优秀的工程师，虽然日常工作中会使用 Hadoop 生态的一些产品，但是对于大规模分布式系统的底层原理的理解也十分有限。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;于是我认为，将我有限的知识分享出来，让大家能够对分布式存储系统有一个初步的感性认识，仍然是一件非常有意义的事情，于是便准备开始这样一个系列。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="sect2"><h3 id="_新的开始">新的开始</h3><div class="paragraph"><p>近几年，随着互联网规模的扩大，我们需要处理的数据也变得越来越多；随着机器学习的发展，我们的数据也变得越来越有价值。在这一时代背景下，大规模分布式系统变得越来越重要。遗憾的是，这一领域由于出现的比较晚，相关的学习资料比较少，大家对这一领域的认识和了解都比较有限。我认识的一些名校毕业名企工作的非常优秀的工程师，虽然日常工作中会使用 Hadoop 生态的一些产品，但是对于大规模分布式系统的底层原理的理解也十分有限。</p></div><div class="paragraph"><p>于是我认为，将我有限的知识分享出来，让大家能够对分布式存储系统有一个初步的感性认识，仍然是一件非常有意义的事情，于是便准备开始这样一个系列。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>入门篇的目标是实现一个类 Redis 的分布式存储系统，具有以下功能：</p></div><div class="olist arabic"><ol class="arabic"><li><p>大规模：可以支持数千台机器组成存储集群，读写数据将比较均匀的分布在这些机器上（以下称机器为节点）</p></li><li><p>高可用：系统中的每一个节点都有可能发生故障，任意节点发生故障后可以自动进行故障恢复</p></li><li><p>磁盘存储：对每一个节点而言，数据会持久化的存储于磁盘上，但是可以使用内存作为热数据的缓存</p></li><li><p>采用和 Redis 类似的接口（仅限字符串接口），支持一些除了 Get/Put 以外的高级功能</p></li></ol></div><div class="sect3"><h4 id="_系统架构">系统架构</h4><div class="paragraph"><p>目标系统的架构如<a href="#architecture-diagram">系统架构图</a>所示：</p></div><div id="architecture-diagram" class="imageblock text-center"><div class="content"><img data-src="/images/系统架构图.svg" alt="系统架构图"></div><div class="title">Figure 1. 系统架构图</div></div><div class="paragraph"><p>所有的用户请求首先进入 API Server，然后由 API Server 处理系统内部的逻辑。API Server 周期性的与 MetadataServer 同步数据的拓扑信息，例如哪些 DataServer 持有哪些数据，然后将用户的请求转发给对应的 DataServer。DataServer 是数据的真正持有者，服务的真正提供者。DataServer 与 MetadataServer 周期性的进行同步，向 MetadataServer 汇报自己的状态信息，接受 MetadataServer 的控制指令。</p></div></div><div class="sect3"><h4 id="_内容安排">内容安排</h4><div class="paragraph"><p>作为入门篇，这一系列的主线内容是通过边学边练的方式，逐步实现上面提到的系统，但是这个系统的方方面面都会比较简陋，功能并不完善，性能也有待优化。在实现这个系统的每一个小方面时，会先介绍该方面相关的一些基本理论，然后选择其中比较容易实现的一种方式介绍实现细节。具体的内容和顺序大致如下：</p></div><div class="olist arabic"><ol class="arabic"><li><p>介绍相关背景</p></li><li><p>实现一个单机 Key-Value 存储系统，并支持 RPC 调用</p></li><li><p>给单机存储系统增加主从备份的功能</p></li><li><p>通过数据分片的方式，将单机存储系统扩展到多机存储系统</p></li><li><p>增加 API Service 对外隐藏内部实现细节</p></li><li><p>增加事务协调以支持 MGET/MSET 指令</p></li><li><p>其他功能讨论，如 TTL，Snapshot，备份等等</p></li><li><p>如何向全功能的 Redis 演进</p></li><li><p>K8S 和运维自动化</p></li><li><p>如何向 NewSQL 的方向演进</p></li></ol></div><div class="paragraph"><p>文章中的示例实现采用 C&#43;&#43; 语言最新标准进行描述，这是因为在工业界实现存储系统时 C&#43;&#43; 语言占主导地位。</p></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Distributed-Storage-From-Scratch-Easy/">Distributed Storage From Scratch(Easy)</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Hands-on-Lab/">Hands-on Lab</category>
      
      
      <comments>http://hcoona.github.io/Distributed-Storage-From-Scratch-Easy/distributed-storage-from-scratch-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[OSDI&#39;16] Slicer: Auto-Sharding for Datacenter Applications</title>
      <link>http://hcoona.github.io/Paper-Note/google-slicer/</link>
      <guid>http://hcoona.github.io/Paper-Note/google-slicer/</guid>
      <pubDate>Sun, 13 Oct 2019 04:52:50 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Slicer &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; 是 Google 内部支持应用按照 Sharding 的方式进行扩展的，与 RPC 框架集成的基础组件。论文中提到其对比其他通用 Sharding 框架论文的独特之处有：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;控制侧和数据侧分离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高效的负载均衡算法，在尽可能减少 key churn 的情况下提供很好的负载均衡效率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些在大规模生产环境下的 evaluation&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Slicer <a href="#1">[1]</a> 是 Google 内部支持应用按照 Sharding 的方式进行扩展的，与 RPC 框架集成的基础组件。论文中提到其对比其他通用 Sharding 框架论文的独特之处有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>控制侧和数据侧分离</p></li><li><p>高效的负载均衡算法，在尽可能减少 key churn 的情况下提供很好的负载均衡效率</p></li><li><p>提供一些在大规模生产环境下的 evaluation</p></li></ol></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>个人认为其独特之处有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>将存储系统经常需要解决的 Sharding 问题独立出一个基础组件集成到 RPC 框架中，这个想法本身就比较有意思</p></li><li><p>在 Sharding 的基础上可以做一些比较特别的事情，例如：</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>指导应用进行 Sharding 的重分布（类似于 rehashing）</p></li><li><p>支持 Sharding 的分裂与合并</p></li><li><p>屏蔽失效的节点，并且指导应用将失效节点的负载转移到健康节点上继续提供服务</p></li><li><p>为热点增加副本数以承载更高的读负载（论文中提到了这个想法但是貌似没进行实现）</p></li><li><p>提供 key range 粒度的租约控制（论文中使用租约控制来保证这个 key range 同时至多只存在一个服务提供者，但是并没有在生产环境中使用这一功能）</p></li></ol></div></li></ol></div><div class="sect1"><h2 id="_基本思路和整体架构">基本思路和整体架构</h2><div class="sectionbody"><div class="paragraph"><p>Slicer 整体上是在 Centrifuge <a href="#2">[2]</a> 上进行改进，总体有 3 个主要部分，见<a href="#slicer-architecture">Abstract Slicer architecture</a>：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Slicer Service: 系统核心部分，负责控制 Shard 的分布并提供查询</p></li><li><p>Clerk: 嵌入到客户端 RPC 库中的部分，负责和 Slicer Service 进行交互，指导 RPC 请求的路由</p></li><li><p>Slicelet: 嵌入到服务器端的部分，负责和 Slicer Service 进行交互，接受 Slicer Service 对于 Shard 重分布的控制</p></li></ol></div><div id="slicer-architecture" class="imageblock text-center text-center"><div class="content"><img data-src="/images/slicer-abstract-architecture.png" alt="Abstract Slicer architecture"></div><div class="title">Figure 1. Abstract Slicer architecture</div></div><div class="paragraph"><p>这里的核心思想在于由 Slicer Service 控制 Logical Shard（论文中为 key range）和 Physical Server（论文中称为 task）之间的映射关系，并且根据反馈信息进行适当的调整。</p></div><div class="paragraph"><p>出于 Availability 的考虑，Slicer 对于 Slicer Service 进行了进一步的拆分，见<a href="#slicer-backend-architecture">Slicer backend service architecture</a>：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Assigner: 负责调整和控制 Logical Shard 和 Physical Server 之间的映射关系</p></li><li><p>Distributor: 负责查询（被动分发）Assigner 的控制结果</p></li><li><p>Backup Distributor: Assigner 挂掉时的后备方案</p></li><li><p>Store: Assigner 背后的可靠存储</p></li></ol></div><div id="slicer-backend-architecture" class="imageblock text-center text-center"><div class="content"><img data-src="/images/slicer-backend-service-architecture.png" alt="Slicer backend service architecture"></div><div class="title">Figure 2. Slicer backend service architecture</div></div><div class="paragraph"><p>这样的另一个额外的好处是，如果 Client 和 Assigner 在不同的 DataCenter 中的话，可以将 Distributor 和 Client 部署在同一个 DataCenter 内，节省跨 DataCenter 流量，提升效率（Distributor 自带缓存）。</p></div><div class="paragraph"><p>另一种常见的跨 DataCenter 策略是使用传统的 SLB 进行跨 DataCenter 的中转，见<a href="#centrifuge-cross-datacenter">Centrifuge cross datacenter</a>。</p></div><div id="centrifuge-cross-datacenter" class="imageblock text-center"><div class="content"><img data-src="/images/centrifuge-cross-datacenter.png" alt="Centrifuge cross datacenter"></div><div class="title">Figure 3. Datacenter applications are often divided into multiple component services, and servicing clients requests frequently requires communicating with multiple such services. Centrifuge is designed to replace only the internal network load balancers used by the component services.</div></div></div></div><div class="sect1"><h2 id="_负载均衡">负载均衡</h2><div class="sectionbody"><div class="paragraph"><p>Slicer 使用 RPC 的 Metrics 数据作为输入，对 Shard 进行负载均衡评估，然后进行调整。从之前的架构可以发现，产生一个调整（Assignment）到生效是最终一致的。</p></div><div class="paragraph"><p>Slicer 的负载均衡考虑了以下几个方面：</p></div><div class="olist arabic"><ol class="arabic"><li><p>使得尖峰负载尽可能低</p></li><li><p>在调整的过程中，减少 key churn 的情况</p></li><li><p>key range 的合并和分裂</p></li></ol></div><div class="paragraph"><p>但是不考虑根据负载增加一些 Logical Shard 的副本数量，或者自动调整 Physical Server 的资源。</p></div><div class="paragraph"><p>我们首先考虑怎么抽象负载指标的问题。在 Slicer 中，使用 Load imbalance value 这一经验指标抽象整个系统的负载均衡状况。定义一个 Physical Server 的 load 为其所负责的 Logical Shard 数量，则 Load imbalance value 为整个系统中的最大 load 与平均 load 的比值。</p></div><div class="paragraph"><p>个人觉得这个经验指标看起来有点问题：</p></div><div class="olist arabic"><ol class="arabic"><li><p>其假设整个系统的负载在 key 上是均匀分布的，实际上即便是对于哈希分布的 key space 也可能是不成立的</p></li><li><p>其假设 Logical Shard 的大小是一致的，但是后面又会对 Logical Shard 进行分裂与合并</p></li></ol></div><div class="paragraph"><p>然后是怎么抽象 key churn 的问题。在 Slicer 中，使用一轮调整产生的 key 重分配的比例作为 key churn 的指标。Slicer 对于 CPU 负载较低的 Physical Server 不会进行 key range 的重分配，以此避免过度优化产生的 key churn 开销。</p></div><div class="paragraph"><p>Slicer 进行负载均衡的算法也是经验得出的，里面的一些 threshold 的具体 number 也是经验得出的，在此不再赘述。</p></div></div></div><div class="sect1"><h2 id="_强一致性">强一致性</h2><div class="sectionbody"><div class="paragraph"><p>Slicer 通过租约（Lease）机制实现强一致性（这里强一致性指同一时刻至多只有一个 Physical Server 对 key 提供服务）。需要注意的是租约机制蕴含了时钟对齐的要求。显然我们没办法对每个 key 提供租约管理，一个简单的思路是对 key range 粒度进行租约管理。但是 Slicer 更进一步的可以只使用至多 3 个 Chubby locks 完成租约管理，并且由于租约管理是由 Chubby 进行的，所以即使 Slicer 挂掉也不会影响用户服务。</p></div><div class="olist arabic"><ol class="arabic"><li><p>job lease: 首先需要一个锁来保证同一时刻内只有一个 Assigner 负责整个分配</p></li><li><p>guard lease: Assigner 会为每一轮分配生成一个租约，只有得到租约许可的 slicelet 才可以提供服务，这样当分配更新时，持有过期信息的 slicelet 就会停止提供服务，避免因信息不同步导致的多个 slicelet 对同一个 key 提供服务的情况</p></li><li><p>bridge lease: 如果只使用 guard lease，则在每一轮分配期间，都会导致全服务的 guard lease 整体失效。但是显然每一轮分配只改变了一小部分 key range 的分布，其他没有发生变化的部分不应该受影响。因此对这部分没有变化的分配，引入一个 bridge lease，使其不受 guard lease 失效的影响。</p></li></ol></div><div class="paragraph"><p>个人觉得这个想法还是比较有意思的，相当于 Slicer 既可以控制分配，也可以控制选主，这样只要用户自己实现 replication 机制，就可以很容易的做一个有状态服务了。</p></div><div class="paragraph"><p>Slicelet 中和强一致性相关的 API 如下：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight java">Opaque <span class="title function_">getSliceKeyHandle</span><span class="params">(String key)</span>;<span class="type">boolean</span> <span class="title function_">isAssignedContinuously</span><span class="params">(Opaque handle)</span>;</code></pre></div></div><div class="paragraph"><p>使用的方法类似于这样（参考了 <a href="#2">[2]</a>）：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight java"><span class="type">boolean</span> <span class="title function_">Subscribe</span><span class="params">(String key, String address)</span> &#123;  <span class="comment">// (1) Check that this is the correct node</span>  <span class="type">Opaque</span> <span class="variable">handle</span> <span class="operator">=</span> getSliceKeyHandle(key);  <span class="keyword">if</span> (handle == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// (2) Perform arbitrary operation on this state;</span>  <span class="comment">// store lease number with any created state</span>  <span class="comment">// in this case, simply add subscription</span>  <span class="built_in">this</span>.subscriptionLists[key].add(address);  <span class="comment">// (3) Check that lease has been continuously held;</span>  <span class="comment">// if so, return result</span>  <span class="keyword">if</span> (!isAssignedContinuously(handle)) &#123;    <span class="comment">// Rollback subscription</span>    <span class="built_in">this</span>.subscriptionLists[key].remove(address);    <span class="keyword">return</span> <span class="literal">false</span>;  &#125;  <span class="comment">// Commit subscription</span>  <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre></div></div></div></div><div class="sect1"><h2 id="_与一致性哈希的比较">与一致性哈希的比较</h2><div class="sectionbody"><div class="paragraph"><p>一致性哈希的一个大问题是其哈希算法固定，如果发现数据分布不符合哈希算法的预设的话，几乎没有任何机会进行调整。这在负载均衡的场景下就显得不是那么合适。另一方面，如果想要支持非对称副本数（例如有的 key range 只有 2 副本，但是有的热点 key range 有 200 副本），一致性哈希也是一个很大的限制。</p></div></div></div><div class="sect1"><h2 id="_参考文献">参考文献</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="slicer"></a>[1] ADYA A, MYERS D, HOWELL J, etc. Slicer : Auto-Sharding for Datacenter Applications[J]. Osdi, 2016: 739–754.</p></li><li><p><a id="centrifuge"></a>[2] ADYA A, DUNAGAN J, WOLMAN A. Centrifuge: Integrated Lease Management and Partitioning for Cloud Services[C]. NSDI’10 Proceedings of the 7th USENIX conference on Networked systems design and implementation. USENIX Association, 2010.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Google/">Google</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/google-slicer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[FTNDB&#39;07] Architecture of a Database System</title>
      <link>http://hcoona.github.io/Paper-Note/architecture-of-a-database-system/</link>
      <guid>http://hcoona.github.io/Paper-Note/architecture-of-a-database-system/</guid>
      <pubDate>Sun, 07 Jul 2019 10:47:52 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;数据库系统是非常重要且复杂的系统，但是其架构方面的知识却不像其他重要的系统（例如操作系统，编译器等）一样为人所熟知。传统教材通常着重讲述数据库相关的算法和理论知识，很少涉及到系统开发和架构方面。论文&lt;a href=&quot;#DBS-002&quot;&gt;[1]&lt;/a&gt;使用流行的商业和开源数据库系统作为例子，着重论述（关系型）数据库系统的架构。尽管有些细节方面在这些年中发生了变化，但是大体结构和思路上并没有太多出入。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>数据库系统是非常重要且复杂的系统，但是其架构方面的知识却不像其他重要的系统（例如操作系统，编译器等）一样为人所熟知。传统教材通常着重讲述数据库相关的算法和理论知识，很少涉及到系统开发和架构方面。论文<a href="#DBS-002">[1]</a>使用流行的商业和开源数据库系统作为例子，着重论述（关系型）数据库系统的架构。尽管有些细节方面在这些年中发生了变化，但是大体结构和思路上并没有太多出入。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>这篇论文内容比较多，暂时先不怎么引入自己的想法，只是摘录一些重点内容，以免以后彻底遗忘论文内容。</p></div><div class="sect1"><h2 id="_整体结构">整体结构</h2><div class="sectionbody"><div class="paragraph"><p>数据库系统的整体结构如<a href="#fig-1-1">Figure 1</a>所示。</p></div><div id="fig-1-1" class="imageblock text-center"><div class="content"><img data-src="/images/fntdb07-1-1.svg" alt="fntdb07 1 1"></div><div class="title">Figure 1. 数据库主要组件</div></div><div class="paragraph"><p>以一次对数据库的请求为例：</p></div><div class="olist arabic"><ol class="arabic"><li><p>首先需要和数据库建立持续的连接，这部分由<a href="#fig-1-1">Figure 1</a>中最上面的组件Client Communications Manager负责。通常数据库需要支持不同的协议，例如ODBC和JDBC，TCP和本地Pipe。</p></li><li><p>用户连接建立后，需要为其分配线程资源，这部分由<a href="#fig-1-1">Figure 1</a>中左边的组件完成。通常Admission Control也在这个时期进行。</p></li><li><p>接下来用户的请求进入数据库的核心部分，通过<a href="#fig-1-1">Figure 1</a>中间的组件Relational Query Processor进行处理。</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>用户的SQL查询首先被解析成为内部表示形式，通常是对应于关系代数的表达式树。</p></li><li><p>接下来SQL查询会被进行优化，在此之前一般会有一个Rewrite的步骤对Query进行一些预处理以简化Optimizer的逻辑。</p></li><li><p>经过优化后的SQL查询可能包含多个Operator，这些Operator运算的结果还需要组合和串联，这部分工作由Plan Executor来执行。</p></li></ol></div></li><li><p>Operator的执行需要数据库底层进行支持，这部分功能由<a href="#fig-1-1">Figure 1</a>中最下面的组件Transactional Storage Manager负责。</p></li></ol></div></div></div><div class="sect1"><h2 id="_进程模型">进程模型</h2><div class="sectionbody"><div class="paragraph"><p>数据库是面向多用户的服务，需要具备同时服务多个用户的能力，这需要一些基础的并行执行组件。数据库一般有自己的进程抽象，这是由于大部分数据库需要支持不同的运行环境，而一些早期操作系统对于线程的支持不够好，所以需要数据库自己进行适配。这里使用进程这一名词是因为可能数据库系统可能跨越多个计算节点。</p></div><div class="paragraph"><p>一般数据库协议采用长连接模型，连接建立后会有对应关联的Session信息，维护了当前连接执行的命令的上下文环境，例如是否正在处理Transaction等等。数据库系统一般会为一个客户端连接分配一个对应的DBMS worker进行管理。DBMS worker需要占用一定的计算资源，其采用的进程模型有以下几种情况：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Process per DBMS worker</p></li><li><p>Thread per DBMS worker</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>OS thread per DBMS worker</p></li><li><p>DBMS thread per DBMS worker</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>DBMS threads scheduled on OS process</p></li><li><p>DBMS threads scheduled on OS threads</p></li></ol></div></li></ol></div></li><li><p>Process/thread pool</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>DBMS workers multiplexed over a process pool</p></li><li><p>DBMS workers multiplexed over a thread pool</p></li></ol></div></li></ol></div><div class="paragraph"><p><strong>个人认为</strong>，出现这么多模型的大部分原因是受历史因素拖累，只考虑现代操作系统（尤其是Linux）的话，由于可以较好的支持大量threads，采用这几种模型都是比较合理的：</p></div><div class="olist arabic"><ol class="arabic"><li><p>DBMS threads scheduled on OS threads</p></li><li><p>DBMS workers multiplexed over a thread pool</p></li></ol></div><div class="paragraph"><p>有些时候，数据库还会采用自己的线程库，里面进一步封装了用户态线程（也叫做纤程Fiber）。这样做的优势是可以进一步的减少线程上下文切换带来的开销，缺点是维护成本较高，DEBUG工具和信息也比较少。</p></div></div></div><div class="sect1"><h2 id="_准入控制">准入控制</h2><div class="sectionbody"><div class="paragraph"><p>进行准入控制有以下两方面的考虑因素：</p></div><div class="olist arabic"><ol class="arabic"><li><p>防止一个用户占用过多资源，影响其他用户使用系统</p></li><li><p>拒绝用户访问没有权限访问的内容</p></li></ol></div><div class="paragraph"><p>数据库系统的准入控制一般有以下两个时机：</p></div><div class="olist arabic"><ol class="arabic"><li><p>当用户请求到达时进行准入控制，避免为无效的请求分配资源</p></li><li><p>在执行查询计划时进行控制，因为直到这一时刻才能方便的汇总所有必要的信息，例如将要执行物理查询计划的节点的负载</p></li></ol></div></div></div><div class="sect1"><h2 id="_并行处理架构进程和内存的协作">并行处理架构：进程和内存的协作</h2><div class="sectionbody"><div class="paragraph"><p>数据库系统为了性能考虑，需要更多的考虑进程和内存的协作，常见的几种模型如下：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Shared Memory</p></li><li><p>Shared-Nothing</p></li><li><p>Shared-Disk</p></li><li><p>NUMA</p></li></ol></div><div class="paragraph"><p>目前主流的单机数据库系统都支持了Shared Memory模型，这样做比较容易达到更高的性能。分布式的数据库系统一般使用Shared-Nothing模型，这基本上符合当前的硬件能力，即硬件并不提供（像访问本地节点数据一样可靠的）访问远程节点数据（内存/硬盘）的能力。目前一些新的硬件技术可能会打破这一假设，也是目前比较热点的一些新尝试领域。</p></div><div class="paragraph"><p>采用Shared-Disk模型的分布式数据系统也有不少，这里假设所有进程都能以相似的代价访问共享磁盘。一些设施确实可以做到这一点，例如SAN（Storage Area Networks）。或者将更底层的软件系统视为共享磁盘使用，以此建立Shared-Disk模型的系统，例如BigTable<a href="#bigtable">[2]</a>。</p></div><div class="paragraph"><p>NUMA尽管最早是作为分布式模型提出的，但是并没有在这一领域得到广泛的应用，反而在单机多核架构上发挥了巨大的作用。个人认为这种架构关于访问速度上的假设虽然勉强成立，但是对于可靠性方面的假设却不成立，因此很难在分布式领域得到很好的应用。主流的数据库系统在单机上一般都考虑了NUMA架构的影响。</p></div></div></div><div class="sect1"><h2 id="_关系查询处理relational_query_processor">关系查询处理（Relational Query Processor）</h2><div class="sectionbody"><div class="paragraph"><p>一般而言，关系查询的处理可以视为是单用户单线程执行的任务。并发控制是在更下层进行处理的，对上层提供了几乎透明的接口。查询主要分为两大类：</p></div><div class="olist arabic"><ol class="arabic"><li><p>DML（Data Manipulation Language），例如SELECT/INSERT/UPDATE/DELETE</p></li><li><p>DDL（Data Definition Language），例如CREATE TABLE/CREATE INDEX</p></li></ol></div><div class="sect2"><h3 id="_查询解析和授权query_parsing_and_authorization">查询解析和授权（Query Parsing and Authorization）</h3><div class="paragraph"><p>对于一个SQL语句，解析的主要工作是</p></div><div class="olist arabic"><ol class="arabic"><li><p>检查查询语句是否正确</p></li><li><p>获取名字和引用信息，例如 <code>SELECT c1 FROM t1 JOIN t2 ON t1.id = t2.t1id</code> 中</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p><code>t1</code> 是Table名称，但是需要规范化为4阶段名称 <code>server.database.schema.table</code>，从而精确的定位这个表</p></li><li><p><code>c1</code> 是个列名，这个列是存在于 <code>t1</code> 还是 <code>t2</code> 中，也需要在这个阶段进行处理和规范化</p></li></ol></div></li><li><p>将查询转换为内部表示形式，通常是关系代数对应的内部表示形式</p></li><li><p>检查用户是否有权限执行这个查询</p></li></ol></div><div class="paragraph"><p>上面这些工作一般都需要和Catalog Manager进行协作以获取表相关的元信息。此外，有些运算符还需要根据这些元信息确定类型，例如 <code>(EMP.salary * 1.15) &lt; 75000</code> 中的比较运算符是整数比较，浮点数比较，还是Decimal比较，就取决于 <code>EMP.salary</code> 的类型。</p></div><div class="paragraph"><p>有些约束也可以在这一时刻进行检查，例如 <code>SET EMP.salary = -1</code> 如果具有约束 <code>EMP.salary &gt; 0</code> 的话，就可以在这一时刻检查出来并拒绝。</p></div></div><div class="sect2"><h3 id="_查询重写query_rewrite">查询重写（Query Rewrite）</h3><div class="paragraph"><p>尽管有些数据库系统会将查询重写合并到上面的查询解析模块，或者下面的查询优化模块中，但是逻辑上这还是一个比较独立的功能，其主要功能是：</p></div><div class="olist arabic"><ol class="arabic"><li><p>视图（View）展开</p></li><li><p>常量计算，例如 <code>R.x &lt; 10 + 2 + R.y</code> &#8658; <code>R.x &lt; 12 + R.y</code></p></li><li><p>Predicate重写，例如</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p><code>NOT Emp.salary &gt; 1000000</code> &#8658; <code>Emp.salary &#8656; 1000000</code>（节约了一个Operator）</p></li><li><p><code>Emp.salary &lt; 75000 AND Emp.salary &gt; 1000000</code> &#8658; <code>False</code>（这种情况一般出现于视图展开之后）</p></li><li><p><code>R.x &lt; 10 AND R.x = S.y</code> &#8658; <code>R.x &lt; 10 AND S.y &lt; 10 AND R.x = S.y</code>（逻辑传递关系，有可能利用 <code>S.y</code> 上的索引）</p></li></ol></div></li><li><p>语义优化，例如（常见于视图展开后）</p><div class="listingblock"><div class="content"><pre><code class="highlight sql"><span class="keyword">SELECT</span> Emp.name, Emp.salary  <span class="keyword">FROM</span> Dept  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Emp <span class="keyword">ON</span> Emp.deptno <span class="operator">=</span> Dept.dno</code></pre></div></div><div class="paragraph"><p>由于根本就没用到 <code>Dept</code> 表，所以可以转化成 <code>SELECT Emp.name, Emp.salary FROM Emp</code>。</p></div></li><li><p>子查询展开和其他启发式重写规则</p><div class="paragraph"><p>由于查询优化是比较复杂的问题（NP-hard<a href="#optimizer-np-hard">[3]</a>)，为了保证复杂性上界，在进行查询优化时，一般不会跨越查询单元进行优化。因此在这之前，如果可能的话，将嵌套子查询重写为一个查询，会对后面的查询优化有所帮助。一般而言，在这一阶段会将所有等价的查询重写为一个标准形式。</p></div><div class="paragraph"><p>此外还有一些基于启发式规则或者代价预估进行的优化。</p></div></li></ol></div></div><div class="sect2"><h3 id="_查询优化query_optimizer">查询优化（Query Optimizer）</h3><div class="paragraph"><p>查询优化的主要工作是生成查询计划，目前主流的方法是沿用Selinger等人在实现System R时使用的方法<a href="#system-r-optimizer">[4]</a>。生成的查询计划有多种表示方法。早期的数据库系统为了追求性能一般直接生成机器码；后来为了保证一定的可移植性，一般生成中间结果然后解释执行。</p></div><div class="paragraph"><p>尽管大家都沿用了Selinger的方法，但是也做出了不少改进：</p></div><div class="olist arabic"><ol class="arabic"><li><p>计划空间（Plan space）。出于性能考虑，Selinger通过以下两种手段来缩减计划空间以减少计算量：只针对左偏树（left-deep tree）进行优化，推后执行笛卡尔积（Cartesian product）。但是大多数现代的数据库系统都会对这两种情况进行考虑，即同时针对左偏树和右偏树（bushy tree）进行优化，提前考虑笛卡尔积。</p></li><li><p>选择代价估计（Selectivity estimation）。Selinger简单的通过索引的大小估计表的大小。现代系统一般通过采样获得直方图和其他统计信息进行估计。</p></li><li><p>搜索算法（Search Algorithms）。一些商业数据库系统，特别是Microsoft和Tandem，没有采用Selinger的方法，而是采用一种自顶向下的搜索策略<a href="#cascade-optimizer">[5]</a>。这种搜索策略有时可以减少优化器考虑的计划数量<a href="#top-down-opt">[6]</a>，但是代价是增加优化器的内存使用量。有些系统会在搜索大量表格时会退化到使用启发式规则进行搜索的策略。</p></li><li><p>并发（Parallelism）。现今主流的商业数据库系统都在一定程度上支持了并发处理，并且大多支持了查询内并发。查询优化器需要知道如何在CPU之间，甚至机器之间调度这些parallelized operators。一个简单的思路是采用2级调度策略，一层只考虑在机器之间进行调度，另一层就像传统的优化器一样，只考虑机器内部的CPU之间调度。一些商业数据库系统使用了这样的策略，但是另一些没有使用2级调度，而是综合考虑了网络拓扑和数据分布进行全局调度。</p></li><li><p>自动调整（Auto-Tuning）。数据的特征发生变化时，进行优化的策略也需要相应发生改变。一些公司正在试图通过机器学习等手段进行数据库系统的自动调优。</p></li></ol></div><div class="paragraph"><p>数据库系统通常会缓存一些查询计划以减少重新计算的开销。但是值得注意的是，这些缓存应该在合适的时机失效，例如做出优化决策的假设已经不复存在的时刻。</p></div></div><div class="sect2"><h3 id="_查询执行query_executor">查询执行（Query Executor）</h3><div class="paragraph"><p>查询计划一般是有向图的形式表示的dataflow，将表和operator联系起来。目前大多数现代查询执行引擎都采用iterator模型：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">iterator</span> &#123;  iterator &amp;inputs[];  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;  <span class="function">tuple <span class="title">get_next</span><span class="params">()</span></span>;  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;&#125;</code></pre></div></div><div class="paragraph"><p>每一个operator都继承自iterator。这样一来，operator只需关注自身逻辑即可，无需关注其上下游。</p></div><div class="paragraph"><p>iterator模型的一个特性是数据流和控制流的强耦合，这一模型简化了不少情况下问题的处理。每调用一次 <code>get_next()</code> 方法，当其返回时，就预示着数据到达，并且调用结束，这就是数据流和控制流强耦合的情况。这样做只需一个线程即可驱动整个查询计划的执行，并且无需考虑operator之间性能匹配的问题。由于不需要进行调度和阻塞式等待，这样做也能够较为容易的达到非常高的系统利用率。而并发执行和网络通信可以通过封装exchange iterator的方式来解决<a href="#exchange-op">[7]</a>。</p></div><div class="paragraph"><p>存取数据时，有两种可行的方法。一种是数据正在buffer pool中，此时需要pin buffer page，然后拿到这个tuple的引用进行使用，使用完毕后unpin buffer page，这种称为BP-tuples。另一种是将tuple复制出来使用，称为M-tuples。尽管M-tuples比BP-tuples容易管理，但是效率却低很多，一般只用于特殊情况，例如长查询。</p></div><div class="paragraph"><p>大多数情况下，诸如INSERT/DELETE/UPDATE之类的写请求对应的查询计划非常简单和直接，但是有些特殊情况需要非常小心，特别是涉及到读后写的情况。例如（Halloween problem）“给每个工资低于$20K的员工涨10%的工资”，首先通过索引找到了候选tuple，然后执行更新。但是数据更新会导致索引更新，因此这个tuple执行更新语句过后如果仍然符合过滤条件，有可能会再被选中执行更新。解决的方法一种是使用临时表之类的技术彻底将读和写过程分离，另一种是使用Multi-version之类的技术避免读到更新后的结果。</p></div></div><div class="sect2"><h3 id="_访存方法access_methods">访存方法（Access Methods）</h3><div class="paragraph"><p><a href="#fig-1-1">Figure 1</a>中最下面模块中的Access Methods。个人感觉类似于Plan Executor和Storage Engine的交叉点，也是最底层访问数据的Operator。</p></div><div class="paragraph"><p>这里讨论了几个问题，其中一个是需要将Scan的参数传递给底层，这是出于以下考虑：</p></div><div class="olist arabic"><ol class="arabic"><li><p>需要利用索引</p></li><li><p>可以批量的pin/unpin或者copy/delete符合条件的tuples以提升性能</p></li></ol></div><div class="paragraph"><p>此外还提到了Row ID的选择，尽管使用Physical disk address可以获得更高的性能，但是当B+-tree分裂或者tuple需要移动时就比较复杂。另一种做法就是secondary index使用primary key作为Row Id。Oracle干脆允许tuple span pages，以避免移动tuples。</p></div></div><div class="sect2"><h3 id="_数据仓库data_warehouses">数据仓库（Data Warehouses）</h3><div class="paragraph"><p>数据仓库的场景（也称为OLAP场景）和OLTP的场景比较不一样，上面提到的优化过程和执行引擎的讨论需要一定的扩展和修改才能在OLAP的场景下得到更好的性能。</p></div><div class="olist arabic"><ol class="arabic"><li><p><strong>Bitmap Indexes</strong>。有些列，例如性别，只有固定的取值可能，使用Bitmap索引可以得到更好的性能。</p></li><li><p><strong>Fast Load</strong>。尽管以前OLAP可以一天导入一次，但是现在一般都希望能够更快。Bulk load可以跳过SQL解析等步骤，直接操作底层存储引擎，获得更好的性能。</p></li><li><p><strong>Materialized Views</strong>。可以创建物理视图，更新数据时同时更新基表和物理视图，用空间换取查询时间。</p></li><li><p><strong>OLAP and Ad-hoc Query Support</strong>。有些数据仓库具有固定的查询场景，因此可以预测到需要执行的语句，例如周期性执行的查询。这些场景某些程度上可以通过data cubes进行支持，类似于预计算。但是对于ad-hoc查询的支持一直是一个难题。</p></li><li><p><strong>Optimization of Snowflake Schema Queries</strong>。OLAP数据库的表结构一般设计成雪花形状，针对这种schema可以进行一些优化。</p></li></ol></div><div class="paragraph"><p>特别的Column Storage可以在OLAP的场景下发挥巨大的作用。</p></div></div><div class="sect2"><h3 id="_数据库可扩展性database_extensibility">数据库可扩展性（Database Extensibility）</h3><div class="olist arabic"><ol class="arabic"><li><p>UDT/UDF</p></li><li><p>JSON/XML</p></li><li><p>Full-Text Search</p></li></ol></div></div></div></div><div class="sect1"><h2 id="_存储管理">存储管理</h2><div class="sectionbody"><div class="sect2"><h3 id="_空间控制spatial_control">空间控制（Spatial Control）</h3><div class="paragraph"><p>众所周知，顺序存取远快于随机存取。数据库系统应当对于如何排布数据具有控制权，而且数据库系统比底层的操作系统知道更多信息，因此会比操作系统做的更好。早期的数据库系统通过直接操作裸磁盘的方式达成这一目的。但是这种方式会独占磁盘，管理和恢复数据困难，不能无痛享受其他技术（例如SAN，RAID等等），因此渐渐被其他方式所取代。目前主流的方法是分配一个大文件，然后使用 <code>mmap</code> API或者Direct I/O，Concurrent I/O之类的技术对其进行操作，模拟一块裸磁盘。</p></div></div><div class="sect2"><h3 id="_缓存控制temporal_controlbuffering">缓存控制（Temporal Control：Buffering）</h3><div class="paragraph"><p>除了需要控制数据的位置，数据库系统还需要控制数据合适被写入持久化存储设备，这出于以下两方面考虑：</p></div><div class="olist arabic"><ol class="arabic"><li><p>一些数据必须立即写入持久化设备以保证正确性，例如事务的write ahead logging</p></li><li><p>数据库根据业务数据做了大量的缓存管理方面的工作，不需要底层操作系统也做类似的事情带来额外的开销</p></li></ol></div></div><div class="sect2"><h3 id="_缓存管理buffer_management">缓存管理（Buffer Management）</h3><div class="paragraph"><p>数据库一般使用一块内存空间（frame）和硬盘上的内容进行一一映射，这个映射不涉及到数据内容的转换以避免额外的CPU开销。这一映射关系和元数据等信息会被管理起来，其中一个重要的信息是dirty flag。如果这个frame被决定换出内存，此时根据dirty flag决定是否需要将frame写回磁盘。上面提到过的pin/unpin也会决定这个frame是否能够被换出到磁盘中。</p></div><div class="paragraph"><p>frame根据一定的替换策略进行加载和换出，这方面的算法是过去研究的重点，例如LRU，CLOCK，LRU-2等算法。</p></div></div></div></div><div class="sect1"><h2 id="_事务并发控制和恢复">事务：并发控制和恢复</h2><div class="sectionbody"><div class="paragraph"><p>数据库系统中真正比较大块，拆分的不怎么清晰的地方就是事务存储管理，通常由相互纠缠的以下4个模块构成：</p></div><div class="olist arabic"><ol class="arabic"><li><p>并发控制中的Lock Manager</p></li><li><p>错误恢复中的Log Manager</p></li><li><p>用于分离I/O的Buffer Pool</p></li><li><p>在底层磁盘上管理数据的Access Methods</p></li></ol></div><div class="sect2"><h3 id="_a_note_on_acid">A Note on ACID</h3><div class="paragraph"><p>ACID指的是数据库系统中的事务：</p></div><div class="hdlist"><table><tr><td class="hdlist1">Atomicity</td><td class="hdlist2"><p>一个事务造成的改动，要么全部生效，要么全部不生效</p></td></tr><tr><td class="hdlist1">Consistency</td><td class="hdlist2"><p>不能违反SQL定义的约束</p></td></tr><tr><td class="hdlist1">Isolation</td><td class="hdlist2"><p>两个并发运行的事务之间不能相互影响</p></td></tr><tr><td class="hdlist1">Durability</td><td class="hdlist2"><p>一个事务一旦成功，其造成的改动——除非被另外的过程所改写——不能丢失</p></td></tr></table></div></div><div class="sect2"><h3 id="_a_brief_review_of_serializability">A Brief Review of Serializability</h3><div class="paragraph"><p>主要有三大类实现并发控制的方法：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Strict two-phase locking（2PL）</p></li><li><p>Multi-Version Concurrency Control（MVCC）</p></li><li><p>Optimistic Concurrency Control（OCC）</p></li></ol></div></div><div class="sect2"><h3 id="_locking_and_latching">Locking and Latching</h3><div class="paragraph"><p>数据库会自己实现一个锁控制系统，称为Locking。数据库系统会自己维护一个Lock Table记录Transaction/Lock/Object之间的关系，这样当Abort一个Transaction的时候，就能将与其关联的所有Lock都释放掉。此外，由于加锁的顺序是由用户存取数据的顺序驱动的，因此死锁检测也是一个必不可少的工作。这种锁系统主要是针对Transaction的。</p></div><div class="paragraph"><p>数据库系统也会在访问数据结构时使用更细粒度的锁对数据及数据结构进行保护，这种锁称为Latching。一般来说Latching都是由操作系统或者硬件指令提供的基础设施，因此对于Latching的使用要避免出现死锁的情况。</p></div><div class="paragraph"><p>ANSI SQL规定了几种隔离性级别：</p></div><div class="olist arabic"><ol class="arabic"><li><p>READ UNCOMMITTED</p></li><li><p>READ COMMITTED</p></li><li><p>REPEATABLE READ</p></li><li><p>SERIALIZABLE</p></li></ol></div><div class="paragraph"><p>这几种隔离性级别都是在早期针对于使用锁进行隔离性控制提出的规范。现在由于MVCC和OCC的使用，一些数据库系统也提供了其他的隔离性级别：</p></div><div class="olist arabic"><ol class="arabic" start="5"><li><p>CURSOR STABILITY</p></li><li><p>SNAPSHOT ISOLATION</p></li><li><p>READ CONSISTENCY</p></li></ol></div></div><div class="sect2"><h3 id="_log_manager">Log Manager</h3><div class="paragraph"><p>建议阅读ARIES的论文<a href="#aries">[8]</a>，其中不仅叙述了使用Logging的方法，也讨论了其他实现方法。</p></div><div class="paragraph"><p>一般数据库系统使用Write-Ahead Logging（WAL）实现事务持久化，其要点在于以下3点规则：</p></div><div class="olist arabic"><ol class="arabic"><li><p>每个对数据页的修改都应该产生一条日志，这个日志必须在内存页落盘之前落盘</p></li><li><p>日志必须有序落盘</p></li><li><p>日志落盘后才能响应事务成功</p></li></ol></div><div class="paragraph"><p>尽管基本规则非常简单，但是实际实现为了获得更好的性能通常远比这些规则复杂。关键在于保持事务提交的 <em>fast path</em> 上高性能的同时，提供Rollback/Abort的一定性能。在考虑到特定场景优化后，日志系统将变得更为复杂。</p></div><div class="paragraph"><p>一般数据库采用 <em>DIRECT, STEAL/NOT-FORCE</em> 这样的原则<a href="#log-opt">[9]</a>：</p></div><div class="olist arabic"><ol class="arabic"><li><p>数据对象原地更新</p></li><li><p>即便数据页上含有未提交的事务写入的数据，unpinned frame也可以被替换掉（此时如果含有脏数据，则将改动写回磁盘。可以这么做是因为可以用undo日志撤销aborted事务的改动）</p></li><li><p>事务commit时，无需将数据页落盘（因为写了redo日志了）</p></li></ol></div><div class="paragraph"><p>另一方面，减少日志的大小也可以有效的增加日志系统的性能。物理操作通常含有更多和当前结构相关的数据，这些数据可以提高执行这一操作时的性能，但是写日志时可以只记录逻辑操作，抛弃这些结构相关的数据，以进一步减少日志大小，提升写入日志时的性能。例如在ARIES系统中，将物理操作记入UNDO日志中，将逻辑操作记入REDO日志中。</p></div><div class="paragraph"><p>系统非正常停机后，再次启动时需要从日志中恢复系统的状态。使用 <em>recovery log sequence number</em> （recovery LSN），记录日志的顺序；使用 <em>checkpoint</em> 周期性的记录 recover LSN 以避免从太早的时间点开始恢复过程。最简单的办法就是把所有的数据页全都落盘，然后记录一个检查点，但是这样做性能太低了。ARIES使用了一种比较聪明的办法，以避免等待所有的数据页落盘。（没写细节）</p></div><div class="paragraph"><p>特别需要注意的是事务Rollback也需要写WAL，如果此时磁盘空间不足的话就会导致Rollback卡住的情况。一般采用预留一部分空间的方法来避免这一情况。</p></div></div><div class="sect2"><h3 id="_locking_and_logging_in_indexes">Locking and Logging in Indexes</h3><div class="paragraph"><p>在Index结构上的Locking和Logging可能有不同于Transaction的策略以优化性能。</p></div><div class="sect3"><h4 id="_latching_in_b_trees">Latching in B+-Trees</h4><div class="paragraph"><p>如果使用严格的两阶段锁来保证SERIALIZABLE一致性的话，可以选择将整个B+树都锁住（锁住根节点）。但是这样一来，两个完全没有交集的事务也不能够并行运行了。常见的有以下3种策略解决这一问题：</p></div><div class="olist arabic"><ol class="arabic"><li><p>保守策略（Conservative schemes）。只有确保对数据页的访问没有任何相互影响的时候，才允许并发访问同一个数据页。例如一个操作正在遍历这个数据页，而另一个操作想要在这个数据页中进行插入操作，这样两个操作是不允许并发执行的，因为可能插入操作会导致数据页分裂。这种策略对比其他2个比较新的策略有点过于保守了。</p></li><li><p>Latch-coupling schemes。在遍历数据时，访问数据节点前对其加锁（Latch），只有在获取到下一个要访问的节点的锁后，才释放当前节点的锁。</p></li><li><p>Right-link schemes。B+树中的节点存有一个右向指针。遍历时不使用上面提到的Latch-coupling的策略，访问完一个节点之后就释放锁。由于存在这样一个右向指针，在遍历的时候就可以察觉到是否在此期间发生了树的分裂，并且可以正确的找到所需的下一个节点。</p></li></ol></div><div class="paragraph"><p>特别的，Latch-coupling只适用于B+树，而Right-link策略比较通用<a href="#gist">[10]</a>。</p></div></div><div class="sect3"><h4 id="_logging_for_physical_structures">Logging for Physical Structures</h4><div class="paragraph"><p>B+树的分裂可以不用UNDO，所以在记日志的时候可以标记REDO only。这种思想也可以用于其他结构的变换上，例如文件的增长等等。</p></div></div></div><div class="sect2"><h3 id="_next_key_locking_physical_surrogates_for_logical_properties">Next-Key Locking: Physical Surrogates for Logical Properties</h3><div class="paragraph"><p>B+树在实现Serializability事务隔离性级别时，有特殊的优化方法，这种优化方法时针对于解决“Phantom”不一致现象的。Phantom现象是这样一种现象，假设有一个查询带有一个范围谓词（predicate），例如 <code>Name BETWEEN 'Bob' AND 'Bobby'</code>，同时另一个查询向这个范围内插入了一条新的记录，例如 <code>Name = 'Bobbie'</code>，那么第一个查询就有可能在执行的过程中看到不一致的结果。这是因为在锁定记录时，没有对查询的这个范围本身加锁，导致了两个实际上有重叠的查询请求并行执行出现的异常结果（违背Serializability隔离级别）。</p></div><div class="paragraph"><p>解决这一问题的一个方法是使用谓词锁，但是这么做代价比较高，一方面是因为判断任意两个谓词是否有交集是比较困难的，另一方面是因为基于哈希的Lock Table也很难支持这样的操作。</p></div><div class="paragraph"><p>在B+树中可以使用这样一种方法进行优化。每次进行查询时，除了锁住自己需要的范围以外，还需要额外的多锁住一个恰好超出范围上界的元素。显然这样的方法是奏效的，并且因为B+树的结构，找到这样的下一个元素是比较容易的。</p></div><div class="paragraph"><p>这种方法的思想是，使用一个实际存在的物理对象来代替一个不容易实现的逻辑性质。在这个例子中，下一个元素代替了扩大谓词范围来判断谓词交集问题这一抽象概念。这种技巧应当为人所知，以便在恰当的时候使用。</p></div></div><div class="sect2"><h3 id="_interdependencies_of_transactional_storage">Interdependencies of Transactional Storage</h3><div class="paragraph"><p>本章的开头提到过Transactional Storage是数据库系统中，子模块之间深度交缠的一个巨大的子系统，在这一节中将讨论各个子模块之间的相互依赖。</p></div><div class="paragraph"><p>只考虑并发控制和错误恢复机制的话，就会发现常见的错误恢复机制WAL依赖于并发控制的实现方法是使用strict two-phase locking。如果使用non-strict two-phase locking的话，如果已经drop了lock，那么在rollback时候进行undo的时候，可能没办法再拿到锁。</p></div><div class="paragraph"><p>如果再把Access Methods考虑进来的话，事情就更复杂了。Access Methods的高性能实现本身就比较复杂，考虑到并发控制和错误恢复机制时，必须和其特有的数据结构紧密结合。这就是为什么主流的数据库系统一般都只实现了B+树和堆文件，只有PostgreSQL实现了GiST。而且每种数据结构都有其特有的并发控制或者是错误恢复机制的优化技巧，即便是最简单的堆文件也有这样的特殊技巧，而这些特殊技巧是无法应用到其他数据结构上的。</p></div><div class="paragraph"><p>在Access Methods上实现的并发控制一般只是在基于锁的实现上做的比较好。其他的并发控制方法，例如MMVC和OCC，其实并没有考虑Access Methods的特性。因此在同一个Access Methods混合使用多种不同的并发控制方法是困难的。</p></div><div class="paragraph"><p>在Access Methods上实现错误恢复的逻辑是一个和整个子系统高度相关的事情。数据结构的变更，使用物理变更日志还是使用逻辑变更日志，这些决策都离不开整个子系统的各个细节。例如在B+树中，恢复和并发逻辑就是交织的。一方面，如果需要进行错误恢复，则需要知道B+树可能进入什么样的不一致状态，然后才能通过日志来保证Atomicity。另一方面，例如B+树节点的分裂，其实就不需要记录UNDO日志，并不需要在Rollback的时候把分裂的节点再合并回去，这就需要日志系统支持REDO-only的能力。</p></div><div class="paragraph"><p>尽管Buffer Manager相对而言比较独立，看似和其他几个模块关联比较松散，但是这是因为我们实现了 DIRECT, STEAL/NOT-FORCE 这样的性质。而支持这些性质实际上是依赖于其他几个模块的支持的，所以Buffer Manager也跟另外几个子模块耦合在了一起。</p></div></div></div></div><div class="sect1"><h2 id="_公共组件">公共组件</h2><div class="sectionbody"><div class="sect2"><h3 id="_catalog_manager">Catalog Manager</h3><div class="paragraph"><p>Catalog Manager中存放了整个数据库系统中的元数据，例如用户，Schemas，表，列，索引，等等。过去实践中的一个重要的经验是，应当使用和访问一般数据相同的方法（即SQL）来访问和修改这些元数据。这些基础的数据需要进行特殊的对待，这通常是为了性能而进行的考虑。通常使用denormalized形式直接将这些数据存放在内存中提供服务，相关的SQL语句也直接进行了预编译和缓存，甚至一些事务相关的操作也进行了特殊优化。</p></div></div><div class="sect2"><h3 id="_memory_allocator">Memory Allocator</h3><div class="paragraph"><p>传统的教科书对于Memory Allocator的讲解都集中在内存池的管理上。但是实际上，数据库系统也将Memory Allocator应用于很多其他方面，例如Selinger的查询优化<a href="#system-r-optimizer">[4]</a>中进行动态规划时就会使用大量的内存，更别提hashjoin和sort这种吃内存的operator了。</p></div><div class="paragraph"><p>另一方面，数据库系统中的Memory Allocator还会使用一种 <em>context-based</em> 技术来同时增加性能和 debug 能力，其提供的基本 API 如下：</p></div><div class="ulist"><ul><li><p><strong>使用给定的名字或者类型创建一个 Context</strong>。这个 Context 可以给 Allocator 关于被分配的内存将要用于何种用途的额外附加信息，这样 Allocator 就可以选择更合适的策略进行内存分配。例如用于 Query Optimizer 的内存每次只需要增长一点点，用于 HashJoin 的内存就是一大片一大片分配的。</p></li><li><p><strong>给指定的 Context 分配一块内存</strong>。类似于 <code>malloc()</code> 函数，但是是从内部的内存池中分配的。</p></li><li><p><strong>回收指定的 Context 已经分配的一块内存</strong>。类似于 <code>free()</code> 函数。这种用法其实比较少见，一般都是一下就将整个 Context 给回收了。</p></li><li><p><strong>回收指定的 Context 的所有内存</strong>。</p></li><li><p><strong>重置一个 Context</strong>。这种情况也会回收这个 Context 已经分配出去的所有内存，但是会保留这个 Context 的元信息，所以接下来还可以继续使用这个 Context 进行内存分配。</p></li></ul></div><div class="paragraph"><p>这和传统的 jemalloc 之类的，目标是无缝替换 <code>malloc</code> 调用的内存分配器略有不同。一些场景下，例如 optimizer 可能需要构建出 plan tree，因此会多次分配小内存对象，但是在这个 phase 结束后，将整个 context 一起回收掉，而不是再去遍历数据结构去进行小心翼翼的 <code>free</code> 操作。</p></div><div class="paragraph"><p>这种使用方式和 Garbage Collector（GC）有些相似，但是比 GC 能够提供更多的可控性。例如其还保留了 <code>free</code> 操作，而且通过 Context 在内存分配和回收上进行了很好的隔离，也能获得更好的本地性。</p></div><div class="paragraph"><p>由于数据库系统的数据流天然就是分成多个阶段进行的，这种 Memory Allocator 的设计方式特别适合数据库系统使用。特别是有些场景下如果事先知道无需进行 <code>free</code> 操作，而是在最后将整个 Context 回收的话，就无需追踪每一块分配出去的内存的使用情况，（对于经常分配小对象的场景）可以节约很多开销。</p></div></div><div class="sect2"><h3 id="_disk_management_subsystems">Disk Management Subsystems</h3><div class="paragraph"><p>主要解决两类问题。一个问题是如何将数据库系统的数据和分布在不同磁盘的多个文件建立对应关系，其中每个文件可能还有大小限制。另一个问题是如何处理不同磁盘设备的特性带来的优化问题。</p></div><div class="paragraph"><p>文件的大小和存取性能可能受操作系统，文件系统，物理设备的限制。数据库系统的数据和文件的大小也不能完全匹配，有些大的表可能一个设备上的单一文件装不下（例如早期文件系统的2GiB限制），有些小的表可能需要合并放在一个文件内。</p></div><div class="paragraph"><p>SCSI磁盘的性能和其他特性，和其他看起来是个磁盘但是实际上不是磁盘的设备可能相差很多，例如RAID，SAN等等。即便是RAID，RAID-0和RAID-5的特性又会相差很多。</p></div></div><div class="sect2"><h3 id="_replication_services">Replication Services</h3><div class="paragraph"><p>做Replication的方法主要有三种，但是只有最后一种性能上比较令人满意：</p></div><div class="olist arabic"><ol class="arabic"><li><p><strong>Physical Replication</strong>，即定期全盘复制</p></li><li><p><strong>Trigger-Based Replication</strong>，使用数据库的Trigger功能</p></li><li><p><strong>Log-Based Replication</strong>，将数据库日志（一般指Bin-Log）近实时的写入另一个位置，然后再进行恢复。这里又有2种做法，一种是从日志中重建SQL进行回放，另一种就是直接回放数据变更。前者通用性好，可以跨不同数据库vendor进行数据复制；后者性能更高。</p></li></ol></div></div><div class="sect2"><h3 id="_administration_monitoring_and_utilities">Administration, Monitoring, and Utilities</h3><div class="ulist"><ul><li><p>Optimizer Statistics Gathering</p></li><li><p>Physical Reorganization and Index Construction</p></li><li><p>Backup/Export（Fuzzy dump + logging）</p></li><li><p>Bulk Load（Manipulate underlying access methods）</p></li><li><p>Monitoring, Tuning, and Resource Governers</p></li></ul></div></div></div></div><div class="sect1"><h2 id="_标准实践">标准实践</h2><div class="sectionbody"><div class="paragraph"><p>这里汇总一下论文中所有提到的，流行的数据库系统在上面各个章节讨论的话题上，所采用的实现方式。</p></div><div class="sect2"><h3 id="_进程模型的标准实践">进程模型的标准实践</h3><div class="sect3"><h4 id="_process_per_dbms_worker">Process per DBMS worker</h4><div class="paragraph"><p>IBM DB2 在不支持高质量的 OS Thread 的系统上默认使用 Process per DBMS worker 模式，在支持高质量 OS Thread 的系统上默认使用 Thread per DBMS worker。</p></div><div class="paragraph"><p>Oracle 也是和 DB2 的选择一样，但是还额外支持 Process Pool。</p></div><div class="paragraph"><p>PostgreSQL 在所有系统上都使用 Process per DBMS worker 模式。</p></div></div><div class="sect3"><h4 id="_thread_per_dbms_worker">Thread per DBMS worker</h4><div class="paragraph"><p>这里还有两种变体：使用 OS thread 或者使用 DBMS thread。</p></div><div class="paragraph"><p>IBM DB2 在操作系统支持高性能 Thread 时默认使用 OS thread。MySQL 也使用 OS thread。</p></div><div class="paragraph"><p>DBMS thread 是数据库系统在用户态自己实现的任务调度抽象，有时也叫“纤程”（Fiber）。这里又有两种情况，一种是基于 OS Process 实现，另一种是基于 OS Thread 实现。Sybase 和 Informix 支持了基于 OS Process 的 DBMS thread。大部分数据库系统都是用 OS Process 来实现 DBMS thread，但是不是所有的系统都支持在 OS Process 之间迁移 DBMS thread。MS SQL Server 支持了 OS Thread 实现的 DBMS Thread，但是应用场景比较少。</p></div></div><div class="sect3"><h4 id="_processthread_pool">Process/thread pool</h4><div class="paragraph"><p>使用 Process pool 要比 Process per DBMS worker 模式更节省内存，而且也容易 Port 到对 Thread 支持不好的 OS 上。Oracle 也将这种模式作为一种支持的选项，并且推荐在用户并发连接多时使用这种模式。Oracle 的默认模式是 Process per DBMS worker，这两种模式都能很容易的扩展到很多种类的操作系统上。</p></div><div class="paragraph"><p>MS SQL Server 默认使用 Thread pool。</p></div></div></div><div class="sect2"><h3 id="_并行处理架构的标准实践">并行处理架构的标准实践</h3><div class="ulist"><ul><li><p><strong>Shared-Memory</strong>: 所有主流的商业数据库系统都支持这种模式，包括：IBM DB2，Oracle，MS SQL Server。</p></li><li><p><strong>Shared-Nothing</strong>: IBM DB2，Informix，Tandem，NCR Teradata 都支持这种模式；Greenplum 提供一个 PostgreSQL 支持 Shared-Nothing 模式的定制版本。</p></li><li><p><strong>Shared-Disk</strong>: 支持这种模式的有Oracle RAC，Oracle RDB，IBM DB2 for zSeries</p></li></ul></div></div><div class="sect2"><h3 id="_关系查询处理的标准实践">关系查询处理的标准实践</h3><div class="paragraph"><p>从粗粒度的架构来看，几乎所有的关系型数据库的查询引擎都和 System R 的原型<a href="#system-r">[11]</a>差不多。这些年相关的进展主要集中在这个框架内怎么加速更多种类的查询和Schema，主要的改进有以下几个方面：</p></div><div class="olist arabic"><ol class="arabic"><li><p>查询优化的搜索策略（top-down vs. bottom-up）</p></li><li><p>查询执行的控制流模型（iterators + exchange operator vs. asynchronous producer/consumer）</p></li></ol></div><div class="paragraph"><p>在细粒度而言，不同的厂商有很多不同的做法，涉及到 optimizer，executor 和 access methods 的综合优化来达到更好的性能，尤其是涉及到不同的 workload 类型时，例如</p></div><div class="olist arabic"><ol class="arabic"><li><p>OLTP</p></li><li><p>decision-support for warehousing</p></li><li><p>OLAP</p></li></ol></div><div class="paragraph"><p>具体的做法都是各个厂商的“秘方”，唯一知道的就是大家做得都挺好的。</p></div><div class="paragraph"><p>开源领域，PostgreSQL 使用了比较成熟的传统的 cost-based 的优化器，拥有一系列 execution 算法和很多商业产品中所没有的扩展功能。MySQL 的查询引擎就简单多了，基本上就是 nested-loop joins over indices。MySQL 的查询优化着力于分析型的查询，确保整个过程的轻量和高效，特别是 key/foreign-key joins，outer-join-to-join rewrite，以及只查询结果的前若干行的场景。</p></div></div><div class="sect2"><h3 id="_存储管理的标准实践">存储管理的标准实践</h3><div class="paragraph"><p>现在数据库系统对于底层存储的主要使用方式是这样的，直接在指定的磁盘上创建一个大文件，通过底层系统调用（例如 mmap）直接对这个文件进行操作。基本上数据库系统将这个文件视为一大块连续的数据库数据页的数组。</p></div></div><div class="sect2"><h3 id="_事务的标准实践">事务的标准实践</h3><div class="paragraph"><p>现如今，所有的产业级数据库系统都支持 ACID 事务，并且基本上都使用 WAL 来实现 Durability，使用 2PL 实现并发控制。PostgreSQL 是一个特例，只使用 MVCC 实现并发控制。Oracle 是一个在提供了 2PL 以外还提供 MVCC 提供其他弱一致性模型的先行者。采用 B+ 树来做索引也基本上时所有数据库系统的标准了。有些数据库系统或者通过直接提供，或者通过插件的形式，还提供了多维索引的能力。但是只有 PostgreSQL 通过其特有的 GiST <a href="#gist">[10]</a>提供了高并发的多维索引和全文索引。</p></div><div class="paragraph"><p>MySQL 的独到之处在于其支持多种实现作为其底层存储，并且允许 DBA 为同一个数据库内的不同表指定使用不同的存储管理实现。MyISAM 只支持表级锁，但是对于读多请求的表现最好。InnoDB 提供了行级锁，适用于读写均衡的场景。但是两种存储引擎都没有实现 System R 著名的多级锁粒度支持<a href="#granularity-locks">[12]</a>，因此在某些场景下两者表现得都不是很好，例如在混合了 scan 和 high-selectivity index access 的场景。</p></div></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="DBS-002"></a>[1] HELLERSTEIN J M, STONEBRAKER M, HAMILTON J. Architecture of a Database System[J]. Foundations and Trends® in Databases, 2007, 1(2): 141–259.</p></li><li><p><a id="bigtable"></a>[2] CHANG F, DEAN J, GHEMAWAT S, et al. Bigtable: A Distributed Storage System for Structured Data[J]. 7th USENIX Symposium on Operating Systems Design and Implementation (OSDI), 2006: 205–218.</p></li><li><p><a id="optimizer-np-hard"></a>[3] IBARAKI T, KAMEDA T. On the Optimal Nesting Order for Computing N-relational Joins[J]. ACM Trans. Database Syst., New York, NY, USA: ACM, 1984, 9(3): 482–502.</p></li><li><p><a id="system-r-optimizer"></a>[4] SELINGER P G, ASTRAHAN M M, CHAMBERLIN D D, et al. Access Path Selection in a Relational Database Management System[C]//Proceedings of the 1979 ACM SIGMOD International Conference on Management of Data. New York, NY, USA: ACM, 1979: 23–34.</p></li><li><p><a id="cascade-optimizer"></a>[5] GRAEFE G. The Cascades Framework for Query Optimization[J]. IEEE Data Eng. Bull., 1995, 18(3): 19–29.</p></li><li><p><a id="top-down-opt"></a>[6] SHAPIRO L D, MAIER D, BENNINGHOFF P, et al. Exploiting Upper and Lower Bounds In Top-Down Query Optimization[C]//Proceedings of the International Database Engineering &Amp; Applications Symposium. Washington, DC, USA: IEEE Computer Society, 2001: 20–33.</p></li><li><p><a id="exchange-op"></a>[7] GRAEFE G. Encapsulation of Parallelism in the Volcano Query Processing System[C]//Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data. New York, NY, USA: ACM, 1990: 102–111.</p></li><li><p><a id="aries"></a>[8] MOHAN C, HADERLE D, LINDSAY B, et al. ARIES: A Transaction Recovery Method Supporting Fine-granularity Locking and Partial Rollbacks Using Write-ahead Logging[J]. ACM Transactions on Database Systems, New York, NY, USA: ACM, 1992, 17(1): 94–162.</p></li><li><p><a id="log-opt"></a>[9] HAERDER T, REUTER A. Principles of Transaction-oriented Database Recovery[J]. ACM Comput. Surv., New York, NY, USA: ACM, 1983, 15(4): 287–317.</p></li><li><p><a id="gist"></a>[10] KORNACKER M, MOHAN C, HELLERSTEIN J M. Concurrency and Recovery in Generalized Search Trees[C]//Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data. New York, NY, USA: ACM, 1997: 62–72.</p></li><li><p><a id="system-r"></a>[11] ASTRAHAN M M, BLASGEN M W, CHAMBERLIN D D, et al. System R: Relational Approach to Database Management[J]. ACM Trans. Database Syst., New York, NY, USA: ACM, 1976, 1(2): 97–137.</p></li><li><p><a id="granularity-locks"></a>[12] GRAY J, LORIE R A, PUTZOLU G R, et al. Granularity of Locks and Degrees of Consistency in a Shared Data Base[C]//NIJSSEN G M. Proceeding of the &#123;IFIP&#125; Working Conference on Modelling in Data Base Management Systems. North-Holland, 1976: 365–394.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Database/">Database</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/architecture-of-a-database-system/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[OSDI&#39;10] Large-scale Incremental Processing Using Distributed Transactions and Notifications</title>
      <link>http://hcoona.github.io/Paper-Note/percolator/</link>
      <guid>http://hcoona.github.io/Paper-Note/percolator/</guid>
      <pubDate>Sun, 09 Jun 2019 07:46:15 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Percolator&lt;a href=&quot;#percolator&quot;&gt;[1]&lt;/a&gt;在基于Bigtable&lt;a href=&quot;#bigtable&quot;&gt;[2]&lt;/a&gt;系统，在不改变Bigtable自身实现的前提下，通过行级事务和多版本控制，实现了Snapshot Isolation级别的跨行事务。此外，论文还描述了一种基于Bigtable实现的可靠的消息通知机制。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比较有特色的是，Percolator在实现上述2个功能时，并没有侵入去改变Bigtable的实现，而是在Bigtable外围通过包装去实现，这在有些情况下是一种非常方便的做法，但是一般会带来性能损失。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Percolator<a href="#percolator">[1]</a>在基于Bigtable<a href="#bigtable">[2]</a>系统，在不改变Bigtable自身实现的前提下，通过行级事务和多版本控制，实现了Snapshot Isolation级别的跨行事务。此外，论文还描述了一种基于Bigtable实现的可靠的消息通知机制。</p></div><div class="paragraph"><p>比较有特色的是，Percolator在实现上述2个功能时，并没有侵入去改变Bigtable的实现，而是在Bigtable外围通过包装去实现，这在有些情况下是一种非常方便的做法，但是一般会带来性能损失。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>本文只叙述Percolator事务相关的部分。</p></div><div class="sect1"><h2 id="_预备知识">预备知识</h2><div class="sectionbody"><div class="sect2"><h3 id="_bigtable的数据模型和事务支持">Bigtable的数据模型和事务支持</h3><div class="paragraph"><p>我们先回顾一下Bigtable的数据模型：</p></div><div class="imageblock"><div class="content"><img data-src="/images/bigtable-data-model.png" alt="Bigtable data model"></div></div><div class="paragraph"><p>如上图所示，数据可以由以下层级关系确定：</p></div><div class="olist arabic"><ol class="arabic"><li><p>row name，例如 <code>com.cnn.www</code></p></li><li><p>column families，例如 <code>anchor</code></p></li><li><p>column，例如 <code>contents:</code> 和 <code>anchor:cnnsi.com</code></p></li><li><p>timestamp，例如 $t_3$，$t_5$ 和 $t_6$</p></li></ol></div><div class="paragraph"><p>Bigtable支持行级事务，尽管在<a href="#bigtable">[2]</a>中没有明说是什么样的事务隔离性级别，但是从<a href="#percolator">[1]</a>对于Primary加锁的相关叙述中可以推测出应该是Serialisability级别的。</p></div></div><div class="sect2"><h3 id="_snapshot_isolation简介">Snapshot Isolation简介</h3><div class="paragraph"><p>在<a href="#critique-sql-isolation">[3]</a>中非形式化的描述了Snapshot Isolation。简单而言，一次Snapshot Isolation的Transaction具有2个重要的时间结点：Start-Timestamp和Commit-Timestamp。在整个Transaction开始时，也即Start-Timestamp，对整个系统中的数据取快照，在Transaction进行过程中读取的所有数据，以及写入的所有变更都来自于这个快照。如果在提交时，也即Commit-Timestamp，发现有其他Transaction已经提交了，则Abort，否则成功。</p></div><div class="paragraph"><p>在<a href="#weak-consistency">[4]</a><a href="#seeing-is-believing">[5]</a>和<a href="#consistency-models">[6]</a>中有关于Snapshot Isolation的形式化表述。</p></div><div class="paragraph"><p>Snapshot Isolation相关展开的话题比较多，包括以下几个主要方面：</p></div><div class="olist arabic"><ol class="arabic"><li><p>提升隔离性：One-copy Snapshot Isolation，Serializable Snapshot Isolation</p></li><li><p>各种变种和优化</p></li><li><p>和新硬件的结合优化</p></li></ol></div><div class="paragraph"><p>相关话题见：<a href="https://zhuanlan.zhihu.com/p/54979396">Snapshot Isolation综述</a>，<a href="https://zhuanlan.zhihu.com/p/67077901">论文笔记：[CONCUR'15] A Framework for Transactional Consistency Models with Atomic Visibility</a> 和 <a href="https://zhuanlan.zhihu.com/p/37076900">CAP，ACID，我们能做什么</a>。</p></div><div class="paragraph"><p>P.S. Postgres中MVCC的实现见<a href="#mvcc-unmasked">[10]</a>。<a href="#critique-sql-isolation">[3]</a>提到了Snapshot Isolation是对于<a href="#mvcc-bhg">[7]</a>中Multiversion Mixed Method的一种扩展。但是Snapshot Isolation也可以用其他方式实现，例如<a href="#semantics-snapshot-isolation">[11]</a>中提供了使用读写锁实现Snapshot Isolation的方法。</p></div></div></div></div><div class="sect1"><h2 id="_percolator是如何实现跨行事务的">Percolator是如何实现跨行事务的</h2><div class="sectionbody"><div class="paragraph"><p>Percolator依赖于底层BigTable实现Multi-version和行级事务，在此基础上实现了跨行事务。</p></div><div class="sect2"><h3 id="_主要流程">主要流程</h3><div class="paragraph"><p>假设存在一个Timestamp Oracle Service可以提供单调递增的时戳。Bigtable Transaction提供行内强一致性级别事务。Bigtable使用Timestamp Oracle Service提供的时戳作为cell的版本号。我们基于上述设施介绍如何实现Percolator Transaction。</p></div><div class="olist arabic"><ol class="arabic"><li><p>当Percolator Transaction开始时，取得一个时戳Start-Timestamp</p></li><li><p>进入读阶段</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>当发起读请求时，总是取得Start-Timestamp之前最后一次Committed的版本的值</p></li><li><p>当发起写请求时，总是将写请求缓存到本地</p></li></ol></div></li><li><p>当Percolator Transaction提交时</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>进入加锁阶段，对所有被写请求影响的cell加锁（通过写一个特殊的cell）</p></li><li><p>取得一个时戳Commit-Timestamp</p></li><li><p>进入提交阶段，以Commit-Timestamp作为写版本，将缓存在本地的写请求Flush到远程并去除受影响的cell上的锁</p></li></ol></div></li></ol></div><div class="paragraph"><p>以上过程中，无论是读请求还是写请求，都需要Bigtable行级事务的支持。</p></div><div class="paragraph"><p>由于BigTable并不支持真正的行级锁，这里锁的实现方式是使用一个特殊的列：<code>c:lock</code>（这里 <code>:</code> 比较容易引起歧义，在BigTable中使用 <code>:</code> 分割 ColumnFamily 和 ColumnName，可以认为这里使用了另一个特殊符号进行分割，例如： <code>cf:cn+lock</code>）。这样的话，原来的数据也需要相应变化一下，约定使用列 <code>c:data</code> 存储真实数据（的不同版本）。由于我们想要支持跨行事务，最终Percolator事务提交的时候，我们还需要一个特殊的列来标记 Committed：<code>c:write</code>。</p></div><div class="paragraph"><p>Percolator还进行了一些变化，以避免为每一个Percolator事务分配唯一标识。通过（任意）指定一个write请求的cell在加锁时，这个锁是Primary的，事务中的其他Lock都是Secondary Lock，并且指向这个Primary Lock。这个设计相当于用Primary Lock唯一标志这个Percolator事务，使用BigTable可靠的记录（追踪）了整个事务，这个记录可以用于错误恢复时读取整个事务的状态。</p></div><div class="paragraph"><p>Percolator的具体算法参考原论文，下面讲解一下论文中给出的例子。</p></div><table id="table-1" class="tableblock frame-all grid-all stretch"><caption class="title">Table 1. Initial State</caption><colgroup><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">key</th><th class="tableblock halign-left valign-top">bal:data</th><th class="tableblock halign-left valign-top">bal:lock</th><th class="tableblock halign-left valign-top">bal:write</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Bob</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Joe</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr></tbody></table><div class="paragraph"><p>如<a href="#table-1">Table 1</a>所示，初始状态中存有2行数据：Bob和Joe。他们最后一次Committed的Version都是5，他们现在都没有被加锁。观察其数据列，得到他们现在的状态：Bob有\$10，Joe有\$2。假设读取的Cell的版本区间上存在“有效”的锁（“有效”见后面错误恢复），则需要等待锁释放后再读取。</p></div><div class="paragraph"><p>现在Bob想要转账\$7给Joe，所有的读取请求无需加锁，直接按照当前时间的快照进行查询，即读到了<a href="#table-1">Table 1</a>中的状态：Bob有\$10，Joe有\$2。此时判定可以进行转账操作，于是开始进行写入。所有的写请求都会先Buffer到本地，等到提交阶段再进行，这样可以保证在提交阶段时知道所有需要加锁的Cell。转账操作需要分别影响Bob的bal和Joe的bal。</p></div><div class="paragraph"><p>假设我们总是将第一次写操作影响的Cell认为是Primary Lock Object，首先从Bob的账户中减去\$7，则第一次写入可以同时做加Primary Lock和记录写请求的工作，如<a href="#table-2">Table 2</a>所示。</p></div><div class="paragraph"><p>加锁时有2种情况会导致加锁失败：</p></div><div class="olist arabic"><ol class="arabic"><li><p>在Transaction开始后，已经有其他人提交了其他的Transaction，并且也写入了这一Cell（意味着Write-Write冲突）</p></li><li><p>别人已经在这个Cell上加锁了，并且这个锁此时仍然是“有效”（“有效”见后面错误恢复）的（意味着Percolator Transaction是Non-blocking的）</p></li></ol></div><table id="table-2" class="tableblock frame-all grid-all stretch"><caption class="title">Table 2. The transfer transaction begins by locking Bob&#8217;s account</caption><colgroup><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">key</th><th class="tableblock halign-left valign-top">bal:data</th><th class="tableblock halign-left valign-top">bal:lock</th><th class="tableblock halign-left valign-top">bal:write</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Bob</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: $3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: I am primary</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock">Joe</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr></tbody></table><div class="paragraph"><p>Primary lock成功后，接下来的所有写操作都需要加锁，并且将锁指向Primary Lock以供错误检测和恢复使用。</p></div><table id="table-3" class="tableblock frame-all grid-all stretch"><caption class="title">Table 3. The transaction now locks Joe&#8217;s account and writes Joe&#8217;s new balance</caption><colgroup><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">key</th><th class="tableblock halign-left valign-top">bal:data</th><th class="tableblock halign-left valign-top">bal:lock</th><th class="tableblock halign-left valign-top">bal:write</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Bob</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: $3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: I am primary</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Joe</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: $9</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: primary @ Bob.bal</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr></tbody></table><div class="paragraph"><p>如果所有写入请求加锁成功，那么就可以进入提交阶段。提交时首先提交Primary Lock锁住的内容，见<a href="#table-4">The transaction has now reached the commit point</a>。</p></div><table id="table-4" class="tableblock frame-all grid-all stretch"><caption class="title">Table 4. The transaction has now reached the commit point</caption><colgroup><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">key</th><th class="tableblock halign-left valign-top">bal:data</th><th class="tableblock halign-left valign-top">bal:lock</th><th class="tableblock halign-left valign-top">bal:write</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock">Bob</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8: data @ 7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">7: $3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Joe</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: $9</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: primary @ Bob.bal</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr></tbody></table><div class="paragraph"><p>然后再提交其他Lock锁住的内容：</p></div><table id="table-5" class="tableblock frame-all grid-all stretch"><caption class="title">Table 5. The transaction completes by adding write records and deleting locks at the secondary cells</caption><colgroup><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">key</th><th class="tableblock halign-left valign-top">bal:data</th><th class="tableblock halign-left valign-top">bal:lock</th><th class="tableblock halign-left valign-top">bal:write</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock">Bob</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8: data @ 7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">7: $3</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $10</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr><tr><td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock">Joe</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">8: data @ 7</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">7: $9</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7: primary @ Bob.bal</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7:</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">6: data @ 5</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">5: $2</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">5:</p></td></tr></tbody></table></div><div class="sect2"><h3 id="_错误恢复">错误恢复</h3><div class="paragraph"><p>Percolator相当于使用Client进行Coordinate，但是将所有需要的数据都（通过Embed的方式）Persist到Bigtable中了，因此只要能够检测到Failure，就有足够的信息进行恢复。这里的难点在于如何确定另一个Client真的Fail了，并且这个Client还得必须是Fail-Stop模型的（例如一个Client仅仅是慢，但是被别人认定为Fail了，此时这个Client必须得自行Stop）。Percolator Worker（也就是上面提到的Client），基于Chubby服务<a href="#chubby">[12]</a>进行Lease-Reclaim来保证上述提到的Failure detect和Fence机制。</p></div><div class="paragraph"><p>剩下的问题就比较简单了，根据Primary Lock的情况分为2种：</p></div><div class="olist arabic"><ol class="arabic"><li><p>如果Primary Lock已经Committed了，则需要继续Rollout这个Transaction，将所有发现的Cell都提交</p></li><li><p>如果Primary Lock还没有Commit，则需要将这个Transaction Rollback，将所有发现的Cell都Rollback</p></li></ol></div><div class="paragraph"><p>论文中没有提到具体怎么发现这些受影响的Cell，推测可能的方法有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>在Get数据时Lazily的检测是否需要Rollout/Rollback这个Cell（这个是必须处理的情况）</p></li><li><p>将Transaction影响到的Cell记录到某个地方（由于在加Primary Lock的时候已经知道都有哪些Cell需要加锁了，所以这个方法是可行的）</p></li><li><p>定期进行全表扫描回收</p></li></ol></div></div><div class="sect2"><h3 id="_其他优化">其他优化</h3><div class="paragraph"><p>由于需要保证Timestamp是全序递增的，Timestamp oracle一般采用集中式的方案，因此可能会成为性能瓶颈，需要特别的优化。</p></div><div class="paragraph"><p>Percolator中Timestamp oracle采用预分配的方式，直接分配出一批timestamp，并且将其中最大的一个持久化到可靠存储中。这种预分配的方式可以使得接下来一段时间内的分配都只需要进行内存访问；如果发生重启，则直接从可靠存储中读取最大的一个可能已经分配的Timestamp继续分配即可。</p></div><div class="paragraph"><p>为了节约通信开销，Percolator Worker通过Batching聚合的方式从Timestamp oracle分配一批Timestamp。</p></div></div><div class="sect2"><h3 id="_性能比较">性能比较</h3><div class="paragraph"><p>Percolator Transaction在不考虑重试和错误处理的情况下</p></div><div class="olist arabic"><ol class="arabic"><li><p>每次读请求需要读</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>基础的Version Range</p></li><li><p>有可能存在的锁</p></li><li><p>锁指向的Primary Lock</p></li></ol></div></li><li><p>每次写请求需要</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>读write是否有新提交（Write-Write冲突）</p></li><li><p>读lock是否有锁冲突</p></li><li><p>写数据更新和锁</p></li><li><p>提交</p></li></ol></div></li></ol></div><div class="paragraph"><p>可见读写放大还是比较严重的。Percolator和裸Bigtable性能对比如论文中<a href="#figure-8">Figure 8</a>所示：</p></div><table id="figure-8" class="tableblock frame-all grid-all stretch"><caption class="title">Table 6. The overhead of Percolator operations relative to Bigtable</caption><colgroup><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"><col style="width: 25%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top"></th><th class="tableblock halign-left valign-top">Bigtable</th><th class="tableblock halign-left valign-top">Percolator</th><th class="tableblock halign-left valign-top">Relative</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Read/s</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">15513</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">14590</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0.94</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Write/s</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">31003</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">7232</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">0.23</p></td></tr></tbody></table></div><div class="sect2"><h3 id="_优缺点">优缺点</h3><div class="paragraph"><p>个人认为，Percolator的优点在于非侵入式的给一个支持Multi-version和行级事务的存储系统增加了多行（多表）事务的能力；缺点在于</p></div><div class="olist arabic"><ol class="arabic"><li><p>需要业务修改表结构</p></li><li><p>性能比较低</p></li><li><p>不能有非Transaction的写入和Transaction有任何读/写冲突</p></li><li><p>错误恢复比较复杂</p></li><li><p>Timestamp Oracle可能单点失效</p></li></ol></div></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="percolator"></a>[1] PENG D, DABEK F. Large-scale Incremental Processing Using Distributed Transactions and Notifications[J]. OSDI’10, 2010, 2006: 1–15.</p></li><li><p><a id="bigtable"></a>[2] CHANG F, DEAN J, GHEMAWAT S, et al. Bigtable: A distributed storage system for structured data[J]. 7th Symposium on Operating Systems Design and Implementation (OSDI ’06), November 6-8, Seattle, WA, USA, 2006: 205–218.</p></li><li><p><a id="critique-sql-isolation"></a>[3] BERENSON H, BERNSTEIN P, GRAY J, et al. A critique of ANSI SQL isolation levels[J]. ACM SIGMOD Record, 1995, 24(2): 1–10.</p></li><li><p><a id="weak-consistency"></a>[4] ADYA A. Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions[J]. 1999: 198.</p></li><li><p><a id="seeing-is-believing"></a>[5] CROOKS N, PU Y, ALVISI L, et al. Seeing is Believing: A Client-Centric Specification of Database Isolation[J]. Podc, 2017(June): 73–82.</p></li><li><p><a id="consistency-models"></a>[6] CERONE A, BERNARDI G, GOTSMAN A. A Framework for Transactional Consistency Models with Atomic Visibility[J]. 26th International Conference on Concurrency Theory, &#123;CONCUR&#125; 2015, Madrid, Spain, September 1.4, 2015, 2015, 42(Concur): 58–71.</p></li><li><p><a id="mvcc-bhg"></a>[7] BERNSTEIN P A, GOODMAN N. Concurrency Control in Distributed Database Systems[J]. ACM Computing Surveys, 1981, 13(2): 185–221.较早的mvcc总结</p></li><li><p><a id="mvcc-book"></a>[8] BERNSTEIN P A, GOODMAN N, HADZILACOS V. Concurrency Control and Recovery in Database Systems[M]. ACM Transactions on Database Systems, Addison-Wesley Pub. Co, 1987.mvcc的书</p></li><li><p><a id="mvcc-evaluation"></a>[9] WU Y, ARULRAJ J, LIN J, et al. An empirical evaluation of in-memory multi-version concurrency control[J]. Proceedings of the VLDB Endowment, VLDB Endowment, 2017, 10(7): 781–792.</p></li><li><p><a id="mvcc-unmasked"></a>[10] MOMJIAN B. MVCC Unmasked[EB/OL]. (2019). <a href="http://momjian.us/main/writings/pgsql/mvcc.pdf" class="bare">http://momjian.us/main/writings/pgsql/mvcc.pdf</a>.</p></li><li><p><a id="semantics-snapshot-isolation"></a>[11]Raad, A., Lahav, O., &amp; Vafeiadis, V. (2019). On the Semantics of Snapshot Isolation. In Logic Programming (Vol. 1, pp. 1–23). Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-11245-5_1" class="bare">https://doi.org/10.1007/978-3-030-11245-5_1</a></p></li><li><p><a id="chubby"></a>[12] BURROWS M. The Chubby lock service for loosely-coupled distributed systems[J]. OSDI ’06: Proceedings of the 7th symposium on Operating systems design and implementation SE - OSDI ’06, 2006: 335–350.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Google/">Google</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/percolator/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[CONCUR&#39;15] A Framework for Transactional Consistency Models with Atomic Visibility</title>
      <link>http://hcoona.github.io/Paper-Note/transactional-consistency-models/</link>
      <guid>http://hcoona.github.io/Paper-Note/transactional-consistency-models/</guid>
      <pubDate>Sun, 26 May 2019 15:38:22 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在数据库领域，Transaction是一个非常重要的抽象，其关键在于保证并发请求的正确性。由于Serialisability级别的一致性所需要付出的代价较高，所以通常会使用弱一些的一致性级别来换取性能提升。特别的，在一些特殊场景下，使用弱一致性并不会带来错误。遗憾的是，ANSI SQL对于一致性级别的分类还不够细致，特别的，对于一些常见的弱一致性实现没有形式化规范。这导致人们很难确认特定供应商提供的弱一致性实现在某个特定场景下是否真的不会引入错误。&lt;a href=&quot;#critique-sql-isolation&quot;&gt;[2]&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;近年来，不断有一些使用形式化方法分析Transaction一致性的论文，如&lt;a href=&quot;#weak-consistency&quot;&gt;[3]&lt;/a&gt;&lt;a href=&quot;#hat&quot;&gt;[4]&lt;/a&gt;，以及本文希望介绍的&lt;a href=&quot;#transactional-consistency-models&quot;&gt;[1]&lt;/a&gt;。形式化的表述有助于推理和验证，但是仍需要非形式化的解释以进行直观解释，本文将介绍&lt;a href=&quot;#transactional-consistency-models&quot;&gt;[1]&lt;/a&gt;所做的形式化工作，并解释其直觉含义。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>在数据库领域，Transaction是一个非常重要的抽象，其关键在于保证并发请求的正确性。由于Serialisability级别的一致性所需要付出的代价较高，所以通常会使用弱一些的一致性级别来换取性能提升。特别的，在一些特殊场景下，使用弱一致性并不会带来错误。遗憾的是，ANSI SQL对于一致性级别的分类还不够细致，特别的，对于一些常见的弱一致性实现没有形式化规范。这导致人们很难确认特定供应商提供的弱一致性实现在某个特定场景下是否真的不会引入错误。<a href="#critique-sql-isolation">[2]</a></p></div><div class="paragraph"><p>近年来，不断有一些使用形式化方法分析Transaction一致性的论文，如<a href="#weak-consistency">[3]</a><a href="#hat">[4]</a>，以及本文希望介绍的<a href="#transactional-consistency-models">[1]</a>。形式化的表述有助于推理和验证，但是仍需要非形式化的解释以进行直观解释，本文将介绍<a href="#transactional-consistency-models">[1]</a>所做的形式化工作，并解释其直觉含义。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect1"><h2 id="_基本模型">基本模型</h2><div class="sectionbody"><div class="paragraph"><p><a href="#transactional-consistency-models">[1]</a>使用Abstract Executions模型分析Transactional一致性。</p></div><div class="paragraph"><p>假设数据库就是一堆slots，每个slot能存放一个整数，对于数据库的操作有读和写2种操作：</p></div><div class="stemblock"><div class="content">\[\mathrm&#123;Op&#125; = \&#123; \mathrm&#123;read&#125;(x,n), \mathrm&#123;write&#125;(x,n) \mid x \in \mathrm&#123;Obj&#125;, n \in \mathbb&#123;Z&#125; \&#125;\]</div></div><div class="paragraph"><p>如果给每个操作编上唯一标识，则我们可以得到一些 <em>history event</em></p></div><div class="stemblock"><div class="content">\[\begin&#123;align&#125;\mathrm&#123;WEvent&#125;_x &amp;= \&#123; (\tau, \mathrm&#123;write&#125;(x,n)) \mid \tau \in \mathrm&#123;EventId&#125;, n \in \mathbb&#123;Z&#125; \&#125; \\\mathrm&#123;REvent&#125;_x &amp;= \&#123; (\tau, \mathrm&#123;read&#125;(x,n)) \mid \tau \in \mathrm&#123;EventId&#125;, n \in \mathbb&#123;Z&#125; \&#125; \\\mathrm&#123;HEvent&#125;_x &amp;= \mathrm&#123;WEvent&#125;_x \cup \mathrm&#123;REvent&#125;_x\end&#123;align&#125;\]</div></div><div class="paragraph"><p>进一步的，我们可以定义Transaction：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>A <em>transaction</em> $T, S, \ldots$ is a pair $(E, \mathrm&#123;po&#125;)$, where $E \subseteq \mathrm&#123;HEvent&#125;$ is a finite, non-empty set of events with distinct identifiers, and the <em>program order</em> $\mathrm&#123;po&#125;$ is a total order over $E$. A <em>history</em> $\mathcal&#123;H&#125;$ is a (finite or infinite) set of transactions with disjoint sets of event identifiers.</p></div><div class="paragraph"><p>All transactions in a history are assumed to be committed: to simplify presentation, our specifications do not constrain values read inside aborted or ongoing transactions.</p></div></blockquote></div><div class="paragraph"><p>简单的来说，Transaction就是一组具有全序关系的history events（还有一些为了严谨性的额外条件，但是对于直觉理解没什么意义）。history由已提交的一些Transactions组成。</p></div><div class="paragraph"><p>更进一步的，我们可以定义abstract execution：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>We call a relation <em>prefix-finite</em>, if every element has finitely many predecessors in the transitive closure of the relation.</p></div><div class="paragraph"><p>An <em>abstract execution</em> is a triple $\mathcal&#123;A&#125; = (\mathcal&#123;H&#125;, \mathrm&#123;VIS&#125;, \mathrm&#123;AR&#125;)$ where:</p></div><div class="olist arabic"><ol class="arabic"><li><p><em>visibility</em>: $\mathrm&#123;VIS&#125; \subseteq \mathcal&#123;H&#125; \times \mathcal&#123;H&#125;$ is a prefix-finite, acyclic relation; and</p></li><li><p><em>arbitration</em>: $\mathrm&#123;AR&#125; \subseteq \mathcal&#123;H&#125; \times \mathcal&#123;H&#125;$ is a prefix-finite, total order such that $\mathrm&#123;AR&#125; \supseteq \mathrm&#123;VIS&#125;$.</p></li></ol></div></blockquote></div><div class="paragraph"><p>abstract execution的直观含义就不太明显了，只能认为是带有两种序关系的history。然而这里并没有定义$\mathrm&#123;VIS&#125;$和$\mathrm&#123;AR&#125;$的具体含义，只是大概解释了一下它们的直观含义：</p></div><div class="olist arabic"><ol class="arabic"><li><p>$T \stackrel&#123;\mathrm&#123;VIS&#125;&#125;&#123;\longrightarrow&#125; S$大体上可以认为$S$发现了$T$，一般来说是$S$读到了$T$产生的内容。</p></li><li><p>$T \stackrel&#123;\mathrm&#123;AR&#125;&#125;&#123;\longrightarrow&#125; S$大体上可以认为是$S$写入的内容（部分或全部）覆盖了$T$写入的内容。尽管论文中是这么解释的，但是我认为理解成这样更通顺一些，即$S$“实际上”在$T$之后发生。我认为这么理解更合适的原因是因为在论文<a href="#figure-3">Figure 3(a)</a>中有$T_1 \stackrel&#123;\mathrm&#123;AR&#125;&#125;&#123;\longrightarrow&#125; T_3$（这个关系源自于$\mathrm&#123;AR&#125;$是传递自反的），但是$T_3$根本没有进行写操作，这个用原论文中的说法根本没法理解。</p></li><li><p>$\mathrm&#123;AR&#125; \supseteq \mathrm&#123;VIS&#125;$意味着$( (T \stackrel&#123;\mathrm&#123;VIS&#125;&#125;&#123;\longrightarrow&#125; S) \Rightarrow (T \stackrel&#123;\mathrm&#123;AR&#125;&#125;&#123;\longrightarrow&#125; S)) \land ( (T \stackrel&#123;\mathrm&#123;AR&#125;&#125;&#123;\longrightarrow&#125; S) \nRightarrow (T \stackrel&#123;\mathrm&#123;VIS&#125;&#125;&#123;\longrightarrow&#125; S))$，也就是说我可以在不知道你的情况下就把你写入的东西给覆盖了，或者理解成尽管我“实际上”在你之前发生，但是你不知道我在你之前发生。或者可以认为$\mathrm&#123;VIS&#125;$相当于是在$\mathrm&#123;AR&#125;$中去掉了一些元素。</p></li></ol></div><div class="paragraph"><p>实际上$\mathrm&#123;VIS&#125;$和$\mathrm&#123;AR&#125;$是由consistency model的约束决定的，因此在这里才没有一个精确的定义。本文所使用的方法就是从通过对$\mathrm&#123;VIS&#125;$和$\mathrm&#123;AR&#125;$增加约束，将某些违反直觉的情况从abstract executions中排除。所增加的约束被定义为某种（好的）性质，通过组合这些性质进一步定义出一致性模型。</p></div><div class="paragraph"><p>总之abstract execution $\mathcal&#123;A&#125;$就是带有$\mathrm&#123;VIS&#125;$和$\mathrm&#123;AR&#125;$两种序关系的event history $\mathcal&#123;H&#125;$。其中$\mathrm&#123;AR&#125;$就是comitted transaction“实际上”串行化后“生效”的顺序，$\mathrm&#123;VIS&#125;$是从用户（客户端）的视角能够发现transaction之间的逻辑因果关系。</p></div><div class="paragraph"><p>关于abstract execution模型的概念在论文中写的不是很详细，如果对这部分内容感兴趣，建议阅读<a href="#abstract-execution">[5]</a>。但是需要注意的是<a href="#abstract-execution">[5]</a>中具体描述的abstract execution模型和这里的场景不一样，是建立在operation上的，而<a href="#transactional-consistency-models">[1]</a>的abstract execution是建立在transaction上的。</p></div></div></div><div class="sect1"><h2 id="_一致性模型和性质总结">一致性模型和性质总结</h2><div class="sectionbody"><div class="paragraph"><p>论文中提到的一致性模型见<a href="#figure-1">figure 1</a>。</p></div><div id="figure-1" class="imageblock"><div class="content"><img data-src="/images/transactional-consistency-models-figure-1.png" alt="Figure 1 in origin paper"></div></div><div class="paragraph"><p>其中并没有提到ANSI SQL中常见的几个一致性级别：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Read Uncommitted</p></li><li><p>Read Committed</p></li><li><p>Repeatable Read（这里取<a href="#generalized-isolation-level">[7]</a>中的定义，和ANSI SQL中的定义有微妙的区别，详见P9 Remark 8上面一点。这么取是因为<a href="#ramp-tods">[6]</a>的P15:11最上面特别提了一下。）</p></li></ol></div><div class="paragraph"><p>特别的，其中Repeatable Read和Read Atomic比较类似，容易引起一些混淆，但是两者并不是相同的一致性级别，见<a href="#ramp-tods">[6]</a>的<a href="#ramp-figure-1">RAMP figure 1</a>（注意是TODS 2016，不是SIGMOD 2014的同名文献）。</p></div><div id="ramp-figure-1" class="imageblock"><div class="content"><img data-src="/images/ramp-figure-1.png" alt="Figure 1 in RAMP TODS 2016 paper"></div></div><div class="sect2"><h3 id="_一些符号">一些符号</h3><div class="paragraph"><p>论文中为了叙述方便，还定义了一些符号。</p></div><div class="sect3"><h4 id="_r_1u">$R^&#123;-1&#125;(u)$</h4><div class="quoteblock"><blockquote><div class="paragraph"><p>For a relation $R \subseteq A \times A$ and an element $u \in A$, we let $R^&#123;−1&#125;(u) = \&#123; v \mid (v, u) \in R \&#125;$.</p></div></blockquote></div><div class="paragraph"><p>直觉上$R^&#123;-1&#125;$就是$R$的反序，但是需要注意的是$R$有可能是一个偏序关系。</p></div><div class="paragraph"><p>例如上面提到的Transaction内部的program order $\mathrm&#123;po&#125;$的反序$\mathrm&#123;po&#125;^&#123;-1&#125;$。</p></div></div><div class="sect3"><h4 id="_max_mathrmra和min_mathrmra">$\max_\mathrm&#123;R&#125;(A)$和$\min_\mathrm&#123;R&#125;(A)$</h4><div class="quoteblock"><blockquote><div class="paragraph"><p>For a total order $\mathrm&#123;R&#125;$ and a set $A$, we let $\max_\mathrm&#123;R&#125;(A)$ be the element $u \in A$ such that $\forall v \in A. \ v = u \lor (v, u) \in R$; if $A = \emptyset$, then $\max_\mathrm&#123;R&#125;(A)$ is undefined. In the following, the use of $\max_\mathrm&#123;R&#125;(A)$ in an expression implicitly assumes that it is defined.</p></div></blockquote></div><div class="paragraph"><p>直觉上，$\max_\mathrm&#123;R&#125;(A)$（$\min_\mathrm&#123;R&#125;(A)$）表示了非空集合$A$在序关系$\mathrm&#123;R&#125;$上的最后（早）一个元素。</p></div><div class="paragraph"><p>例如<a href="#figure-3">figure 3(e)</a>中的$\max_&#123;\mathrm&#123;po&#125;&#125;(T_1)$就是$\mathrm&#123;write&#125;(\text&#123;acct1&#125;, -40)$。</p></div></div><div class="sect3"><h4 id="_t_vdash_mathrmwrite_x_n和t_vdash_mathrmread_x_n">$T \vdash \mathrm&#123;Write&#125; \ x : n$和$T \vdash \mathrm&#123;Read&#125; \ x : n$</h4><div class="quoteblock"><blockquote><div class="paragraph"><p>defining certain attributes of a transaction $T = (E, \mathrm&#123;po&#125;)$. We let $T \vdash \mathrm&#123;Write&#125; \ x : n$ if $T$ writes to $x$ and the last value written is $n: \max_\mathrm&#123;po&#125;(E \cap \mathrm&#123;WEvent&#125;_x) = (\_, write(x, n))$.</p></div></blockquote></div><div class="paragraph"><p>直觉上$T \vdash \mathrm&#123;Write&#125; \ x : n$（$T \vdash \mathrm&#123;Read&#125; \ x : n$）表示在Transaction $T$内部的Event，按照program order，最后（早）一个对$x$的写入（读取）为$n$。</p></div><div class="paragraph"><p>例如<a href="#figure-3">figure 3(e)</a>中$T_1 \vdash \mathrm&#123;Write&#125; \ \text&#123;acct1&#125; : -40$。</p></div></div></div><div class="sect2"><h3 id="_read_atomic">Read Atomic</h3><div class="paragraph"><p>首先我们先学习一下论文中提到的几个基本性质以及一些较弱的隔离性级别。论文中介绍的最弱的隔离性级别是Read Atomic（RA），但是从<a href="#ramp-figure-1">RAMP figure 1</a>可以看出，这一隔离性级别仍然高于ANSI SQL中定义的几种较弱的隔离性级别，并且RA和RR是略有区别的两种不同的隔离级别。比较RA和RU/RC/RR以及<a href="#transactional-consistency-models">[1]</a>中定义的各种性质之间的关系，涉及到如何形式化的表述RU/RC/RR，以及这些定义和各种性质之间的关系，限于篇幅不在本文进行解释，有兴趣的话可以在<a href="#ramp-tods">[6]</a>的3.3中找到相关内容。</p></div><div class="paragraph"><p>非形式化的，RA不允许出现 <em>fractured reads</em> <a href="#ramp-tods">[6]</a>：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>Definition 3.1 (Fractured Reads). A transaction $T_j$ exhibits the fractured reads phenomenon if transaction $T_i$ writes versions $x_a$ and $y_b$ (in any order, where $x$ and $y$ may or may not be distinct items), $T_j$ reads version $x_a$ and version $y_c$, and $c &lt; b$.</p></div></blockquote></div><div class="paragraph"><p><a href="#transactional-consistency-models">[1]</a>中首先介绍了2个基本性质：<em>internal consistency axiom</em>（INT）和 <em>external consistency axiom</em>（EXT）。</p></div><div class="stemblock"><div class="content">\[\forall(E, \mathrm&#123;po&#125;) \in \mathcal&#123;H&#125; . \forall e \in E . \forall x, n .\left(e=(\_, \operatorname&#123;read&#125;(x, n)) \land\left(\mathrm&#123;po&#125;^&#123;-1&#125;(e) \cap \mathrm&#123;HEvent&#125;_&#123;x&#125; \neq \emptyset\right)\right) \\\implies \max_&#123;\mathrm&#123;po&#125;&#125;\left(\mathrm&#123;po&#125;^&#123;-1&#125;(e) \cap \mathrm&#123;HEvent&#125;_&#123;x&#125;\right)=(\_,\_(x, n))\tag&#123;INT&#125;\]</div></div><div class="paragraph"><p>直觉上，INT性质保证了，在一个Transaction内，如果读$x$读到了$n$，那么在同一个Transaction内如有上一个对$x$的操作，则一定是$\operatorname&#123;read&#125;(x, n)$或$\operatorname&#123;write&#125;(x, n)$，因此被称为 <em>internal</em> consistency axiom。</p></div><div class="paragraph"><p>特别的，INT性质保证了一旦读到了一个值，那么之后无论读多少次，只要中间没有插入写操作，这个值都不会发生变化，即排除了 <em>unrepeatable reads</em> 的可能。</p></div><div class="stemblock"><div class="content">\[\forall T \in \mathcal&#123;H&#125; . \forall x, n . T \vdash \mathrm&#123;Read&#125; \  x : n \implies \\\left(\left(\mathrm&#123;VIS&#125;^&#123;-1&#125;(T) \cap\&#123;S \mid S \vdash \mathrm&#123;Write&#125; \  x :\_ \&#125;=\emptyset \land n=0\right) \lor \\\max_&#123;\mathrm&#123;AR&#125;&#125;\left(\mathrm&#123;VIS&#125;^&#123;-1&#125;(T) \cap\&#123;S \mid S \vdash \mathrm&#123;Write&#125; \  x :\_ \&#125;\right) \vdash \mathrm&#123;Write&#125; \  x : n\right)\tag&#123;EXT&#125;\]</div></div><div class="paragraph"><p>直觉上，EXT性质保证了，在$T_1$中第一个读到$x = n$的操作，是因为在$\mathrm&#123;VIS&#125;$序中$T_1$的上一个Transaction中如存在$T_0$，则$T_0$中最后一次对$x$的写操作写入了$n$；否则$n = 0$（读到初始值）。这里由于$\mathrm&#123;VIS&#125;$是偏序关系，可能不止一个$T_0$这样的Transaction，此时取他们之间在$\mathrm&#123;AR&#125;$序中的最后一个。EXT性质保证了第一次读到$x$的值是因为“之前”的某个其他的Transaction写入的，因此被称为 <em>external</em> consistency axiom。</p></div><div class="paragraph"><p>特别的，EXT性质保证了不会出现 <em>dirty reads</em>，因为没有commit（不管是abort还是on-going的）的Transaction不会出现在abstract execution中（这里不太严谨，因为没有INT性质的话不会保证中间不能读到任意奇怪的结果）。因此这一性质已经超出了Read Committed的要求（这里是我自己不太严谨的结论，不严谨的地方在于没有约定关于 <em>dirty writes</em> 的性质）。</p></div><div class="paragraph"><p>此外，EXT性质保证了 <em>atomic visibility</em>：either all or none of its writes can be visible to another transaction。这也是为什么这个隔离性级别叫做Atomic Read的原因，它保证了不会出现fractured reads，因此可以用于一些需要完整性验证的场合，例如：</p></div><div class="olist arabic"><ol class="arabic"><li><p>$T_1$写入了Alic和Bob之间双向成为了朋友关系，那么之后的$T_1$不会只观察到单向的关系，见<a href="#figure-3">Figure 3(b)</a></p></li><li><p>Secondary Index的场景</p></li></ol></div></div><div class="sect2"><h3 id="_causal_consistency">Causal consistency</h3><div class="paragraph"><p>尽管Read Atomic已经是一个比较强的一致性级别了，它能够保证一个Transaction中写入的内容总是一起被其他Transaction看到（不会只看到其中的一部分，fractured reads），但是不能保证这些写入在什么情况下被观察到。这意味着两种情况：</p></div><div class="olist arabic"><ol class="arabic"><li><p><a id="unbounded-staleness"></a>在“真实时间”上过了足够久还没有被发现，极端情况下我们可以实现一个trivial数据库所有的写入其实都不生效，关于这方面的扩展讨论见<a href="#pbs">[8]</a></p></li><li><p>有可能违背因果（Causal）关系，例如<a href="#figure-3">Figure 3(a)</a>中$T_3$已经读到了$T_2$写入的$\operatorname&#123;write&#125;(y,\text&#123;comment&#125;)$，因此也应该能读到$T_2$读到的$\operatorname&#123;read&#125;(x,\text&#123;post&#125;)$</p></li></ol></div><div class="paragraph"><p>Causal consistency要求不能违背因果关系，在当前的模型中，$\mathrm&#123;VIS&#125;$实际上捕获了因果关系，因此只需$\mathrm&#123;VIS&#125;$具有传递性即可保证因果一致性，即<a href="#figure-1">Figure 1</a>中的TRANSVIS性质。</p></div></div><div class="sect2"><h3 id="_parallel_snapshot_isolation">Parallel snapshot isolation</h3><div class="paragraph"><p>在<a href="#hat">[4]</a>中论述过，Causal consistency是能够达到100% High Availability的最高一致性级别，这意味着不需要Replica之间进行任何通信，也可以实现Causal consistency，由此可能带来 <em>lost update</em><a href="#critique-sql-isolation">[2]</a>的问题：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>P4 (Lost Update): The lost update anomaly occurs when transaction $T_1$ reads a data item and then $T_2$ updates the data item (possibly based on a previous read), then $T_1$ (based on its earlier read value) updates the data item and commits.</p></div></blockquote></div><div class="paragraph"><p>例如<a href="#figure-3">Figure 3(c)</a>尽管满足causual consistency，但是$T_1$的$\operatorname&#123;write&#125;(\text&#123;acct&#125;, 50)$就被冲掉了。为此，我们引入NOCONFLICT性质来约束这种情况：</p></div><div class="stemblock"><div class="content">\[\forall T, S \in \mathcal&#123;H&#125; .\left(T \neq S \land T \vdash\text&#123;Write&#125; \  x :\_ \land S \vdash\text&#123;Write&#125; \  x :\_\right) \\\implies (T \stackrel&#123;\mathrm&#123;VIS&#125;&#125;&#123;\longrightarrow&#125; S \vee S \stackrel&#123;\mathrm&#123;VIS&#125;&#125;&#123;\longrightarrow&#125; T)\tag&#123;NOCONFLICT&#125;\]</div></div><div class="paragraph"><p>直觉上，如果$T$和$S$都对同一个对象执行了写操作，那么这两个Transaction不能是Concurrent的，即其中一个必须知道另一个在它之前committed，这样就不会出现一个写入将另一个写入冲掉了的情况了。</p></div></div><div class="sect2"><h3 id="_prefix_consistency">Prefix consistency</h3><div class="paragraph"><p>TRANSVIS保证了一个具有因果关系的链条中的每个节点都可以观察到在它之前的所有因果关系，但是如果从一开始就出现了两组相互之间没有因果关系的链条，就会出现一些奇怪的现象，这些现象的根本原因在于写入没有在有界的时间内对其他Transaction可见<a href="#unbounded-staleness">[unbounded-staleness]</a>。例如<a href="#figure-3">Figure 3(d)</a>中，$T_1$和$T_2$分别写入了$x$和$y$，$T_3$看到了对$x$的写入但是没看到对$y$的写入，$T_4$看到了对$y$的写入但是没看到对$x$的写入。我们可以通过加强TRANSVIS来禁止这种情况出现，PREFIX：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>If $T$ observes $S$, then it also observes all $\mathrm&#123;AR&#125;$-predecessors of $S$.</p></div></blockquote></div><div class="paragraph"><p>这里observes就是$\mathrm&#123;VIS&#125;$，由于$\mathrm&#123;AR&#125;$具有传递性，因此PREFIX性质蕴含TRANSVIS性质。形式化一点：</p></div><div class="stemblock"><div class="content">\[\mathrm&#123;AR&#125;; \mathrm&#123;VIS&#125; \subseteq \mathrm&#123;VIS&#125; \tag&#123;PREFIX&#125;\]</div></div><div class="paragraph"><p>这意味着$T$能看到的Transactions，在其“实际提交”之前的所有Transactions以及他们之间的“实际提交”关系都是可见的。</p></div></div><div class="sect2"><h3 id="_snapshot_isolation">Snapshot isolation</h3><div class="paragraph"><p>如<a href="#figure-1">[figure-1]</a>所示，Snapshot isolation具有INT, EXT, PREFIX和NOCONFLICT性质。</p></div><div class="paragraph"><p>Snapshot Isolation和Repeatable Read略有区别<a href="#ramp-tods">[6]</a>（<a href="#critique-sql-isolation">[2]</a>的Remark 9也对两者进行了比较，但是不如<a href="#ramp-tods">[6]</a>的模型细致）：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Definition 3.16 (Snapshot Isolation). A system provides Snapshot Isolation if it prevents phenomena G0, G1a, G1b, G1c, PMP, OTV, and Lost Updates.</p></li><li><p>Definition 3.20 (Repeatable Read). A system provides Repeatable Read isolation if it prevents phenomena G0, G1a, G1b, G1c, and Write Skew for nonpredicate reads and writes.</p></li></ol></div></div><div class="sect2"><h3 id="_serialisability">Serialisability</h3><div class="paragraph"><p>尽管Snapshot Isolation已经是相当强的一种一致性级别了，但是仍然会在某些时刻出现问题，例如<a href="#figure-3">Figure 3(e)</a>中描述的 <em>write skew</em> 问题。$T_1$和$T_2$都检查了两个账户的余额之和大于100，并且分别从两个账户中取出了100。由于$T_1$和$T_2$是并发执行的，因此在检查时刻都能通过；由于$T_1$和$T_2$分别对不同的账户进行操作，因此也不会违背NOCONFLICT性质。但是最终，$T_1$和$T_2$都执行的结果将会使得最开始的检查限制被绕过，两个账户的总额变成负数。</p></div><div class="paragraph"><p>对于这一点，我们可以使用性质TOTALVIS进行限制，即令VIS具有全序。考虑到$\mathrm&#123;AR&#125; \supseteq \mathrm&#123;VIS&#125;$，我们有$\mathrm&#123;AR&#125; = \mathrm&#123;VIS&#125;$，也就是Serialisability。</p></div></div></div></div><div class="sect1"><h2 id="_附录">附录</h2><div class="sectionbody"><div id="figure-3" class="imageblock"><div class="content"><img data-src="/images/transactional-consistency-models-figure-3.png" alt="Figure 3 in origin paper"></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>这篇论文对于建模和理解比较强的一致性有很大的帮助，但是缺点是模型不够细致以至于有些一致性级别表示不了或者区分不出来，有些anomaly的情况也没有列出来，但是对于大多数常见情况足够了。</p></div><div class="paragraph"><p>后面省略了一些refinement正确性，和其他模型等价性相关的内容，对于工程师来说意义不大。</p></div></div></div><div class="sect1"><h2 id="_题外话">题外话</h2><div class="sectionbody"><div id="hat-figure-2" class="imageblock"><div class="content"><img data-src="/images/hat-figure-2.png" alt="Figure 2 in Highly Available Transactions: Virtues and Limitations"></div></div><div class="paragraph"><p>如<a href="#hat">[4]</a>中的<a href="#hat-figure-2">HAT Figure 2</a>所示，其中左半部分主要是和multi-key之间协调相关的一致性级别，右半部分主要是single-key multi-replica之间协调相关的一致性级别，但是两者之间又有交叉。这篇论文主要论述的是Transaction的一致性模型，关于replication的一致性模型见<a href="#non-transactional">[9]</a>。</p></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="transactional-consistency-models"></a>[1] Cerone, A., Bernardi, G., &amp; Gotsman, A. (2015). A Framework for Transactional Consistency Models with Atomic Visibility. 26th International Conference on Concurrency Theory, &#123;CONCUR&#125; 2015, Madrid, Spain, September 1.4, 2015, 42(Concur), 58–71. <a href="https://doi.org/10.4230/LIPIcs.CONCUR.2015.58" class="bare">https://doi.org/10.4230/LIPIcs.CONCUR.2015.58</a></p></li><li><p><a id="critique-sql-isolation"></a>[2] BERENSON H, BERNSTEIN P, GRAY J, et al. A critique of ANSI SQL isolation levels[J]. ACM SIGMOD Record, 1995, 24(2): 1–10.</p></li><li><p><a id="weak-consistency"></a>[3] ADYA A. Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions[J]. 1999: 198.</p></li><li><p><a id="hat"></a>[4] Bailis, P., Davidson, A., Fekete, A., Ghodsi, A., Hellerstein, J. M., &amp; Stoica, I. (2013). Highly Available Transactions: Virtues and Limitations. Proceedings of the VLDB Endowment, 7(3), 181–192. <a href="https://doi.org/10.14778/2732232.2732237" class="bare">https://doi.org/10.14778/2732232.2732237</a></p></li><li><p><a id="abstract-execution"></a>[5] BURCKHARDT S. Principles of Eventual Consistency[J]. Foundations and Trends® in Programming Languages, Hanover, MA, USA: Now Publishers Inc., 2014, 1(1–2): 1–150.</p></li><li><p><a id="ramp-tods"></a>[6] Bailis, P., Fekete, A., Ghodsi, A., Hellerstein, J. M., &amp; Stoica, I. (2016). Scalable Atomic Visibility with RAMP Transactions. ACM Trans. Database Syst., 41(3), 15:1&#8212;&#8203;15:45. <a href="https://doi.org/10.1145/2909870" class="bare">https://doi.org/10.1145/2909870</a></p></li><li><p><a id="generalized-isolation-level"></a>[7] ADYA A, LISKOV B, O’NEIL P. Generalized isolation level definitions[C]//Proceedings of 16th International Conference on Data Engineering (Cat. No.00CB37073). IEEE Comput. Soc, 2002(March): 67–78.</p></li><li><p><a id="pbs"></a>[8] BAILIS P, VENKATARAMAN S, FRANKLIN M J, et al. Quantifying eventual consistency with PBS[J]. The VLDB Journal, 2014, 23(2): 279–302.</p></li><li><p><a id="non-transactional"></a>[9] VIOTTI P, VUKOLIĆ M. Consistency in Non-Transactional Distributed Storage Systems[J]. ACM Computing Surveys, 2016, 49(1): 1–34.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Consistency-Theory/">Consistency Theory</category>
      
      <category domain="http://hcoona.github.io/tags/Transaction/">Transaction</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/transactional-consistency-models/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[FAST&#39;03] ARC: A Self-Tuning, Low Overhead Replacement Cache</title>
      <link>http://hcoona.github.io/Paper-Note/arc-one-up-on-lru/</link>
      <guid>http://hcoona.github.io/Paper-Note/arc-one-up-on-lru/</guid>
      <pubDate>Sat, 30 Mar 2019 12:21:02 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ARC是一种缓存替换算法，在很多种负载环境的表现优于常用的LRU算法，并且实现难度和算法复杂度与LRU近似。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ARC算法具有以下优良特性：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;在recency和frequency之间持续的进行动态（在线）调整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无需事先指定特别的参数（先验知识）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有全局优化策略（意译，不确定翻译的对不对，原文empirically universal，note说明该词出自LZ77的论文）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以（在某种程度上）抵抗线性扫描（scan-resistant）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>ARC是一种缓存替换算法，在很多种负载环境的表现优于常用的LRU算法，并且实现难度和算法复杂度与LRU近似。</p></div><div class="paragraph"><p>ARC算法具有以下优良特性：</p></div><div class="olist arabic"><ol class="arabic"><li><p>在recency和frequency之间持续的进行动态（在线）调整</p></li><li><p>无需事先指定特别的参数（先验知识）</p></li><li><p>具有全局优化策略（意译，不确定翻译的对不对，原文empirically universal，note说明该词出自LZ77的论文）</p></li><li><p>可以（在某种程度上）抵抗线性扫描（scan-resistant）</p></li></ol></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>原论文中花费了很多篇幅介绍之前人们试图提出比LRU更好的算法的一些工作，并进行了一番对比，本文限于篇幅和精力略过这部分内容。</p></div><div class="sect1"><h2 id="_基本思想">基本思想</h2><div class="sectionbody"><div class="paragraph"><p>LRU的问题在于其只考虑了recency而完全没有考虑frequency。一般而言，保存freqency信息的代价又比较大。ARC的最根本的思路（以下称为DBL）在于使用2个LRU，其中一个$L_1$存放最近被访问1次的数据（也就是传统的LRU），另一个$L_2$存放最近被访问2次及以上的数据。这一近似减少了维护frequency的成本。最终目标是尽可能维持$|L_1| = |L_2| = c$，但是论文中并没有解释为什么要这么做。（总是能保持$|L_1| + |L_2| = 2c$，如果$|L_1| &lt; c$时会优先淘汰$L_2$中的内容给$L_1$腾地儿）</p></div><div class="paragraph"><p>我们把整个Cache分为以下2个部分：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Cache Directory</p></li><li><p>Cache Item</p></li></ol></div><div class="paragraph"><p>其中Cache Directory用于进行索引，Cache Item真正表示在缓存中的内容。对于传统LRU算法而言，以上2者的大小是一样的（Directory索引的项的数量和真正在缓存中的内容的数量）。对于上面提到的DBL而言，以上2者的大小也是一样的，为$|L_1| + |L_2| = 2c$。特别的，在DBL中，$L_1$就是一个传统的LRU，其大小为$c$。</p></div><div class="paragraph"><p>上面提到的DBL算法的问题是使用了2倍于LRU的空间，其效果比LRU好是显然的，能不能使用和LRU一样多的空间得到更好的效果呢？一个直接的想法是使用$2c$的Cache Directory但是只保留$c$个Cache Item常驻内存，那么在这$2c$个索引项中如何取舍就是一个问题。如<a href="#figure-1">[figure-1]</a>所示，我们将$L_1$和$L_2$分别拆分为$T_1, B_1, T_2, B_2$。直觉上，$T_1$比$B_1$更有价值，$T_2$比$B_2$更有价值，如果我们能够维持$|T_1| + |T_2| \le c$，则应当将$T_1 \cup T_2$中的元素保留在Cache中。</p></div><div id="figure-1" class="imageblock"><div class="content"><img data-src="/images/ARC.png" alt="ARC" width="50%"></div></div><div class="paragraph"><p>剩下的问题，在于如何在$L_1 \cup L_2$中调节$T_1 \cup T_2$的位置（即调节$|B_1|$和$|B_2|$），以及如何在$T_1 \cup T_2$中调节两者的大小分配。特别的，当$|L_1| = |T_1| = c$时，该算法等价于LRU，也就是说如果调节得当的话，该算法至少能做到和LRU一样好。</p></div></div></div><div class="sect1"><h2 id="_arc算法">ARC算法</h2><div class="sectionbody"><div class="paragraph"><p>由于我们要求保持性质$|L_1| = |L_2| = c$，因此当调节$T_1$和$T_2$的关系时，实际上就调节了$T_1 \cup T_2$在$L_1 \cup L_2$中的位置。直觉上相当于在$L_1$和$L_2$中间的地方有一个固定大小的滑块，我们在调节这个滑块的位置。不妨令$|T_1| = p$，则$|B_1| = |T_2| = c - p$且$|B_2| = p$。</p></div><div class="paragraph"><p>接下来，我们需要思考一下$B_1$和$B_2$对我们而言意味着什么。回想上面提到的DBL，$L_1$意味着最近只命中了1次的缓存项索引，其中$T_1$是我们保留在缓存中的内容，$B_1$是我们没有保留在缓存中的内容。因此，如果查询请求命中了$B_1$，意味着我们应当把这次命中当作命中了$L_1$来看，并且相应的，说明我们的$|T_1|$可能小了，没能将这次命中的数据存起来。论文中，当$|B_1| \gt |B_2|$时，$p$增加1，当$|B_1| &lt; |B_2|$时，$p$增加$|B_2| / |B_1|$，但是论文中没有解释为什么这么设计。</p></div><div class="paragraph"><p>完整的ARC算法如<a href="#figure-2">[figure-2]</a>所示，其中Case I-III对应于DBL命中的情况，Case IV对应于DBL未命中的情况。</p></div><div id="figure-2" class="imageblock"><div class="content"><img data-src="/images/ARC_algo.png" alt="ARC Algorithm"></div></div></div></div><div class="sect1"><h2 id="_问题回顾">问题回顾</h2><div class="sectionbody"><div class="paragraph"><p>之前提到了一些问题，在此继续探讨一下。</p></div><div class="sect2"><h3 id="_l_1和l_2的大小是否可以调整">$L_1$和$L_2$的大小是否可以调整</h3><div class="paragraph"><p>在目前的设计中，$|L_1| = |L_2| = c$，由于我们最多只保留$|T_1| + |T_2| = c$项内容，在极端情况下$|L_1| = |T_1| = c$，此时进一步增大$L_1$也不能再进行什么调整了（受限于Cache大小），从这个角度来看在$L_1$和$L_2$之间进行调整可能是没什么意义的。</p></div><div class="paragraph"><p>但是在论文中特别提到了 <code>E. Extra History</code>，讨论了这样一个问题：</p></div><div class="quoteblock"><blockquote>An interesting question is whether we can incorporate more history information in ARC to further improve it.</blockquote></div><div class="paragraph"><p>论文中给出了一种利用额外的空间的方法，似乎暗示了这么做是有用的，但是没有论证对比这一方法的效果如何。</p></div></div><div class="sect2"><h3 id="_p的调整为什么不是固定的">$p$的调整为什么不是固定的</h3><div class="paragraph"><p>推测是因为当$B_1$小的时候命中$B_1$是比较困难的，要对此做一个加成。但是为什么这么做论文并没有给出一个解释，也没有什么对比。</p></div></div><div class="sect2"><h3 id="_scan_resistant">Scan-Resistant</h3><div class="paragraph"><p>直觉上ARC是可以抵御扫描Pattern的请求的，因为ARC不仅考虑了recency，还考虑了frequency。具体而言，有以下2个原因：</p></div><div class="olist arabic"><ol class="arabic"><li><p>扫描会刷新$L_1$的内容，但是不会影响$L_2$的内容</p></li><li><p>扫描会更多的命中$B_2$（相较于$B_1$），因此会进一步减小$|T_1|$，进而使得扫描造成的影响比单纯考虑第1点更小</p></li></ol></div></div></div></div><div class="sect1"><h2 id="_不总结总觉得少点什么">不总结总觉得少点什么</h2><div class="sectionbody"><div class="paragraph"><p>总的来说，ARC算法通过一种比较巧妙的方法，在不显著增加实现成本和算法时间复杂的情况下，较为显著的改进了LRU算法。使用LRU来承载最近遇到2次以上的数据来近似捕获frequency信息是一大亮点。动态平衡的方案直觉上有效，但是细节上缺乏有力的论证，不确定是不是一个最优的算法。对于动态变化的数据而言，动态平衡的算法优于静态的算法是可以预期的。</p></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="arc1"></a>[1] MEGIDDO N, MODHA D S. ARC: A Self-Tuning, Low Overhead Replacement Cache[C]//CHASE J. Proceedings of the &#123;FAST&#125; ’03 Conference on File and Storage Technologies, March 31 - April 2, 2003, Cathedral Hill Hotel, San Francisco, California, &#123;USA&#125;. USENIX, 2003.</p></li><li><p><a id="arc2"></a>[2] NIMROD MEGIDDO, MODHA D S. one up on LRU[J]. ;Login:, 2003, 28(4).</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Algorithms/">Algorithms</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/arc-one-up-on-lru/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>分布式系统入门介绍</title>
      <link>http://hcoona.github.io/Tips/distributed-systems-101/</link>
      <guid>http://hcoona.github.io/Tips/distributed-systems-101/</guid>
      <pubDate>Fri, 22 Mar 2019 13:23:34 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文特别写给想要学习分布式系统但是还不知道该如何下手的读者，宽泛并点到为止的介绍了我个人对于分布式系统各个方面的一些不成熟的理解，帮助读者认识到分布式系统领域的一个全景图，以便接下来寻找感兴趣的领域进行深入的学习。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;学习分布式系统，需要回答以下几个问题：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;（需求分析）分布式系统主要解决哪些问题？主要应用场景有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（实现方案）构建分布式系统的常见问题有哪些？解决这些问题的主流方案有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（技术难点）实现分布式系统的本质困难是什么？这些困难影响了那些问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（工业应用）工业上正在构建那些分布式系统？他们的发展情况如何？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>本文特别写给想要学习分布式系统但是还不知道该如何下手的读者，宽泛并点到为止的介绍了我个人对于分布式系统各个方面的一些不成熟的理解，帮助读者认识到分布式系统领域的一个全景图，以便接下来寻找感兴趣的领域进行深入的学习。</p></div><div class="paragraph"><p>学习分布式系统，需要回答以下几个问题：</p></div><div class="olist arabic"><ol class="arabic"><li><p>（需求分析）分布式系统主要解决哪些问题？主要应用场景有哪些？</p></li><li><p>（实现方案）构建分布式系统的常见问题有哪些？解决这些问题的主流方案有哪些？</p></li><li><p>（技术难点）实现分布式系统的本质困难是什么？这些困难影响了那些问题？</p></li><li><p>（工业应用）工业上正在构建那些分布式系统？他们的发展情况如何？</p></li></ol></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>特别提示，这篇文章全凭个人经验写成，有些看法和理解可能不正确，如有任何疑问，还请在评论区讨论，谢谢。</p></div><div class="sect1"><h2 id="_分布式系统的基本问题和应用场景">分布式系统的基本问题和应用场景</h2><div class="sectionbody"><div class="paragraph"><p>分布式系统主要解决以下2个问题：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Scalability，特别的，指Scale Out</p></li><li><p>High Availability，特别的，指通过软件系统的设计，组合多个相对可靠性较低的设备对外提供更高的可用性</p></li></ol></div><div class="paragraph"><p>互联网时代的到来，使得我们需要解决的问题规模越来越大，以至于单机的Capacity增长速度难以满足需要。这里的Capacity可能是计算资源（CPU、内存），存储资源（硬盘），甚至是网络资源（网络IO）。分布式系统通过在软件层面上协调多个终端共同工作来提供服务，以满足对Capacity的需求。其本质上和操作系统、虚拟机等技术的作用一样，都是使用软件对上层屏蔽下层的细节。</p></div><div class="paragraph"><p>随着分布式系统规模的不断增长，人们（Google）发现大量使用通用硬件取代商业高可用硬件，可以节省大量成本。于是使用软件模拟高可用的技术应运而生，这也是分布式系统着力于解决的一大问题。</p></div><div class="paragraph"><p>本质上，系统软件的发展就是使用软件屏蔽底层细节的过程。明确了这一思路，分布式系统的应用场景就很容易找了。先从最底层的硬件开始：</p></div><div class="olist arabic"><ol class="arabic"><li><p>计算资源（CPU）</p></li><li><p>存储（硬盘、内存）</p></li><li><p>通信网络（网卡、交换机）</p></li><li><p>整个物理机（虚拟机）</p></li></ol></div><div class="paragraph"><p>然后上升到操作系统：</p></div><div class="olist arabic"><ol class="arabic"><li><p>调度（进程、线程）</p></li><li><p>隔离（时间片共享、队列、Namespace）</p></li><li><p>整个操作系统（容器）</p></li></ol></div><div class="paragraph"><p>最后到各个具体应用：Software as a Service</p></div><div class="paragraph"><p>特别需要注意的是，尽管都是屏蔽底层细节，但是屏蔽到什么程度仍然是值得探索的一个问题。个人认为，主张完全屏蔽下层细节，尤其是屏蔽分布式系统和单机系统这一细节的尝试基本上已经宣告失败。这方面的探索主要体现在构建分布式共享内存（Distributed Shared Memory）这一topic上。出于性能上的考虑，上层需要理解并一定程度上配合底层细节。因此暴露何种细节，提供什么样的接口仍然是一个值得思考的问题。但是随着硬件和底层设施的发展，这一问题也在不断变换。</p></div></div></div><div class="sect1"><h2 id="_构建分布式系统的常见问题和解决方案">构建分布式系统的常见问题和解决方案</h2><div class="sectionbody"><div class="sect2"><h3 id="_节点的组织">节点的组织</h3><div class="paragraph"><p>分布式系统最基础的问题在于如何将分布式节点组织起来发挥作用，这方面的讨论在<a href="https://zhuanlan.zhihu.com/p/34323809">论文笔记：关于 P2P 的一些综述</a>中有一个总结。大体上，分布式节点的组织方式有以下几种：</p></div><div class="ulist"><ul><li><p><strong>Hybrid Decentralized</strong>: 具有中心节点进行协调或索引，但是其他部分都是分布式的，例如 HDFS, BitTorrent。</p></li><li><p><strong>Partially Centralized</strong>: 不具有中心节点，但是具有 super node，例如类似于 DNS 的结构，但是每层的上一层都是选举出来的 super node。</p></li><li><p><strong>Purely Decentralized</strong>: 完全分布式，节点完全对等</p><div class="ulist"><ul><li><p><strong>Unstructured</strong>: 节点不组成固定结构，类似于物理路由器，只知道附近的几个邻居节点。因此查询等操作主要依赖于 flooding 或类似于物理路由器的路由操作。</p></li><li><p><strong>Structured</strong>: 节点组成固定结构，例如 Chord（环）, CAN（多维空间）, Tapestry（超立方体）</p></li></ul></div></li></ul></div><div class="paragraph"><p>其中Partially Centralized和Purely Decentralized没有什么本质上的区别，但是Hybrid Decentralized一直被诟病存在中心节点带来的性能和可用性问题。尽管从Google和目前各个开源系统的实践来看，Hybrid Decentralized是一种能够以较低的成本构造（代码质量上）可靠的分布式系统的实用方法，但是随着问题规模的进一步增长，中心节点也确实成为了瓶颈（进而需要使用Federation的方案把中心节点再分布式化），由中心节点带来的性能问题也仍然很难解决。</p></div><div class="paragraph"><p>分布式节点的组织必然需要通信作为支撑。对于一个存在中心节点的系统，这个问题比较好解决，只需要额外处理好中心节点的限流、延迟等问题即可。对于不存在中心节点的系统，需要解决好以下几个问题：</p></div><div class="olist arabic"><ol class="arabic"><li><p><strong>Membership protocol</strong>: 哪些节点是当前Overlay network的成员？</p></li><li><p><strong>Naming service</strong>: 本质上是名字到位置的索引</p></li><li><p><strong>Message routing</strong>: 如何将消息从一个位置投递到目标位置？</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p><strong>unicast</strong></p></li><li><p><strong>anycast</strong></p></li><li><p><strong>groupcast</strong></p></li><li><p><strong>atomic groupcast</strong></p></li><li><p><strong>total ordered groupcast</strong></p></li></ol></div></li></ol></div></div><div class="sect2"><h3 id="_节点的协作">节点的协作</h3><div class="paragraph"><p>由于我们需要解决的问题之一就是Capacity的问题，必然会出现需要取用的数据分布在多个节点的情况。在这种情况下，需要节点之间进行协作。此时，在传统并行计算领域的基础组件需要在分布式领域重新实现：</p></div><div class="olist arabic"><ol class="arabic"><li><p>临界区和锁</p></li><li><p>原子性和事务</p></li></ol></div><div class="paragraph"><p>目前解决这一问题主要依赖于分布式事务，工业实现正在从2PC过渡到Paxos <a href="#paxos_trans">[1]</a>。跨越Shard的Compare-And-Swap操作不存在 <a href="#wait_free">[2]</a>。只读或者只写的分布式事务存在优化的可能。关于这部分的讨论在<a href="https://zhuanlan.zhihu.com/p/37076900">CAP，ACID，我们能做什么</a>中有一个总结。</p></div></div><div class="sect2"><h3 id="_数据的复制和一致性">数据的复制和一致性</h3><div class="paragraph"><p>为了支持High Availability，分布式系统一般都会将数据进行复制，但是由此可能会引起一致性问题。传统的一致性问题在并行计算领域就已经产生了，例如多核CPU的Cache就是一个典型的例子。但是一致性问题在分布式领域有着更多的困难，这一困难源于物理机之间的通信网络可靠性比物理机内部的（尤其是CPU核心之间，核心和内存、缓存之间）的通信低的多。关于这部分的讨论在<a href="https://zhuanlan.zhihu.com/p/37076900">CAP，ACID，我们能做什么</a>中有一个总结。</p></div></div></div></div><div class="sect1"><h2 id="_分布式系统的本质难点">分布式系统的本质难点</h2><div class="sectionbody"><div class="paragraph"><p>个人认为，分布式系统所有的理论难点都源于这2个关键点：</p></div><div class="olist arabic"><ol class="arabic"><li><p>在分布式系统中不存在全局时钟</p></li><li><p>在分布式系统中通信是不可靠的（保证信息不重不漏的通信延迟是有限无界的）</p></li></ol></div><div class="paragraph"><p>由于这两点，我们不能构建事件的全序关系：</p></div><div class="olist arabic"><ol class="arabic"><li><p>不能通过时戳定序</p></li><li><p>不能通过通信（在有界的延迟内）定序</p></li></ol></div><div class="paragraph"><p>上面提到的全序组播，分布式锁和事务，没有提到的节点失效检测等问题，都受这一本质问题（事件定序）的影响。</p></div></div></div><div class="sect1"><h2 id="_分布式系统的工业应用">分布式系统的工业应用</h2><div class="sectionbody"><div class="paragraph"><p>这里只讨论比较底层的系统。</p></div><div class="sect2"><h3 id="_分布式存储">分布式存储</h3><div class="paragraph"><p>分布式存储系统是最早进入大众视野的分布式产品，以NoSQL为大旗抢占了传统数据库的大量市场份额。</p></div><div class="paragraph"><p>所有存储系统的本质都是数据加上数据的索引。</p></div><div class="paragraph"><p>最简单的分布式存储系统是Key-Value存储，其难点在于如何构建Key的索引以及所有分布式系统都需要面对的一致性问题。主流的Key-Value存储使用一致性哈希构建Key的索引，这方面的问题主要集中在如何做scan，以及有可能需要扩展的secondary index。关于哈希表的相关讨论见<a href="https://zhuanlan.zhihu.com/p/35673745">哈希表总结及其高级话题讨论</a>。也有分布式系统以树状结构构建Key的索引（BigTable）。</p></div><div class="paragraph"><p>分布式存储系统的一致性问题取决于业务场景的需求，在此不进行展开。但是如何在不同的一致性级别之间平滑切换，也是学术界和工业界共同的热点。特别的，在弱一致性情况下，可能会产生数据冲突，如何提供业务友好的冲突解决方案，也是一个很好的方向。冲突解决的研究见<a href="https://zhuanlan.zhihu.com/p/33912913">论文笔记：[Inria RR-7506] A comprehensive study of Convergent and Commutative Replicated Data Types</a>以及<a href="https://zhuanlan.zhihu.com/p/35426881">论文笔记：[ICDE'18] Anna: A KVS for any scale</a>。</p></div><div class="paragraph"><p>还有一些单机和分布式存储系统都需要面对的问题：性能优化。</p></div><div class="olist arabic"><ol class="arabic"><li><p>读多写少，读少写多等特殊场景下的性能优化</p></li><li><p>随机读写和顺序读写场景下，吞吐和延迟的优化</p></li><li><p>行式存储和列式存储的取舍与优化</p></li></ol></div><div class="paragraph"><p>虽然分布式存储在最初是举起NoSQL的大旗革了传统数据库的命，但是仍然还是需要去解决传统数据库已经解决过的问题，其中非常重要的一点就是Schema。有了Schema，系统就能理解Value的含义，而不只是将其当做一坨Blob。理解了Value的含义，才能做更多特化的事情，进一步提高性能。</p></div><div class="paragraph"><p>目前也有一些存储系统开始尝试加上一些计算的功能，但是实现的方式还都比较初级，基本上都是将计算任务下推到数据所在的节点进行计算，再将结果汇总。个人认为存储和计算的完全分离是未来的主流方向，上面提到的实现方式的优点是延迟较低，但是分布式计算和根据元数据进行调度的系统配合起来完全能够达到这个效果，并且还有额外的好处。</p></div><div class="paragraph"><p>此外就是特殊场景的优化。一个是OLAP，以及OLAP和OLTP的融合。还有一个是时间序列数据的特定场景优化。</p></div></div><div class="sect2"><h3 id="_分布式计算">分布式计算</h3><div class="paragraph"><p>最早为人所熟知的分布式计算框架可能是MapReduce（不算MPI的话）。MapReduce的模型比较简单，很难满足业务复杂的需求，于是Tez和Spark这样的系统应运而生。实践上来看，RDD+DAG的模型已经能够很好地表述大多数业务逻辑。</p></div><div class="paragraph"><p>流式计算和批量计算没有本质上的区别，基本上可以认为批量计算是流式计算的一个特例。但是由于历史原因，目前批量计算框架在进行批量计算时，性能要强于流式算计框架。流式计算如果不关心数据的顺序的话，可以采用micro batch的方式进行处理。流式计算如果关心数据的顺序的话，问题会变得稍微复杂一些。困难在于，只从数据的角度来看的话，数据在进行划分的时候是有限无界的。但是从业务的角度来看，如果数据的延迟足够大的话，可以认为这些数据可以被抛弃（意味着不存在这样的数据），因此可以在时间限制上强行划出硬界限。从业务的角度来看，数据的延迟大概率会在一个软界限以内，可以以这个界限对数据进行划分，超出软界限的数据走旁路流程进行补救，从而将延迟大概率控制到软界限以内。批量计算可以认为是界限分明的数据进行流式计算。</p></div><div class="paragraph"><p>仍然有一些业务要求比Dataflow更复杂的计算模型。最通用的模型就是用户自己写代码，可以允许任意复杂，即对托管服务的支持。目前k8s天然支持托管服务，YARN在这方面的支持较少，也没有很出色的通用框架。对于其他一些应用比较广泛的计算模型，例如图计算，机器学习，目前已经有了一些计算框架支持。</p></div><div class="paragraph"><p>人们对于本地性的看法也随着时间发展发生了一些变化。最早的时候由于缺乏分布式存储，人们别无选择只能让数据和计算绑定。MapReduce提出的另一个思想就是计算跟着数据跑，尽可能的把计算分配到数据所在的节点。这一思想其实在HPC中也早有应用。但是随着网络栈速度的大幅提升，人们发现本地性不再像以前一样重要（当然，仍然很重要）：</p></div><div class="olist arabic"><ol class="arabic"><li><p>计算和存储的比例很难事先确定</p></li><li><p>TOR内与POD内网络带宽相比较不再具有压倒性的优势</p></li></ol></div><div class="paragraph"><p>另一方面，随着集群规模的扩大和迭代，人们很难保证一个集群内的机器都是同构的（之前在HPC的时代很容易保证），于是对于异构调度的需求变得逐渐强烈起来，并且压倒了本地性的需求。于是最终调度从计算框架中分离出来作为一个相对独立的中间件存在。</p></div><div class="paragraph"><p>目前看来，分布式计算领域主流计算模型已经有了可用的计算框架支持，后续的问题主要在于如何进一步提高性能（吞吐和延迟两方面）。个人认为近几年的性能优化主要还是把数据库领域中已有的功能拿回来，我们应该更多的关注VLDB这样的数据库期刊。另外一些优化的点则在于分布式系统特有的问题，尤其是系统的组件可靠性比传统HPC低造成的问题。</p></div></div><div class="sect2"><h3 id="_分布式调度">分布式调度</h3><div class="paragraph"><p>由于大量使用通用硬件代替HPC，集群内的机器开始出现异构的情况，并且用户的任务也是异构的，于是对于调度的要求提高了很多。分布式调度主要有以下几个发展方向：</p></div><div class="olist arabic"><ol class="arabic"><li><p>精细化调度</p></li><li><p>特殊场景的调度</p></li><li><p>可插拔的灵活调度</p></li></ol></div><div class="paragraph"><p>精细化调度体现在以下几个方面：</p></div><div class="olist arabic"><ol class="arabic"><li><p>调度的粒度变得更细（整机&#8594;Slot&#8594;Fine Grain）</p></li><li><p>需要调度的资源类型和维度都在增长（可伸缩/不可伸缩，CPU/MEM/GPU/IO/&#8230;&#8203;）</p></li><li><p>调度的物理机情况变得更加复杂（资源异构，亲和性，条件限制，&#8230;&#8203;）</p></li><li><p>考虑目标机器状态的调度（机会调度，超售，&#8230;&#8203;）</p></li><li><p>考虑全局策略的调度</p></li></ol></div><div class="paragraph"><p>特殊场景的调度有些是可以在性能上进行极大的优化，有些是有特殊的限制需求，例如Gang Scheduling，有Deadline要求的调度等等。</p></div><div class="paragraph"><p>目前分布式集群的使用方式也和HPC大有不同，不再是一个任务跑完了再跑另一个任务了，而是多种任务一起去跑。在这种情况下，不同的任务对于调度的需求又有不同，因此需要可插拔的灵活调度机制。</p></div><div class="paragraph"><p>总体而言，调度的发展趋势更多的要求全局信息。目前由于没有成熟的分布式数据库方案的支持，一般选择中心化全局信息的方案，这反过来又限制了集群的规模。为了解决集群规模增长的问题，一般使用Sharding和Facade的方式去做，但是也有难以解决的问题。</p></div><div class="paragraph"><p>这里插一段个人思考，调度是否适合采用乐观并发？如果调度如果采用乐观并发的话，对于一致性的需求就降低了，这样的话不使用分布式数据库也能解决这个问题。</p></div></div><div class="sect2"><h3 id="_其他中间件">其他中间件</h3><div class="paragraph"><p>除了上面提到的比较大块的内容以外，也有专注于解决具体细节问题的方向。</p></div><div class="paragraph"><p>首先要解决的就是节点的组织（含一致性哈希等方式）和消息路由（含Sharding）的问题，这方面比较知名的中间件有Consul和Akka。节点组织起来之后也有可能会失效，因此需要失效检测的中间件（Failure Detector），但是这在分布式系统中是一个困难问题。然后有的人致力于解决可靠传输的问题，这方面的发展趋势是将协议栈倒置，让传输层而非应用层称为最上层，例如Kafka。另一个趋势是Message Broker越来越向通用存储发展，两者的界限越来越不分明，例如k8s使用etcd来做“消息传递”。锁，分布式事务，选主，这三个是一回事，目前稳定的实现是Raft的各个变种，趋势是使用Paxos，因为优化的余地更大（Raft相当于是Paxos的串行版本）。</p></div><div class="paragraph"><p>分布式带来的另一个问题是DEBUG的难度进一步上升，因为一个用户请求会分散到不同的机器上。为此我们使用3种不同的方法来解决这一问题（<a href="https://speakerdeck.com/adriancole/observability-3-ways-logging-metrics-and-tracing">Observability 3 ways: logging metrics and tracing</a>）：</p></div><div class="ulist"><ul><li><p>收集日志，日志包括一台机器上最为详细的细节信息</p></li><li><p>收集Metrics，Metrics由于只是数因此方便做统计</p></li><li><p>做Tracing，将一个用户请求的全过程串起来</p></li></ul></div><div class="paragraph"><p>除此之外还有很多小的领域，不在此一一介绍。</p></div></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="paxos_trans"></a>[1] GRAY J, LAMPORT L. Consensus on Transaction Commit[J]. 2004, 1(April 2004).</p></li><li><p><a id="wait_free"></a>[2] HERLIHY M. Wait-free synchronization[J]. ACM Transactions on Programming Languages and Systems, 1991, 13(1): 124–149.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      
      <comments>http://hcoona.github.io/Tips/distributed-systems-101/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>大规模集群管理和运维自动化</title>
      <link>http://hcoona.github.io/Tips/cluster-management-and-devops/</link>
      <guid>http://hcoona.github.io/Tips/cluster-management-and-devops/</guid>
      <pubDate>Wed, 29 Aug 2018 15:07:13 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;说到大规模集群管理，就离不开运维自动化。一个人手工也许可以运维几百台机器，但是随着集群规模的增长，我们需要的是一个人运维数万台机器。
这在大规模集群管理中是一个常见的问题。因此，运维自动化是一个很重要的事情，这也是为什么很多公司原因上云，因为上云之后运维的问题就托管给
云平台了。这也是云平台这么贵还能卖的这么好的原因。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;运维自动化的问题到底是一个什么问题？我认为，可以拆解为以下子问题：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;自动发现错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动修复错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全（Safety而非Security）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里的每一个问题都是复杂的，困难的问题，远非表面上看起来那么简单。以下仅作简单的展开，提供一些思路。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>说到大规模集群管理，就离不开运维自动化。一个人手工也许可以运维几百台机器，但是随着集群规模的增长，我们需要的是一个人运维数万台机器。这在大规模集群管理中是一个常见的问题。因此，运维自动化是一个很重要的事情，这也是为什么很多公司原因上云，因为上云之后运维的问题就托管给云平台了。这也是云平台这么贵还能卖的这么好的原因。</p></div><div class="paragraph"><p>运维自动化的问题到底是一个什么问题？我认为，可以拆解为以下子问题：</p></div><div class="olist arabic"><ol class="arabic"><li><p>自动发现错误</p></li><li><p>自动修复错误</p></li><li><p>安全（Safety而非Security）</p></li></ol></div><div class="paragraph"><p>这里的每一个问题都是复杂的，困难的问题，远非表面上看起来那么简单。以下仅作简单的展开，提供一些思路。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect1"><h2 id="_自动发现错误">自动发现错误</h2><div class="sectionbody"><div class="paragraph"><p>我们先简单的将错误划分为两类：硬件错误和软件错误。</p></div><div class="sect2"><h3 id="_硬件错误">硬件错误</h3><div class="paragraph"><p>通常，商业硬件都会提供一些接口用于获取硬件错误信息，这些错误信息是由硬件自检产生的，例如硬盘S.M.A.R.T。通过这些接口报告的错误信息是比较准确的。但是还有一些情况，虽然硬件出问题了，但是硬件自检没有检测到。这种情况也会影响运行的软件，需要通过其他方式进行检测。这种问题通常是由业务方发现异常，排除软件错误因素后，或由统计结论导出，确认为硬件问题。具体是什么硬件问题，还需要离线进行进一步检测。</p></div><div class="paragraph"><p>还有一类特殊的硬件错误，发生点不在本机，但是也会影响服务，即网络错误。网络错误根据现象一般有以下分类：</p></div><div class="olist arabic"><ol class="arabic"><li><p>传输内容错误，例如数据位反转</p></li><li><p>大量丢包，例如CRC校验莫名出现大量错误，但是实际上没错（有可能是硬件错误，也有可能是系统内核错误）</p></li><li><p>带宽下降，例如交换机错误</p></li><li><p>连接丢失，例如交换机错误</p></li></ol></div><div class="paragraph"><p>由于网络错误不一定发生在本机，因此很难通过单机定位问题，通常通过PingMesh结合其他手段发现问题，例如流量监控，内核关键metric，交换机关键metric。最近的新方向是结合SDN和机器学习发现并解决网络问题。</p></div></div><div class="sect2"><h3 id="_软件错误">软件错误</h3><div class="paragraph"><p>软件错误的类型五花八门。通用的检测和容忍错误的机制是复杂而困难的（例如拜占庭问题），所以要允许用户灵活方便的扩展错误发现规则。一般来说，软件错误有以下几种：</p></div><div class="olist arabic"><ol class="arabic"><li><p>操作系统错误</p></li><li><p>依赖环境错误</p></li><li><p>数据错误</p></li><li><p>配置错误</p></li><li><p>自身bug</p></li></ol></div></div></div></div><div class="sect1"><h2 id="_自动修复错误">自动修复错误</h2><div class="sectionbody"><div class="paragraph"><p>通用的解决所有问题的方案（大概率）是不存在的，但是我们又不能完全为每一个特殊的错误定制修复的方法。对于硬件故障，我们只有换机器一条路可走。对于操作系统的问题，通常重启即可解决问题，如果不能解决问题，可能需要重做系统。重做系统也涵盖了系统升级的需求（考虑到有些时候需要升级内核才能解决问题）。数据错误需要使用强checksum校验，具体需要多强，需要覆盖多大范围，则是一个仁者见仁智者见智的问题。配置错误和自身bug其实是部署需要解决的问题，如果能够及时发现问题，只需要在部署的过程中中止并回滚即可解决问题。而如何部署，又是一个可以写一篇文章的大问题了:D</p></div></div></div><div class="sect1"><h2 id="_安全">安全</h2><div class="sectionbody"><div class="paragraph"><p>自动化最担心的问题就是安全。不能保证安全会导致可怕的后果，例如瞬间几万台机器被重做系统。在大规模集群管理中，所谓安全，实际上指的是安全规则，安全规则保证的则是SLA。可预期的SLA通常由MTBF（Mean Time Between Failures）计算得出理论上限。自动修复会导致理论MTBF降低，这是因为我们通过错误发现机制在建模的时候考虑了更多的错误因素。重启服务，重启机器，重做系统，换机器，都会导致服务中断。我们可以认为，在错误修复期间，这台机器上的服务不可用。此时，如何有序的保证剩下的可用机器总是大于一定数量（并且满足一定规则），则是安全的核心。</p></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Cluster-Management/">Cluster Management</category>
      
      
      <comments>http://hcoona.github.io/Tips/cluster-management-and-devops/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[Operating Systems Review 2007] Autopilot: Automatic Data Center Management</title>
      <link>http://hcoona.github.io/Paper-Note/Microsoft-Autopilot/</link>
      <guid>http://hcoona.github.io/Paper-Note/Microsoft-Autopilot/</guid>
      <pubDate>Sat, 14 Jul 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Autopilot是微软Bing组研发的集群管理系统，至今已有近20年的历史。Autopilot是一个内部模块高度解耦，完善发达的系统，其设计目标是自动化的管理静态集群。自动化的好处有以下几点：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;节省人力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应速度和处理时间优于人工处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的处理过程都有Audit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不易出错&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Autopilot是微软Bing组研发的集群管理系统，至今已有近20年的历史。Autopilot是一个内部模块高度解耦，完善发达的系统，其设计目标是自动化的管理静态集群。自动化的好处有以下几点：</p></div><div class="olist arabic"><ol class="arabic"><li><p>节省人力</p></li><li><p>响应速度和处理时间优于人工处理</p></li><li><p>所有的处理过程都有Audit</p></li><li><p>不易出错</p></li></ol></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>Autopilot的设计依赖于这样一个前提：运行的应用的进程可以在不被预先通知的情况下杀死，而不影响整个系统的稳定性。这一假设是合理的，因为使用的物理机是通用计算机（对比商业高可靠计算机，超级计算机等），其随时有可能发生故障，因此集群管理系统并不能保证在节点失效前对运行的进程进行通知。集群管理系统主要需要考虑以下3个方面：</p></div><div class="olist arabic"><ol class="arabic"><li><p>机器的生命周期管理</p></li><li><p>应用的生命周期管理</p></li><li><p>两者的匹配</p></li></ol></div><div class="sect1"><h2 id="_机器和应用生命周期的匹配">机器和应用生命周期的匹配</h2><div class="sectionbody"><div class="paragraph"><p>Autopilot是一个静态的管理系统，这个静态的最主要体现就是机器和应用的生命周期是静态绑定的。Autopilot首先将机器划分为不同的Machinetype，这决定了这台机器是用于安装那些应用的（纵向切分）；其次将同一Machinetype的机器又划分了Scaleunit，决定了相同用途的机器的管理批次顺序（横向切分）。</p></div><div class="paragraph"><p>有时，机器的生命周期长于应用的生命周期。如果是软件故障，则会通过Reboot，Reimage，Rollback等机制将其恢复正常。如果是应用升级或降级，则按照Machinetype和Scaleunit将受影响的机器分成不同的stage分别按顺序进行操作。如果需要将机器改作它用，则需要重新指定机器的Machinetype和Scale unit。</p></div><div class="paragraph"><p>有时，机器的生命周期短于软件的生命周期。此时通过Replace操作替换物理机。</p></div></div></div><div class="sect1"><h2 id="_系统架构">系统架构</h2><div class="sectionbody"><div class="paragraph"><p>Autopilot的系统架构如下（根据个人对论文的理解加工而成）：</p></div><div class="imageblock"><div class="content"><img data-src="/images/MS_Autopilot_Architecture.png" alt="Microsoft Autopilot Architecture"></div></div><div class="paragraph"><p>集群中的所有节点状态由统一的中心数据库DeviceManager进行记录。这一中心数据库使用Paxos协议实现，提供Linearizability一致性，一般由5-10台机器组成，类似于Zookeeper。集群中的所有组件都依赖于DeviceManager中记录的信息，相互之间不进行直接的交互。这样的设计方式使得组件之间完全解耦，但是对DeviceManager的依赖非常重。</p></div><div class="paragraph"><p>每个节点上由Application Manager进行主要的管理工作：</p></div><div class="olist arabic"><ol class="arabic"><li><p>与Device Manager通信决定应该保留哪些应用的数据</p></li><li><p>通过File Sync Service下载所需的文件</p></li><li><p>将标记为Active的Application启动</p></li></ol></div><div class="paragraph"><p>应用和机器的状态信息通过Watchdog Service收集并记录到DeviceManager中。日志和Performance Counter通过CollectionAgent收集到冷热存储中。</p></div><div class="paragraph"><p>Device Manager是整个集群的核心。Application Manager是每台机器的核心。</p></div></div></div><div class="sect1"><h2 id="_机器的生命周期管理">机器的生命周期管理</h2><div class="sectionbody"><div class="paragraph"><p>这一点是很多软件工程师都不太了解的"神秘领域"，这一点论文中进行了一些细致描述。机器被插入机架后，可以通过每个机架上自带的控制单元进行基本的电源管理，可以远程开关机、重启而无需人工到指定位置进行物理操作。集群中所有的机器都会被ProvisioningService定期检查，以识别其是否是新加入集群的机器，基本运行信息是否正确（如操作系统，BIOS版本等）。如有需要，ProvisioningService会自动重新启动该机器，机器在启动时会进入PXE NetworkBooting，具体使用的PXE image由ProvisioningService决定。在此过程中，首先联系DeviceManager决定该完成何种操作，然后自动化的进行BIOS升级，Reimage等底层操作。</p></div><div class="paragraph"><p>Reimage使用的镜像是定制过的，其中直接包含了最初始的ApplicationManager，File Sync Service，CollectionAgent等基础服务。系统在启动过后，就可以依赖于常规机制进行应用级别的组件升级和替换。</p></div></div></div><div class="sect1"><h2 id="_软件的生命周期管理">软件的生命周期管理</h2><div class="sectionbody"><div class="paragraph"><p>由于Autopilot是由Bing组研发的，在其构建之初就考虑到了在线服务对延迟敏感的特性，因此FileSyncService就很有必要了。系统不提供直接的接口，如SAMBA，FTP，RSYNC，SCP等方式进行文件传输，所有的跨节点运维交互都需要通过FileSync Service，这样的好处有2点：</p></div><div class="olist arabic"><ol class="arabic"><li><p>可以有效的通过限流，QoS等手段避免对在线服务的影响</p></li><li><p>可以使用P2P技术减轻对数据源的压力</p></li></ol></div><div class="paragraph"><p>所有的应用需要提前进行构建操作，构建的结果成为一个manifest。论文中没有直接对其所包含的内容进行描述，但是综合提到的信息进行推断，至少包含以下内容：</p></div><div class="olist arabic"><ol class="arabic"><li><p>应用，数据和配置文件</p></li><li><p>应用描述信息，以确定该应用是一个Always Running的服务，还是一个定期任务</p></li><li><p>以上所有内容的强校验信息，用于传输错误检测和人工修改检测</p></li></ol></div><div class="paragraph"><p>Manifest分为至少2种状态：disabled和enabled。ApplicationManager在与DeviceManager的定期通信中得知其需要保存哪些Manifest以及它们的状态，通过FileSyncService得到所需的Manifest，将disabled状态的应用杀死，将enabled状态的应用启动。ApplicationManager会定期校验Manifest的完整性，并进行纠正。这样做允许同时保留一个应用的多个版本，用于接下来的升级或回滚。校验完整性除了可以克服TCP协议的弱CRC校验和存储错误导致的文件损坏，还可以避免因人工修改导致的配置文件漂移。</p></div><div class="paragraph"><p>系统需要知道机器和应用的状态，从而进行自动修复，这是通过WatchdogService来实现的。WatchdogService可以和应用Cohost，也可以完全部署于其他节点，两者也可以结合使用。使用单独的WatchdogService可以允许用户根据自己应用的逻辑来对应用的状态进行检测，这种检测有时需要以内部的视角观察应用的状态，有时需要以外部的视角（用户的身份）进行观测。用户可以自行制定修复逻辑，否则系统只能进行与应用程序自身逻辑无关的修复工作，即Reboot，Reimage，Replace等操作。</p></div><div class="paragraph"><p>应用程序在运行的过程中，会产生日志和Metric两类信息，这些信息会通过CollectionAgent收集起来，根据热度进入不同的路径，并对接报警系统或查询系统。</p></div><div class="paragraph"><p>应用的部署流程根据论文中的内容推测如下：</p></div><div class="olist arabic"><ol class="arabic"><li><p>用户提交部署请求</p></li><li><p>系统根据请求将应用打包成Manifest</p></li><li><p>Deployment Service将Manifest信息更新到Device Manager中</p></li><li><p>Deployment Service通知Application Manager与Device Manager进行数据同步</p></li><li><p>未能通知到的Application Manager在与DeviceManager的定期同步中会得到最新信息</p></li><li><p>大部分受影响的节点下载了Manifest后开始部署流程</p></li><li><p>Deployment Service按照Machine type和Scaleunit将部署操作分为不同的stage，按照顺序更新Device Manager</p></li><li><p>每个stage在进行部署前，先将受影响的机器状态设置为Probe状态，然后进行更新</p></li><li><p>Stage内有足够多的机器更新成功，并从Probe状态进入Normal状态后，认为该Stage更新成功，否则按照Stage的反顺序进行回滚</p></li></ol></div></div></div><div class="sect1"><h2 id="_其他细节">其他细节</h2><div class="sectionbody"><div class="ulist"><ul><li><p>配置文件的更新也需要走正式的部署流程，这样的好处是配置文件引发的错误也可以被自动检测和修复。类似的，操作系统的更新也是如此。</p></li><li><p>It is vital to keep checksums of all crucial files</p></li><li><p>TCP/IP checksums are weak</p></li><li><p>Computers will spontaneously start running very slowly, but keep making progress</p></li><li><p>Throttling and load shedding are crucial in all aspects of an automated system</p></li><li><p>Failure detectors must be able to distinguish between then symptoms of failure and overloading</p></li></ul></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="autopilot"></a>[1] ISARD M. Autopilot: automatic data center management[J]. ACM SIGOPS Operating Systems Review, 2007, 41(2): 60–67.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Cluster-Management/">Cluster Management</category>
      
      <category domain="http://hcoona.github.io/tags/Microsoft/">Microsoft</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/Microsoft-Autopilot/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CAP，ACID，我们能做什么</title>
      <link>http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/</link>
      <guid>http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/</guid>
      <pubDate>Sun, 20 May 2018 09:56:05 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文从CAP理论和ACID性质为切入点，讨论分布式（存储）系统的设计。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;分布式系统，尤其是分布式存储系统，在进行设计考虑时，首先需要想到的就是CAP问题，即在C（Consistency）和A（Availability）之间如何进行取舍的问题。我在思考的过程中发现，尽管对于Consistency有着诸多分类，如Linearizability、Sequential
Consistency、Causal
Consistency，但是对于Availability却没有一个对应的分类。这有悖于对CAP理论的理解：我们降低了Consistency之后，能得到什么程度的Availability？更进一步的，我们降低了Consistency后，是否真的能够提高Availability？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>本文从CAP理论和ACID性质为切入点，讨论分布式（存储）系统的设计。</p></div><div class="paragraph"><p>分布式系统，尤其是分布式存储系统，在进行设计考虑时，首先需要想到的就是CAP问题，即在C（Consistency）和A（Availability）之间如何进行取舍的问题。我在思考的过程中发现，尽管对于Consistency有着诸多分类，如Linearizability、SequentialConsistency、CausalConsistency，但是对于Availability却没有一个对应的分类。这有悖于对CAP理论的理解：我们降低了Consistency之后，能得到什么程度的Availability？更进一步的，我们降低了Consistency后，是否真的能够提高Availability？</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect1"><h2 id="cap和acid">CAP和ACID</h2><div class="sectionbody"><div class="paragraph"><p>我们之所以需要将一个单机系统扩展到分布式系统，主要原因有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>对性能的要求超过单机系统所能提供的极限</p></li><li><p>对Availability的要求超过单机系统所能提供的极限</p></li></ol></div><div class="paragraph"><p>对于前者，我们可以使用Shard的方式将负载分布到多个单机系统中。对于后者，我们在设计时必须考虑CAP理论的约束。</p></div><div class="sect2"><h3 id="cap">CAP</h3><div class="paragraph"><p>CAP理论的第一个较为正式的形式化表述和证明发表于论文[28]。CAP理论是针对于具有多个Replication的SingleData Object论述的，其模型类似于Distributed SharedMemory。其中P表示Network PartitionTolerance，由于目前一般的网络条件不能认为是可靠的，因此构建在这样的网络上的系统必须认为Partition是可能发生的，进而在CAP理论中不能放弃P而选择C和A，详细的论述见[55]。CAP理论中的C指LinearizabilityConsistency，其具体含义见下文中的Linearizability一节，我们此时先认为其是一种非常强的一致性保证。CAP理论中的A指的是100%的Read&amp; WriteAvailability，非形式化的理解，在任意时刻对任意节点发起的（读或写）请求，无需等待与系统中其他节点通信的结果，即可进行“正确”响应。</p></div><div class="paragraph"><p>由于Partition不是经常发生[11]，在这样的情况下，C和A是可以同时达到的。有趣的是，Google对于网络基础设施的持续改善，使得在他们的网络环境中，由于网络通信导致的问题的概率比由于Bug导致的问题的概率还低，此时甚至可以认为网络是可靠的[17]。但是在Partition发生时，我们必须在LinearizabilityConsistency和100% Availability之间进行取舍。</p></div><div class="paragraph"><p>这样一来，就有一个关键的问题：如何判断是否正在发生NetworkPartition？实践中我们通常采用消息超时的机制进行判断，即如果两个节点之间的通信（即便经过一些重试）超时，则认为此时正在发生NetworkPartition。使用这种方法进行判断，我们会发现Latency和Availability是一回事。Latency低的时候，节点之间可以正常通信，从而提供LinearizabilityConsistency。Latency高的时候，我们认为发生了NetworkPartition，或者等待Latency降低到足以在Threshold内进行通信（NetworkPartition解除），即放弃100% Availability但是保证LinearizabilityConsistency，或者放弃节点间进行通信直接进行响应，即放弃保证LinearizabilityConsistency但是提供100%Availability。目前越来越多的系统即使在P没有发生时，也不提供LinearizabilityConsistency，其这样做是为了提供更高的性能保证。也就是说，在P发生时，我们在C和A之间进行取舍；在P没有发生时，我们在C和L（Latency）之间进行取舍。这样，CAP理论被扩展为PACELC理论（Ifthere is a Partition, how does the system trade off Availability andConsistency; Else, when the system is running normally in the absence ofpartitions, how does the system trade off Latency andConsistency?），见[1]。</p></div><div class="paragraph"><p>进一步考虑，我们之所以需要在C和A之间进行取舍，或者是在C和L之间进行取舍，其根本原因在于节点之间需要进行<strong>同步通信</strong>才能够保证C。极端情况下，我们可以使得整个系统无需进行同步通信，来达到极致的A和L。此时考虑一个写请求，在写入一个节点并收到成功确认后，如果该节点在和其他节点进行<strong>异步通信</strong>之前就发生了永久性故障，则这一写请求写入的内容将永久性的丢失。这说明Consistency和Durability在某种程度上是类似的[43]。</p></div><div class="paragraph"><p>从一个更大的角度来看，在一个不可靠的分布式系统中，我们需要在Safety性质和Liveness性质之间进行取舍[29]。例如，Consistency是一种Safety性质，而Availability是一种Liveness性质。又例如，FLP问题[27]告诉我们在Consensus问题中如果有任意节点不可靠，则无法在保证Safety性质的同时保证Liveness性质。有关分布式系统中的Impossibility的重要问题有[15,27, 28, 46]。</p></div><div class="paragraph"><p>Paxos算法可以容忍系统中少数集合中的节点失效，直觉上，我们认为Paxos算法在系统级别提供高可用服务，同时提供了LinearizabilityConsistency。这似乎与CAP理论相违背。考虑CAP理论对于Availability的定义，要求对任意节点的请求都能立刻（read-time）得到回应。假设由于网络分区将系统分为了一个多数集和一个少数集，对于Paxos算法，尽管多数集中的节点仍然可以正确且立即回复请求，但是少数集中的节点不能。CAP理论这样定义有一定道理，因为在网络分区发生时，有可能客户端并不能访问多数集中的节点。</p></div><div class="paragraph"><p>[37]提出了对CAP理论的一些批评和改进。考虑这样一个事实，Availability是服务的一个观测结果（Metric）而非系统的一个属性，而Consistency和Partition是系统模型，这两者并不能统一起来，CAP理论中对于Availability的定义是不严格的。Brewer在[16]中（非形式化的）提出，Availability和Consistency在CAP理论中并不是一个非0即1的离散变量，而是从0%至100%连续变化的变量。这与[28]中形式化描述CAP理论的工作是相违背的。这意味着我们有必要重新思考CAP理论的精确定义（形式化描述）。[37]中将CAP中的A定义为算法对Latency的敏感程度，将C定义为算法所使用的并发一致性模型，将P定义为Latency的突发增长。这样一来，A不再是对服务的一个观测结果，而是算法的一个本质属性；P的定义也能和A相结合。在这样一种框架下，最终一致性模型也能很好的进行建模和推理，最终得出结论，最终一致性的Replica算法在Partition永久性的发生时仍然能够停机。这与我们的直觉，使用最终一致性协议可以提高Availability一致。文中还进一步总结了达成三种一致性模型所需时间的下界（不确定是否是下确界），假设消息传播时间为\(d\)，见下表：</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width: 33.3333%;"><col style="width: 33.3333%;"><col style="width: 33.3334%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Consistency Level</th><th class="tableblock halign-left valign-top">Write latency</th><th class="tableblock halign-left valign-top">Read latency</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Linearizability</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">\(\mathcal&#123;O&#125;(d)\)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">\(\mathcal&#123;O&#125;(d)\)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Sequential Consistency</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">\(\mathcal&#123;O&#125;(d)\)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">\(\mathcal&#123;O&#125;(1)\)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Causal Consistency</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">\(\mathcal&#123;O&#125;(1)\)</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">\(\mathcal&#123;O&#125;(1)\)</p></td></tr></tbody></table><div class="paragraph"><p>其中Sequential Consistency的读写延迟可以互换。</p></div></div><div class="sect2"><h3 id="acid">ACID</h3><div class="paragraph"><p>ACID性质指的是并行执行多个事务（Transaction）时需要保证的性质[33]：</p></div><div class="ulist"><ul><li><p>TransactionAtomicity：组成事务的多个事件（Event）要么都成功要么都失败（all-or-nothing）</p></li><li><p>DatabaseConsistency：执行事务的前后，数据库的状态保持（应用程序层面）一致</p></li><li><p>Isolation：并发执行的事务之间不互相影响</p></li><li><p>Durability：已经提交的事务中的事件不会丢失</p></li></ul></div><div class="paragraph"><p>ACID中的Atomicity和ConcurrentProgramming领域中的Atomicity意义完全不同，为了区分这一点我将ACID中的A称为TransactionAtomicity。同样的，ACID中的Consistency和ConcurrentProgramming领域中的Consistency也完全不同，但是ACID中的Isolation和ConcurrentProgramming领域中的Consistency有一定相关性。这里将ACID中的Consistency称为DatabaseConsistency是因为ACID中的A、I、D是更底层的性质，而C是上层应用的性质，具体见[38]中的第7章。</p></div></div><div class="sect2"><h3 id="different-between-cap-acid">两者区别</h3><div class="paragraph"><p>CAP理论更多的关注于分布式共享内存模型下对象的一致性问题和可用性问题，是传统ConcurrentProgramming领域在不可靠系统下的问题。传统Consistency的分类在[51]中有一个总结，其中比较常见的几种一致性模型从弱到强如下：</p></div><div class="ulist"><ul><li><p>Read-your-writes/Monotonic Reads/Monotonic Writes</p></li><li><p>PRAM（即FIFO，等于上面三者的和）</p></li><li><p>Causal（等于PRAM和Writes-follow-reads）</p></li><li><p>Sequential</p></li><li><p>Linearizability</p></li></ul></div><div class="paragraph"><p>ACID性质是数据库系统中并发执行多个事务时的问题，是数据库领域的传统问题。ACID性质中的Isolation从弱到强有以下几个常见级别[12]：</p></div><div class="ulist"><ul><li><p>Read Uncommitted</p></li><li><p>Read Committed</p></li><li><p>Cursor Stability</p></li><li><p>Repeatable Read</p></li><li><p>Snapshot Isolation</p></li><li><p>Serializable</p></li></ul></div></div></div></div><div class="sect1"><h2 id="linearizability-vs-serializability">Linearizability和Serializability</h2><div class="sectionbody"><div class="paragraph"><p>Linearizability是ConcurrentProgramming中Consistency的最终目标，Serializability是数据库事务中Isolation的最终目标，两者均在分布式存储系统中起到了重要的作用。</p></div><div class="sect2"><h3 id="linearizability">Linearizability</h3><div class="paragraph"><p>Linearizability是在具有多个副本的单个对象的情况下，对于并发操作的执行顺序约束。也可以认为是在给定的并发操作历史下，对于单个操作返回结果的约束。</p></div><div class="paragraph"><p>Linearizability的原始论文为[35]，但是个人认为[45]的第16章更容易理解，此外[38]的第9章也给出了Linearizability的非形式化解释。</p></div><div class="paragraph"><p>Linearizability的形式化定义如下[35]：</p></div><div class="paragraph"><p>A history \(H\) induces an irreflexive partial order\(&lt;_&#123;H&#125;\) on operations:</p></div><div class="stemblock"><div class="content">\[e_&#123;0&#125; &lt;_&#123;H&#125;e_&#123;1&#125;\ \text&#123;if&#125;\ res(e_&#123;0&#125;)\ \text&#123;precedes&#125;\ inv(e_&#123;1&#125;)\ \text&#123;in&#125;\ H\]</div></div><div class="paragraph"><p>A history \(H\) is <em>linearizable</em> if it can be extended (byappending zero or more response events) to some history \(H'\)such that:</p></div><div class="ulist"><ul><li><p>\(complete(H')\) is equivalent to some legal sequentialhistory \(S\)</p></li><li><p>\(&lt;_&#123;H&#125; \subseteq &lt;_&#123;S&#125;\)</p></li></ul></div><div class="paragraph"><p>直觉上理解，Linearizability执行的结果，等价于按照真实时间顺序，依次（非并发的）执行这些事件（Event，在此理解为读或写操作）。</p></div></div><div class="sect2"><h3 id="serializability">Serializability</h3><div class="paragraph"><p>Serializability是数据库事务并发执行的约束。一个数据库事务由涉及到多个对象（也可以只是一个对象）的多个操作（也可以只是一个）组成。Serializability要求这些事务执行的结果，等价于这些事务依次（非并发的）执行的结果。值得注意的是，Serializability并没有对这些事务的执行顺序做出约束。</p></div><div class="paragraph"><p>Serializability的具体描述见[13]的第2章。</p></div></div><div class="sect2"><h3 id="different-between-linearizability-and-serializability">两者区别</h3><div class="paragraph"><p>Linearizability主要应用于分布式共享内存模型下，对于单个对象的单个操作返回什么样的值合法做出限制。Linearizability是一种对Recency的限制，要求历史上并行操作的执行顺序必须反映他们的Real-Time顺序。此处Real-Time指的并非实时系统领域的Real-Time，而是对应于全局时钟而言的真实时间这一概念。</p></div><div class="paragraph"><p>Serializability是数据库事务并行执行时的Isolation要求，其约束了并行事务执行的结果等价于这些事务“一条接一条”的执行的结果，但是没有限定这些并行事务的执行顺序。数据库事务通常涉及对多个对象的多个操作。</p></div><div class="paragraph"><p>Serializability和Linearizability结合称为Strict Serializability或One-copySerializability。</p></div><div class="paragraph"><p>对于两者的比较也可以参考[39]。</p></div></div></div></div><div class="sect1"><h2 id="what-can-we-do">我们能做什么</h2><div class="sectionbody"><div class="paragraph"><p>理清了CAP理论和ACID，我们来考虑一下分布式系统设计中能做到什么，以及如何进行取舍：</p></div><div class="olist arabic"><ol class="arabic"><li><p>在满足传统数据库的强一致性约束下，我们能做到多高的可用性，以及多低的延迟？</p></li><li><p>在满足100% Read Write Availability的约束下，我们能做到多高的一致性？</p></li><li><p>在这两者之间还存在什么？</p></li></ol></div><div class="paragraph"><p>对于这些问题，我们总是从最简单的模型入手，即多副本的Key-ValueStore开始，然后再考虑如何加上分布式事务。当然对于一个分布式数据库而言，我们至少还应该有SecondaryIndex，Data Constraint Check，等等功能，但是不在本文中进行进一步展开。</p></div><div class="sect2"><h3 id="strong-consistency-system-design">强一致性约束下的分布式系统</h3><div class="paragraph"><p>我们的目标是实现一个Linearizability Consistency的Key-ValueStore，同时支持Serializability Isolation Level的分布式事务。</p></div><div class="sect3"><h4 id="linearizability-consistency-implementation">Linearizability Consistency的实现方法</h4><div class="paragraph"><p>我们的目标是实现一个Linearizability Consistency的Key-ValueStore。由于Linearizability具有LocalProperty，我们可以将问题进一步简化。首先我们考虑如何实现一个AtomicRead/Write Register。更具体的，应该是MRMW Atomic Register（Multi-ReaderMulti-Writer Atomic Register）。</p></div><div class="paragraph"><p>[38]的P333对于Replication方式是否能实现Linearizability有一个总结：</p></div><div class="ulist"><ul><li><p>Single-leader replication (potentially linearizable)</p></li><li><p>Consensus algorithms (linearizable)</p></li><li><p>Multi-leader replication (not linearizable)</p></li><li><p>Leaderless replication (probably not linearizable)</p></li></ul></div><div class="paragraph"><p>[45]的第16章第4节对于如何实现Linearizability也有一个总结：</p></div><div class="ulist"><ul><li><p>Atomicity Based on a Total Order Broadcast Abstraction</p></li><li><p>Atomicity of Read/Write Objects Based on Server Processes</p><div class="ulist"><ul><li><p>Atomicity Based on a Server Process and Copy Invalidation</p></li><li><p>Atomicity Based on a Server Process and Copy Update</p></li></ul></div></li></ul></div><div class="paragraph"><p>总的来说，分为这样几种思路：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Total Order Broadcast</p></li><li><p>Quorum read/write</p></li><li><p>Write-invalidate &amp; Read-through</p></li><li><p>Write-through</p></li></ol></div><div class="paragraph"><p>Total OrderBroadcast保证每个replication以相同的顺序接收到全序排列的消息，显然，这符合LinearizabilityConsistency的定义。使用Consensus算法，例如Raft、ZAB等，相当于先在Leader节点上定序，然后再将消息和这一顺序本身传播给所有的replication，实际上等同于TotalOrder Broadcast。关于Total Order Broadcast的分类和实现方法见[23]。</p></div><div class="paragraph"><p>使用Quorum方式实现Linearizability，需要在每次Read/Write操作的之前都进行一次Repair，见[38]的P334，[20]的第4章，以及[4]。需要注意的是，只有Read/Write操作能够以这种方式实现，Compare-And-Set之类的操作不能以这种形式实现，而必须使用分布式共识（Consensus）算法，具体见[34]的Fig1。</p></div><div class="paragraph"><p>Read-through和Write-through的方式主要适用于Cache场景，在分布式存储场景下使用这样的方法有较大的丢失数据的风险。</p></div><div class="paragraph"><p>达成Linearizability的代价为Client到Leader的延迟加上Leader到多数集中最慢的节点的延迟。</p></div></div><div class="sect3"><h4 id="serializability-isolation-transaction-implementation">Serializability Isolation事务的实现方法</h4><div class="paragraph"><p>在已经有了分布式Key-ValueStore的情况下，我们接下来的目标是实现一个Serializability IsolationLevel的分布式事务。</p></div><div class="paragraph"><p>在单机数据库系统中实现Serializability IsolationLevel事务的方法（按照Scalability从弱到强）主要有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>真实（单线程）Serialize执行</p></li><li><p>Strict 2 Phase Locking</p></li><li><p>Serializable Snapshot Isolation Algorithm</p></li></ol></div><div class="paragraph"><p>其中，Serialize execute和Strict 2PL（Strict 2 PhaseLocking）属于悲观并发，SSI（Serializable SnapshotIsolation）属于乐观并发。SSI的原理大致是使用SnapshotIsolation但是在提交前检查是否有已知的写操作与当前事务的读操作在Serializability语义下冲突，如果有的话就Abort，没有的话就可以Commit并且保证Serializability了[21]。</p></div><div class="paragraph"><p>实现分布式事务所需要解决的主要问题是AtomicCommitment，即多个节点all-or-nothing的决议commit或abort一个transaction的问题。AtomicCommitment分为Blocking和Non-blocking两种。Blocking AtomicCommitment问题可以转化为Consensus问题[31]。Blocking AtomicCommitment的一个典型的实现方法是2 Phase Commit，但是我觉得应该使用PaxosCommit Algorithm[31]。Non-blocking AtomicCommitment问题严格的比Consensus问题难[32]，一个典型的实现方法是3PC（3PhaseCommit），但是由于3PC不能在节点失效时保证正确性，所以几乎没有人在实际环境中使用3PC。</p></div><div class="paragraph"><p>对于一个LinearizabilityConsistency的系统，我们无需关注每个Shard的多个副本（Replication）之间的一致性，因此对于没有跨越Shard的事务的实现方法和单机数据库事务的实现方法一致。对于跨越Shard的事务的实现方法，一个可行的方案是使用PaxosCommit Algorithm协调多个Shard，每个Shard使用Strict2PL。除了需要额外的外部组件记录整个系统中事务和锁的关系以便进行死锁检测和处理，这个方案基本上和传统数据库的事务处理一致。SSI的实现需要解决一个重要问题，即如何跨越Shard生成一致的Snapshot。关于这方面我的经验不多，希望能在以后阅读了[26,36, 48, 49, 53]后在补完这一部分内容（也有可能挖坑不埋）。</p></div></div><div class="sect3"><h4 id="problems-with-strong-consistency-system">强一致性系统的问题</h4><div class="paragraph"><p>LinearizabilityConsistency虽然使得我们可以像是对待只有一份副本系统一样使用这一系统，但是代价不仅是算法的NetworkLatency Sensitive，还有Scalability下降。对于一个LinearizabilityConsistency的系统，不能够通过增加副本来提高系统的性能。LinearizabilityConsistency代价非常高，即便是多核CPU也没有使用LinearizabilityConsistency[47]。因此，我们应该只在必要的时候提供LinearizabilityConsistency，例如使用额外的系统（Zookeeper）。</p></div><div class="paragraph"><p>Strict2PL的并发度也比较低，带来的问题是事务处理的性能低。SSI的并发度尽管比Strict2PL要高，但是在高并发场景下Abort的概率也比较高。</p></div></div></div><div class="sect2"><h3 id="high-availability-system-design">高可用性约束下的分布式系统</h3><div class="paragraph"><p>从[3, 37]中总结的结论，若想实现一个100% Read &amp; WriteAvailable的系统（或者说，读写操作的时间复杂度不受节点间通信网络延迟的影响），最高只能支持CausalConsistency。特别的，考虑到VersionVector的大小，甚至可能不支持完全的Causal Consistency。另一方面，从[8]中的结论来看，对于分布式事务的支持最高也只能达到RC（ReadCommitted），MAV（Monotonic Atomic View）或P-CI（Predicate CutIsolation）。</p></div><div class="paragraph"><p>这里故意避开了EventualConsistency的概念，因为目前还没有统一的对于EventualConsistency的形式化的定义，分歧主要集中在How Eventual和WhatConsistency两方面。[19, 51]中通过将LinearizabilityConsistency中的全序关系扩展到偏序关系，并且分解为Visible和Arbitration两个维度，来统一的描述多种Consistency。特别的，只出现在Arbitration关系中，但是没有出现在Visible关系中的事件相当于丢失了或被覆盖了。</p></div><div class="paragraph"><p>CausalConsistency对于很多场景都具有很高的价值。例如在社交网络中，A说自己的小孩走丢了（a1），A又发消息说小孩找到了（a2），B评论说太好了（b）。如果此时C只能看到消息a1和b，就会产生问题。从CausalRelation上看，a1&#8594;a2&#8594;b，一个Eventual Consistency的系统不提供CausalRelation的保证，但是Causal Consistency必须保证这一点。</p></div><div class="paragraph"><p>尽管如此，目前主流的NoSQL只实现了EventualConsistency[22]。这是因为实现一个通用的CausalConsistency的代价比较高，例如某个Client先读取大量的数据然后进行了一次写入，一个通用的系统不能知道这个写入只是Causal依赖其中的哪些读取操作，进而必须捕获所有的读取操作。即便是让用户显式指定其写操作依赖于哪些读操作，还需要考虑CausalRelation的传递性（transitive），即读操作又依赖于那些读操作，等等。</p></div><div class="sect3"><h4 id="causal-consistency-implementation">Causal Consistency的实现方法</h4><div class="paragraph"><p>Single Object（或者说Per-Key）的CausalConsistency是容易实现的，使用MVCC等技术可以同时存储对象的多个版本，在写入时只需指定其依赖于哪一个版本，即可实现SingleObject的Causal Consistency。需要注意的是，为了维持Session LevelGuarantees，需要在Session维持期间只与同一个副本进行通信。个人认为，一般情况下，系统应该提供SingleObject的Causal Consistency，这一负担并不重。</p></div><div class="paragraph"><p>可惜的是，不像Linearizability Consistency，CausalConsistency不具有Locality性质。即使实现了Single Object的CausalConsistency，也不能使得整个系统能够满足Causal Consistency。</p></div><div class="paragraph"><p>目前，如何实现Causal Consistency是学术上的一个热点[2, 6, 22, 24, 25,40–42, 54]，一方面因为Causal Consistency是维持100%Availability情况下所能支持的最高的一致性级别，另一方面是因为EventualConsistency提供的保证实在是太少了[10, 30]。</p></div></div><div class="sect3"><h4 id="highly-available-transaction-implementation">高可用分布式事务的实现方法</h4><div class="paragraph"><p>尽管[8]指出，在保证高可用的情况下，分布式事务最高能支持RC（ReadCommitted），MAV（Monotonic Atomic View）或P-CI（Predicate CutIsolation），但是在其中并没有指出可以使用什么样的算法来做到这一点。特别的，[8]指出他们之所以写这篇论文，就是因为尽管很多算法实现了这些分布式事务，但是并没有支持高可用，很多系统虽然宣称自己是高可用的，但是用了这些不是高可用的算法后，也就不是严格意义上的高可用系统。</p></div><div class="paragraph"><p>[18]提出了一种无需Coordinator的分布式事务的实现方法，[7]对CoordinationAvoidance进行了进一步的论述。Eiger系统分别提供了低延迟的只读事务和只写事务[41]，但是仍然需要进一步的仔细检查，才能知道其是否是高可用的。Anna系统号称实现了ReadCommitted级别的跨越Shard的分布式事务[54]，但是没有披露更多的技术细节。其作者还发布过RAMP事务[9]，提供了低延迟的ReadAtomicIsolation分布式事务。总的来说，高可用的分布式事务的实现还是一个开放问题。</p></div></div><div class="sect3"><h4 id="further-about-high-availability-system-design">其他</h4><div class="paragraph"><p>[7]对什么样的约束检查需要进行Coordination进行了形式化的论述。总的来说，无需Coordination的约束检查只能检查具有Locality性质的约束，而不能检查全局约束（例如非负计数器，自增主键等等）。</p></div><div class="paragraph"><p>目前仍需探索的一个方向是如何在不同级别的Consistency和IsolationLevel之间切换[50]。</p></div></div></div></div></div><div class="sect1"><h2 id="recommend-readings">Recommend Readings</h2><div class="sectionbody"><div class="paragraph"><p>在撰写本文时，我阅读了大量的相关资料，在此给出一个文献的建议阅读顺序。</p></div><div class="paragraph"><p>首先应该阅读[38]中的第5章、第7章和第9章，这些章节分别介绍了Replication的方法，数据库事务，Consistency和Consensus及它们之间的关系。这使得读者对于CAP理论，数据库事务，ConcurrentProgramming中的一致性模型，分布式系统的共识问题，有一个初步的理解。</p></div><div class="paragraph"><p>然后建议阅读[22]，对当前流行的NoSQL系统有一个初步的认识。</p></div><div class="paragraph"><p>对于CAP理论相关的文献，建议首先阅读[28]，对于普遍认识中的CAP理论有非形式化和形式化的定义和证明。然后强烈建议阅读[37]，其作者也是[38]的作者，在这篇论文中提出了对CAP理论现有工作的一些批评和改进，这些批评和改进非常具有启发性和实用性。然后可以在以下列表中挑选感兴趣的内容阅读：</p></div><div class="ulist"><ul><li><p>[16]为CAP理论的提出者Brewer在12年后对CAP理论的回顾和补充</p></li><li><p>[1]这篇论文将CAP理论扩展为PACELC理论，将Latency纳入对Availability的解释中</p></li><li><p>[29]这篇论文将CAP理论扩展为Safety性质和Liveness性质的Impossibility问题</p></li><li><p>[55]解释了在CAP理论中P是不可舍弃的（应该作为算法设计模型的一部分），这一问题在[37]中也略有涉及</p></li><li><p>[51]对于Consistency进行了非常详尽的形式化的总结，但是强烈建议先看完[19]再看这个，因为其描述方法是沿用[19]中的方式，否则容易看不懂</p></li><li><p>[52]对Eventual Consistency有一个简略的介绍和总结</p></li><li><p>[30]对于Eventual Consistency的Eventual有一个略微深入的展开</p></li><li><p>[19]是一个对Eventual Consistency非常详尽和形式化的总结</p></li></ul></div><div class="paragraph"><p>关于LinearizabilityConsistency，建议阅读[45]的第16章，其原始论文为[35]，关于其性能的一些讨论可以在[5]中找到。关于EventualConsistency，建议阅读[10, 14, 52]，关于其一些形式化的描述，建议阅读[19,51]。</p></div><div class="paragraph"><p>关于Serializability建议阅读[13]的第2章。</p></div><div class="paragraph"><p>关于Concurrent Programming中的Consistency，建议阅读</p></div><div class="paragraph"><p>对于（单机）数据库事务，建议阅读[38]的第7章。关于Serializable SnapshotIsolation，见[21, 44]。关于实现单机数据库事务的新方法，见[53]。</p></div><div class="paragraph"><p>分布式事务的一致性和分布式共识问题有很强的相关性，建议阅读[38]中的第9章，以及Lamport写的[31]。关于Non-blockingAtomic Commitment，建议阅读[32]。</p></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="paragraph"><p>[1] Abadi, D. 2012. Consistency Tradeoffs in Modern Distributed DatabaseSystem Design: CAP is Only Part of the Story. <em>Computer</em>. 45, 2 (2012),37–42. DOI:https://doi.org/10.1109/MC.2012.33.</p></div><div class="paragraph"><p>[2] Akkoorath, D.D. et al. 2016. Cure: Strong Semantics Meets HighAvailability and Low Latency. <em>2016 IEEE 36th International Conferenceon Distributed Computing Systems (ICDCS)</em> (Jun. 2016), 405–414.</p></div><div class="paragraph"><p>[3] Attiya, H. et al. 2017. Limitations of Highly-AvailableEventually-Consistent Data Stores. <em>IEEE Transactions on Parallel andDistributed Systems</em>. 28, 1 (2017), 141–155.DOI:https://doi.org/10.1109/TPDS.2016.2556669.</p></div><div class="paragraph"><p>[4] Attiya, H. et al. 1995. Sharing memory robustly in message-passingsystems. <em>Journal of the ACM</em>. 42, 1 (1995), 124–142.DOI:https://doi.org/10.1145/200836.200869.</p></div><div class="paragraph"><p>[5] Attiya, H. and Welch, J.L. 1994. Sequential consistency versuslinearizability. <em>ACM Transactions on Computer Systems</em>. 12, 2 (1994),91–122. DOI:https://doi.org/10.1145/176575.176576.</p></div><div class="paragraph"><p>[6] Bailis, P. et al. 2013. Bolt-on causal consistency. <em>Proceedings ofthe 2013 international conference on Management of data - SIGMOD ’13</em>.(2013), 761. DOI:https://doi.org/10.1145/2463676.2465279.</p></div><div class="paragraph"><p>[7] Bailis, P. et al. 2015. Coordination Avoidance in Database Systems.<em>Pvldb</em>. 8, 4 (2015), 185–196. DOI:https://doi.org/1402.2237v2.</p></div><div class="paragraph"><p>[8] Bailis, P. et al. 2013. Highly Available Transactions: Virtues andLimitations. <em>Proceedings of the VLDB Endowment</em>. 7, 3 (2013), 181–192.DOI:https://doi.org/10.14778/2732232.2732237.</p></div><div class="paragraph"><p>[9] Bailis, P. et al. 2014. Scalable atomic visibility with RAMPtransactions. <em>Proceedings of the 2014 ACM SIGMOD internationalconference on Management of data - SIGMOD ’14</em>. (2014), 27–38.DOI:https://doi.org/10.1145/2588555.2588562.</p></div><div class="paragraph"><p>[10] Bailis, P. and Ghodsi, A. 2013. Eventual consistency today.<em>Communications of the ACM</em>. 56, 5 (2013), 55.DOI:https://doi.org/10.1145/2447976.2447992.</p></div><div class="paragraph"><p>[11] Bailis, P. and Kingsbury, K. 2014. The Network is Reliable.<em>Queue</em>. 12, 7 (2014), 20:20-20:32.DOI:https://doi.org/10.1145/2639988.2639988.</p></div><div class="paragraph"><p>[12] Berenson, H. et al. 1995. A critique of ANSI SQL isolation levels.<em>ACM SIGMOD Record</em>. 24, 2 (1995), 1–10.DOI:https://doi.org/10.1145/568271.223785.</p></div><div class="paragraph"><p>[13] Bernstein, P.A. et al. 1987. <em>Concurrency Control and Recovery inDatabase Systems</em>. Addison-Wesley Pub. Co.</p></div><div class="paragraph"><p>[14] Bernstein, P.A. and Das, S. 2013. Rethinking eventual consistency.<em>Proceedings of the 2013 international conference on Management of data- SIGMOD ’13</em>. (2013), 923. DOI:https://doi.org/10.1145/2463676.2465339.</p></div><div class="paragraph"><p>[15] Borowsky, E. and Gafni, E. 1993. Generalized FLP impossibilityresult for <em>t</em>-resilient asynchronous computations. <em>Proceedings of thetwenty-fifth annual ACM symposium on Theory of computing - STOC ’93</em>. 5,(1993), 91–100. DOI:https://doi.org/10.1145/167088.167119.</p></div><div class="paragraph"><p>[16] Brewer, E. 2012. CAP twelve years later: How the “rules” havechanged. <em>Computer</em>. 45, 2 (2012), 23–29.DOI:https://doi.org/10.1109/MC.2012.37.</p></div><div class="paragraph"><p>[17] Brewer, E. 2017. Spanner, TrueTime &amp; The CAP Theorem. <em>WhitePapers</em>. 2015, 4/4/2015 (2017), 1–7.</p></div><div class="paragraph"><p>[18] Burckhardt, S. et al. 2012. Eventually Consistent Transactions.<em>Proceedings of the 22n European Symposium on Programming (ESOP)</em>.Springer. 67–86.</p></div><div class="paragraph"><p>[19] Burckhardt, S. 2014. Principles of Eventual Consistency.<em>Foundations and Trends® in Programming Languages</em>. 1, 1–2 (2014),1–150. DOI:https://doi.org/10.1561/2500000011.</p></div><div class="paragraph"><p>[20] Cachin, C. et al. 2011. <em>Introduction to reliable and securedistributed programming</em>. Springer.</p></div><div class="paragraph"><p>[21] Cahill, M.J. et al. 2009. Serializable isolation for snapshotdatabases. <em>ACM Transactions on Database Systems</em>. 34, 4 (Dec. 2009),1–42. DOI:https://doi.org/10.1145/1620585.1620587.</p></div><div class="paragraph"><p>[22] Davoudian, A. et al. 2018. A Survey on NoSQL Stores. <em>ACM ComputingSurveys</em>. 51, 2 (Apr. 2018), 1–43. DOI:https://doi.org/10.1145/3158661.</p></div><div class="paragraph"><p>[23] Défago, X. et al. 2004. Total order broadcast and multicastalgorithms: Taxonomy and Survey. <em>ACM Computing Surveys</em>. 36, 4 (Dec.2004), 372–421. DOI:https://doi.org/10.1145/1041680.1041682.</p></div><div class="paragraph"><p>[24] Didona, D. et al. 2017. Okapi: Causally Consistent Geo-ReplicationMade Faster, Cheaper and More Available. (Feb. 2017).</p></div><div class="paragraph"><p>[25] Du, J. et al. 2014. GentleRain : Cheap and Scalable CausalConsistency with Physical Clocks. <em>SOCC ’14 Proceedings of the ACMSymposium on Cloud Computing</em>. (2014), 1–13.DOI:https://doi.org/10.1145/2670979.2670983.</p></div><div class="paragraph"><p>[26] Dutta, P. et al. 2005. How fast can eventual synchrony lead toconsensus? <em>Proceedings of the International Conference on DependableSystems and Networks</em>. March (2005), 22–27.DOI:https://doi.org/10.1109/DSN.2005.54.</p></div><div class="paragraph"><p>[27] Fischer, M.J. et al. 1983. Impossibility of distributed consensuswith one faulty process. <em>Proceedings of the 2nd ACM SIGACT-SIGMODsymposium on Principles of database systems - PODS ’83</em> (New York, NewYork, USA, Apr. 1983), 1–7.</p></div><div class="paragraph"><p>[28] Gilbert, S. and Lynch, N. 2002. Brewer’s conjecture and thefeasibility of consistent, available, partition-tolerant web services.<em>ACM SIGACT News</em>. 33, 2 (2002), 51.DOI:https://doi.org/10.1145/564585.564601.</p></div><div class="paragraph"><p>[29] Gilbert, S. and Lynch, N. 2012. Perspectives on the CAP Theorem.<em>Computer</em>. 45, 2 (2012), 30–36.DOI:https://doi.org/10.1109/MC.2011.389.</p></div><div class="paragraph"><p>[30] Golab, W. et al. 2014. Eventually consistent: not what you wereexpecting? <em>Communications of the ACM</em>. 57, 3 (2014), 38–44.DOI:https://doi.org/10.1145/ 2576794.</p></div><div class="paragraph"><p>[31] Gray, J. and Lamport, L. 2004. Consensus on Transaction Commit. 1,April 2004 (2004). DOI:https://doi.org/10.1145/1132863.1132867.</p></div><div class="paragraph"><p>[32] Guerraoui, R. 1995. Revisiting the relationship betweennon-blocking atomic commitment and consensus. <em>Distributed Algorithms</em>(1995), 87–100.</p></div><div class="paragraph"><p>[33] Haerder, T. and Reuter, A. 1983. Principles of transaction-orienteddatabase recovery. <em>ACM Computing Surveys</em>. 15, 4 (1983), 287–317.DOI:https://doi.org/10.1145/289.291.</p></div><div class="paragraph"><p>[34] Herlihy, M. 1991. Wait-free synchronization. <em>ACM Transactions onProgramming Languages and Systems</em>. 13, 1 (1991), 124–149.DOI:https://doi.org/10.1145/114005.102808.</p></div><div class="paragraph"><p>[35] Herlihy, M.P. and Wing, J.M. 1990. Linearizability: a correctnesscondition for concurrent objects. <em>ACM Transactions on ProgrammingLanguages and Systems</em>. 12, 3 (Jul. 1990), 463–492.DOI:https://doi.org/10.1145/78969.78972.</p></div><div class="paragraph"><p>[36] Jung, H. et al. 2011. Serializable Snapshot Isolation forReplicated Databases in High-Update Scenarios. <em>PVLDB</em>. 4, 11 (2011),783–794.</p></div><div class="paragraph"><p>[37] Kleppmann, M. 2015. A Critique of the CAP Theorem. (2015).</p></div><div class="paragraph"><p>[38] Kleppmann, M. 2017. <em>Designing data-intensive applications</em>.O’Reilly Media, Inc.</p></div><div class="paragraph"><p>[39] Linearizability versus Serializability: 2014.<em><a href="http://www.bailis.org/blog/linearizability-versus-serializability/" class="bare">http://www.bailis.org/blog/linearizability-versus-serializability/</a></em>.Accessed: 2018-05-08.</p></div><div class="paragraph"><p>[40] Lloyd, W. et al. 2011. Don’t Settle for Eventual: Scalable CausalConsistency for Wide-Area Storage with COPS. <em>Proceedings of theSymposium on Operating Systems Principles</em>. (2011), 1–16.DOI:https://doi.org/10.1145/2043556.2043593.</p></div><div class="paragraph"><p>[41] Lloyd, W. et al. 2013. Stronger Semantics for Low-LatencyGeo-Replicated Storage. <em>Proceedings of the Symposium on NetworkedSystems Design and Implementation</em>. April (2013), 313–328.DOI:https://doi.org/10.1145/2602649.2610533.</p></div><div class="paragraph"><p>[42] Mehdi, S.A. et al. 2017. I Can’t Believe It’s Not Causal! ScalableCausal Consistency with No Slowdown Cascades. <em>14th &#123;USENIX&#125; Symposiumon Networked Systems Design and Implementation, &#123;NSDI&#125; 2017, Boston,MA, USA, March 27-29, 2017</em>. (2017), 453–468.</p></div><div class="paragraph"><p>[43] On Consistency and Durability:<em><a href="http://www.bailis.org/blog/on-consistency-and-durability/" class="bare">http://www.bailis.org/blog/on-consistency-and-durability/</a></em>. Accessed:2018-05-08.</p></div><div class="paragraph"><p>[44] Ports, D.R.K. and Grittner, K. 2012. Serializable snapshotisolation in PostgreSQL. <em>Proceedings of the VLDB Endowment</em>. 5, 12(Aug. 2012), 1850–1861. DOI:https://doi.org/10.14778/2367502.2367523.</p></div><div class="paragraph"><p>[45] Raynal, M. 2013. <em>Distributed Algorithms for Message-PassingSystems</em>. Springer, Berlin, Heidelberg.</p></div><div class="paragraph"><p>[46] Saks, M. and Zaharoglou, F. 1993. Wait-free k-set agreement isimpossible. <em>Proceedings of the twenty-fifth annual ACM symposium onTheory of computing - STOC ’93</em>. (1993), 101–110.DOI:https://doi.org/10.1145/167088.167122.</p></div><div class="paragraph"><p>[47] Sewell, P. et al. 2010. X86-TSO: A Rigorous and Usable Programmer’sModel for x86 Multiprocessors. <em>Communications of the ACM</em>. 53, 7 (Jul.2010), 89. DOI:https://doi.org/10.1145/1785414.1785443.</p></div><div class="paragraph"><p>[48] Shao, J. et al. 2016. Read Consistency in Distributed DatabaseBased on DMVCC. <em>2016 IEEE 23rd International Conference on HighPerformance Computing (HiPC)</em>. (Dec. 2016), 142–151.DOI:https://doi.org/10.1109/HiPC.2016.11.</p></div><div class="paragraph"><p>[49] Sovran, Y. et al. 2011. Transactional storage for geo-replicatedsystems. <em>Proceedings of the Twenty-Third ACM Symposium on OperatingSystems Principles - SOSP ’11</em>. (2011), 385.DOI:https://doi.org/10.1145/2043556.2043592.</p></div><div class="paragraph"><p>[50] Tripathi, A. and Thirunavukarasu, B.D. 2015. A transaction modelfor management of replicated data with multiple consistency levels.<em>2015 IEEE International Conference on Big Data (Big Data)</em> (Oct. 2015),470–477.</p></div><div class="paragraph"><p>[51] Viotti, P. and Vukolić, M. 2016. Consistency in Non-TransactionalDistributed Storage Systems. <em>ACM Computing Surveys</em>. 49, 1 (Jun. 2016),1–34. DOI:https://doi.org/10.1145/2926965.</p></div><div class="paragraph"><p>[52] Vogels, W. 2008. Eventually Consistent. <em>Queue</em>. 6, 6 (2008), 14.DOI:https://doi.org/10.1145/1466443.1466448.</p></div><div class="paragraph"><p>[53] Wang, T. et al. 2016. Efficiently making (almost) any concurrencycontrol mechanism serializable. <em>The VLDB Journal</em>. 26, 4 (May 2016),537–562. DOI:https://doi.org/10.1007/s00778-017-0463-8.</p></div><div class="paragraph"><p>[54] Wu, C. et al. 2018. Anna : A KVS For Any Scale. <em>34th IEEEInternational Conference on Data Engineering</em>. (2018).</p></div><div class="paragraph"><p>[55] You Can’t Sacrifice Partition Tolerance: 2010.<em><a href="https://codahale.com/you-cant-sacrifice-partition-tolerance/" class="bare">https://codahale.com/you-cant-sacrifice-partition-tolerance/</a></em>.Accessed: 2018-04-17.</p></div></div></div><div class="sect1"><h2 id="afterword">后记</h2><div class="sectionbody"><div class="paragraph"><p>可以看得出，本文后期的内容比较杂乱，实际上没有达到我心中的效果。这是因为本人对于如何实现一个Causal Consistency存储系统并没有一个非常清晰的认识。我写这篇文章的初衷是理清CAP理论和ACID性质之间的关系，为分布式存储系统的设计找到一个清晰的脉络。在查资料的过程中，发现CAP理论的描述并不清晰，大家对此也各有纷争。ACID性质本身也不是很清晰，而且扩展到分布式环境中又带来一些新的问题。一些新的数据库事务的实现方法，也没有很好的对应于ACID性质中去。Non-blocking的分布式系统也是一个新兴领域，目前尽管有一些理论准备，但是算法和实现上还没有一个清晰的思路。</p></div><div class="paragraph"><p>对于分布式存储系统，首先要考虑在性能和一致性之间权衡。考虑的顺序应该如下：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Per-key Consistency</p></li><li><p>Multi-key Consistency</p></li><li><p>Transaction Consistency</p></li></ol></div><div class="paragraph"><p>偏重一致性的应用应该考虑支持Linearizability Consistency，但是同时也要考虑是否能够接受随之而来的Latency和Scalability的下降。需要高性能或高可用的应用应当考虑使用Eventual Consistency，因为Causal Consistency相关理论目前还不够成熟。但是在需要的时候，也可以探索Causal Consistency的高可用实现。对于事务的支持，如果没有实现Linearizability Consistency的话，可以考虑只支持单机事务，或者多机只读、只写事务。</p></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Consistency-Theory/">Consistency Theory</category>
      
      
      <comments>http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>哈希表总结及其高级话题讨论</title>
      <link>http://hcoona.github.io/Data-Structure/hash-table-summary-and-advanced-topics/</link>
      <guid>http://hcoona.github.io/Data-Structure/hash-table-summary-and-advanced-topics/</guid>
      <pubDate>Sat, 14 Apr 2018 06:48:16 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;哈希表（hash table）是一种快速查找场景下常用的数据结构，本文对其主要问题及其高级应对方法进行有限的总结和讨论：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;负载不够均衡，此时会有哈希冲突（collision）出现，导致哈希表性能下降&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负载高时，若不进行空间扩展则性能下降，若进行空间扩展，扩展行为的（瞬间）代价通常较高&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>哈希表（hash table）是一种快速查找场景下常用的数据结构，本文对其主要问题及其高级应对方法进行有限的总结和讨论：</p></div><div class="olist arabic"><ol class="arabic"><li><p>负载不够均衡，此时会有哈希冲突（collision）出现，导致哈希表性能下降</p></li><li><p>负载高时，若不进行空间扩展则性能下降，若进行空间扩展，扩展行为的（瞬间）代价通常较高</p></li></ol></div><div class="paragraph"><p><span id="more"></span></p></div><div class="imageblock"><div class="content"><img data-src="/images/hash-table-problems-mindmap.png" alt="Hash table problems mindmap"></div></div><div class="paragraph"><p>先回顾一下哈希表的数学模型：</p></div><div class="ulist"><ul><li><p>所有数据所在的空间集合为 \(S\)</p></li><li><p>通过哈希表存储的数据集合为 \(U\)</p></li><li><p>所有哈希桶（bucket）的下标集合为 \(R\)</p></li><li><p>通过某种方式将 \(S\) 中的元素映射到 \(R\) 集合，不妨记为函数 \(h\)</p></li></ul></div><div class="paragraph"><p>一般 \(S\) 的大小远大于 \(R\)，但是通过哈希表存储的数据集合 \(U\) 与 \(R\) 的大小相差不会太悬殊。</p></div><div class="paragraph"><p>如果有 \(x \in S, y \in S\) 并且 \(x \ne y \land h(x) = h(y)\)，则称 \(x\) 与 \(y\) 冲突（collision）。</p></div><div class="paragraph"><p>如果 \(h\) 可以将 \(U\) 单射（injective）到 \(R\)，则称此种情况为完美哈希（perfect hashing）。这意味着 \(U\) 的大小小于等于 \(R\) 的大小。特别的，当 \(U\) 的大小与 \(R\) 的大小相等时，称此种情况为最小完美哈希（minimal perfect hashing）。</p></div><div class="paragraph"><p>如果 \(U\) 预先给定，并且不再进行调整，则称此种情况为静态哈希表（static hash table），否则称为动态哈希表（dynamic hash table）。</p></div><div class="sect1"><h2 id="_哈希冲突">哈希冲突</h2><div class="sectionbody"><div class="paragraph"><p>哈希冲突的解决方案有两种：</p></div><div class="olist arabic"><ol class="arabic"><li><p>冲突避免</p></li><li><p>冲突解决</p></li></ol></div><div class="sect2"><h3 id="_冲突避免">冲突避免</h3><div class="paragraph"><p>如果哈希函数 \(h\) 选得足够好，并且 \(U\) 的大小小于等于 \(R\)，就有可能形成完美哈希的情况。<strong>对于静态哈希表，有确定性的策略 <a href="#perfect">[1]</a> 可以找到这样的 \(h\) 来达成最小完美哈希</strong>。对于动态哈希表，由于我们不能预测 \(U\) 中元素的分布，我们不能预先设计 \(h\) 以达成完美哈希。特别的，由于 \(U\) 中的元素是变动的，\(U \subset S\) 且 \(S\) 的大小远大于 \(R\)，因此对于使用确定性策略构成的哈希函数 \(h\)，总是存在一个对抗性的集合 \(U\)，可以使得哈希冲突尽可能的多。因此，<strong>对于动态哈希表，必须使用非确定性的策略来构成哈希函数 \(h\)，才有可能保证避免哈希冲突</strong>。这一问题称为 Dynamic Perfect Hashing 问题。一个可行的方案是预先准备一族哈希函数，在使用过程中随机从中选择一个哈希函数。可以想象，这一族哈希函数应该具有某种性质，使得相同分布的输入不会产生相同分布的输出。这样一来，针对某一个特定哈希函数的对抗性策略就不会对其他哈希函数生效，因此随机选择哈希函数即可抵抗确定性的对抗策略。当然，这涉及到一个问题，即在查找的时候该怎么知道用哪一个哈希函数进行查找？这一问题在后面<a href="#collision-resolution">冲突解决</a>中的 <a href="#_two_way_chaining">Two-way Chaining</a> 中进一步讨论。</p></div><div class="paragraph"><p>如果存在这样一组哈希函数，\(H = \&#123;h: U \rightarrow R\&#125;\) 满足 \(\forall x, y \in U, x \ne y: \Pr_&#123;h \in H&#125;[h(x) = h(y)] \le 1/&#123;|R|&#125;\)，则称 \(H\) 为全域哈希族（universal hashing） <a href="#universal">[2]</a>。这一数学式的意义是，在 \(U\) 中任选两个不同的元素 \(x, y\)，在 \(H\) 中任选一个哈希函数 \(h\)，则 \(h(x), h(y)\) 是独立（均匀分布）的。</p></div><div class="paragraph"><p>全域哈希族的加强形式为全域<sub>k</sub>哈希（universal<sub>k</sub> hashing) <a href="#new">[3]</a>，其需要满足如下条件：给定 k 个两两不等的元素 \((x_1, ..., x_k) \in U^k\)，和 k 个哈希值（无需两两不等）\((y_1, ..., y_k) \in R^k\)，有</p></div><div class="stemblock"><div class="content">\[\Pr_&#123;h \in H&#125; [ h(x_1) = y_1 \land \dots \land h(x_k) = y_k ] = m^&#123;-k&#125;\]</div></div><div class="paragraph"><p>这一加强形式通常不容易达到，因此我们有时选择其宽松型式 \((\mu, k)\)-universal：</p></div><div class="stemblock"><div class="content">\[\forall \text&#123;distinct&#125; (x_1, \ldots, x_k) \in U^k, \forall (y_1, \ldots, y_k) \in R^k,\Pr_&#123;h \in H&#125; [ h(x_1) = y_1 \land \dots \land h(x_k) = y_k ] \lt \mu/|R|^k\]</div></div><div class="paragraph"><p>其中 \(\mu\) 越接近 1 越好。</p></div></div><div class="sect2"><h3 id="collision-resolution">冲突解决</h3><div class="paragraph"><p>经过上面的讨论可知，对于动态哈希表很难达成完美哈希，因此我们必须考虑如何处理哈希冲突。常见的冲突解决策略有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Open Addressing</p></li><li><p>Separate Chaining</p></li><li><p>Two-way Chaining</p></li></ol></div><div class="sect3"><h4 id="_open_addressing">Open Addressing</h4><div class="paragraph"><p>Open Addressing 是一种常见的冲突解决策略，其常见的细分策略有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Linear probing</p></li><li><p>Quadratic probing</p></li><li><p>Double hashing</p></li></ol></div><div class="paragraph"><p>其中 Linear probing 由于对缓存友好，性能最高，比较常用。Linear probing 可能带来冲突聚集的情况，为了避免这一现象，有时也会使用 Quadratic probing 策略。使用 Quadratic probing 也会被对抗性策略所困，因此有时也会使用 Double hashing 配合 Universal hashing 获得更好的效果。</p></div></div><div class="sect3"><h4 id="_separate_chaining">Separate Chaining</h4><div class="paragraph"><p>Open Addressing 在装载因子较高时性能会急剧下降，为了应对这一情况，也常使用 Separate Chaining 策略。Separate Chaining 一般使用链表，有时也会使用查找树结构。</p></div></div><div class="sect3"><h4 id="_two_way_chaining">Two-way Chaining</h4><div class="paragraph"><p>Two-way Chaining 就像是 Double hashing，区别在于 Double hashing 使用一个哈希表，而 Two-way Chaining 使用两个哈希表 T<sub>1</sub> 和 T<sub>2</sub>。在插入时，\(T[h_1(x)]\) 和 \(T[h_2(x)]\) 中哪个装载的元素更少，就插入到哪儿。查找时需要访问两个哈希表。</p></div></div><div class="sect3"><h4 id="_cuckoo_hashing">Cuckoo Hashing</h4><div class="paragraph"><p>Cuckoo Hashing <a href="#cuckoo">[4]</a> 是 Two-way Chaining 的进阶版本，其同样使用两个哈希表，但是不再进行 Chaining，而是进行 Evicting，算法如下：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight plaintext">procedure insert(x)  if lookup(x) then return  loop MaxLoop times    x ↔ T1[h1(x)]    if x = ⊥ then return    x ↔ T2[h2(x)]    if x = ⊥ then return  end loop  rehash(); insert(x)end</code></pre></div></div><div class="paragraph"><p>Cuckoo Hashing 不使用 Chaining，意味着这是一种 Dynamic Perfect Hashing 的方案。</p></div><div class="paragraph"><p>P.S. Cuckoo Hashing 论文 <a href="#cuckoo">[4]</a> 中对其所使用的 \((\mu, k)\)-universal 哈希函数族有着更进一步的优化。</p></div></div></div></div></div><div class="sect1"><h2 id="_动态大小调整">动态大小调整</h2><div class="sectionbody"><div class="paragraph"><p>随着哈希表的装载因子上升，哈希冲突的概率会不断上升，直到装载因子超过 1 时，必然发生哈希冲突（抽屉原理）。对于动态哈希表，由于 \(U\) 的大小不能预先得知，所以必然需要动态调整哈希表的大小。常见的策略是当装载因子超过某一阈值后，线性扩展哈希表的大小为原来的若干倍；当装载因子低于某一阈值时，线性收缩哈希表的大小为原来的若干分之一。使用两个阈值的原因是为了避免抖动。由于 \(R\) 发生变化，因此对应的哈希函数也必须发生变化。调整大小时，另行分配内存，然后将原哈希表中的所有元素 rehash 后存储到新的哈希表中，这种策略称为 Copy All 策略。尽管该操作可以均摊到插入操作中，使得整体的均摊时间复杂度仍为一个常数，但是这一策略会带来较长时间的停顿。为了改善这一问题，又有其他改进策略 <a href="#dynamic">[5]</a>，其中较为知名的有：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Linear Hashing</p></li><li><p>Spiral Storage</p></li><li><p>Extendible Hashing</p></li></ol></div><div class="paragraph"><p>哈希表不能够均匀地增长，其根本原因在于 rehash，只要能够不 rehash 但是调整 \(R\)，就可以解决这一问题。</p></div><div class="sect2"><h3 id="_linear_hashing">Linear Hashing</h3><div class="paragraph"><p>Linear Hashing <a href="#dynamic">[5]</a><a href="#linear">[6]</a> 同时使用 2 个哈希函数来解决动态调整大小的问题。考虑这样一族哈希函数：</p></div><div class="stemblock"><div class="content">\[h_0: U \rightarrow &#123;0, 1, \dots, N - 1&#125;, h_i: U \rightarrow &#123;0, 1, \dots, 2^i N - 1&#125;\]</div></div><div class="paragraph"><p>对于任意给定的 \(x \in U\) 或者有 \(h_i(x) = h_&#123;i - 1&#125;(x)\)，或者有 \(h_i(c) = h_&#123;i - 1&#125;(c) + 2^&#123;i - 1&#125; N\)。一般来说简单取模即可符合这一要求。</p></div><div class="paragraph"><p>当哈希数组需要扩张大小时，从前向后进行，当前正在扩张的 bucket 下标记为 p。对于在 p 之前的位置，使用 \(h_&#123;i + 1&#125;\)，对于 p 及其之后的位置仍然使用 \(h_i\)。这样就可以非常平滑的，每次操作只扩张一个 bucket，而不需要把所有的元素都 rehash。<a id="spiral-better"></a> 不过这样做有一个缺点，就是有可能有一个位置上比较靠后的 bucket 一直比较拥挤，经过很多次插入后，才能对这个 bucket 进行扩张以缓解性能下降。对于这一问题，Spiral Storage 的方法处理的比较好。</p></div></div><div class="sect2"><h3 id="_spiral_storage">Spiral Storage</h3><div class="paragraph"><p>Spiral Storage <a href="#dynamic">[5]</a> 总是将负载更多的放在哈希表靠前的位置上，而非均匀地将负载分配到整个哈希表中。这样尽管是像 Linear Hashing 一样，总是从哈希表的头部开始进行 bucket 的分裂，也不会有不及时处理非常满的 bucket 的问题。</p></div><div class="paragraph"><p>Spiral Storage 的思路是这样的。哈希表的负载从前向后逐渐降低；扩展大小时，需要将表头的 bucket 中的元素分配到多个新 bucket 中并添加到哈希表的末尾，并且依然保持负载从前向后逐渐下降的性质。假设每去掉表头的一个 bucket 就添加 d 个新 bucket，称 d 为哈希表的增长因子。考虑到哈希表是非线性增加大小的，应该采用一个非线性增长的哈希函数族，将 \(U\) 映射到 \(R\)。易发现指数函数满足这样的性质。为了满足负载逐渐下降的性质，可以将 \(u \in U\) 先均匀的映射到 \(x \in [S, S + 1)\)，然后再使用指数函数 \(y = d^x \in R\)。\(R\) 的大小会随着 \(S\) 的变化而指数级增长，并且其中的元素的负载分布是指数级下降的。哈希表扩张时，将原本 \(y = d^x, x \in [S, S')\) 的元素映射到了新的区间 \(y = d^x, x \in [S + 1, S' + 1)\)，区间的大小增长了 d。</p></div><div class="paragraph"><p>论文 <a href="#dynamic">[5]</a> 中提到了 Spiral Storage 的具体实现细节及一些优化方法。</p></div></div><div class="sect2"><h3 id="_extendible_hashing">Extendible Hashing</h3><div class="paragraph"><p>Extendible Hashing <a href="#extendible">[7]</a> 将 bucket 和 bucket 的索引分别存放，使用 bucket 对应 key 的前缀对其进行索引，这样在扩展哈希表的大小时，就无需复制所有对象调整索引部分即可。</p></div></div></div></div><div class="sect1"><h2 id="_使用场景">使用场景</h2><div class="sectionbody"><div class="sect2"><h3 id="_单机场景">单机场景</h3><div class="paragraph"><p>在 Facebook F4 这种只读存储服务的场景下，或者是批量更新的 Index Serving 场景下，适合使用 Minimal Perfect Hashing 的策略。</p></div><div class="paragraph"><p>对于动态哈希表的使用场景，如果可以预先知道或部分知道数据的分布，则可以针对性的设计哈希函数，以尽可能达到 perfect hashing。</p></div><div class="paragraph"><p>如果没有关于数据的额外信息，则只能考虑冲突避免策略。在可以保证负载因子较低的情况下，应该尽量选择 Linear Probing 策略以较好的利用缓存。不能保证负载因子的情况下，如果需要有最坏情况保证的话，应该考虑 Separate Chaining 平衡搜索树的策略，或者干脆不使用哈希表。希望获得较高的装载因子，同时性能下降不太严重，又可以接受一定长尾的话，可以考虑 Cuckoo Hashing。</p></div><div class="paragraph"><p>哈希表的动态大小调整一般选择 Copy All 策略，这样对哈希函数的限制最小，实现也最容易。个人感觉 Spiral Storage 要比 Linear Hashing 好一些，原因已在上面 <a href="#spiral-better">[spiral-better]</a> 说明过。Google 有一个 Spiral Storage 的开源实现： <a href="https://code.google.com/p/sparsehash/" class="bare">https://code.google.com/p/sparsehash/</a> 。PostgreSQL 中使用 Linear Hashing，见 <a href="https://www.postgresql.org/docs/8.0/static/sql-createindex.html" class="bare">https://www.postgresql.org/docs/8.0/static/sql-createindex.html</a> 。</p></div></div><div class="sect2"><h3 id="_多机场景">多机场景</h3><div class="paragraph"><p>哈希函数的选择同单机场景。这里只讨论动态大小调整的问题。</p></div><div class="paragraph"><p>尽管在早期有将 Linear Hashing 和 Extendible Hashing 扩展到多机的尝试 <a href="#linear_star">[8]</a><a href="#extendible_star">[9]</a>，但是最终被一致性哈希所统治。多机场景下，由于不希望出现单点瓶颈，所以使用 P2P 结构，更多的问题在于如何快速的将请求匹配到实际存储数据的节点。这一问题被归类为如何将对等节点自组织成某种结构，并在其上进行消息路由，这方面的总结见 <a href="https://zhuanlan.zhihu.com/p/34323809">论文笔记：关于 P2P 的一些综述</a>。这些路由算法的时间复杂度一般都是 \(\mathcal&#123;O&#125;(\log n)\) 级别的。对于 LAN 环境下的快速查找场景，尤其是使用哈希表的情况下，我们一般期望常数级别的时间复杂度，这方面可以参考 <a href="#beehive">[10]</a><a href="#zht">[11]</a>，或者是干脆缓存所有节点的映射信息。</p></div><div class="paragraph"><p>哈希表的动态大小调整，个人觉得 Amazon Dynamo <a href="#dynamo">[12]</a> 做的比较好，最近 Google 也出了一篇论文 <a href="#load">[13]</a> 似乎能保证移动数据量的上界。</p></div></div></div></div><div class="sect1"><h2 id="_其他">其他</h2><div class="sectionbody"><div class="paragraph"><p>因为哈希表一般需要保持较低的负载因子，在哈希表较大时元素会非常稀疏。如果需要支持 scan 操作的话，需要考虑在非空 bucket 之间建立联系。</p></div><div class="paragraph"><p>如果不在乎计算复杂度的话，可以使用密码学哈希函数（Cryptographic hash function）以获得较为均匀的结果。</p></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="perfect"></a>[1] Martin Dietzfelbinger. (2007). Design Strategies for Minimal Perfect Hash Functions. Stochastic Algorithms: Foundations and Applications. SAGA 2007. Lecture Notes in Computer Science, vol 4665.  DOI:https://doi.org/10.1007/978-3-540-74871-7_2</p></li><li><p><a id="universal"></a>[2] Carter, J. L., &amp; Wegman, M. N. (1979). Universal classes of hash functions. Journal of Computer and System Sciences, 18(2), 143–154.  DOI:https://doi.org/10.1016/0022-0000(79)90044-8</p></li><li><p><a id="new"></a>[3] Wegman, M. N., &amp; Carter, J. L. (1981). New hash functions and their use in authentication and set equality. Journal of Computer and System Sciences, 22(3), 265–279. DOI:https://doi.org/10.1016/0022-0000(81)90033-7</p></li><li><p><a id="cuckoo"></a>[4] Pagh, R., &amp; Rodler, F. F. (2004). Cuckoo hashing. Journal of Algorithms, 51(2), 122–144. <a href="https://doi.org/10.1016/J.JALGOR.2003.12.002" class="bare">https://doi.org/10.1016/J.JALGOR.2003.12.002</a></p></li><li><p><a id="dynamic"></a>[5] Larson, P.-A. (1988). Dynamic hash tables. Communications of the ACM, 31(4), 446–457. <a href="https://doi.org/10.1145/42404.42410" class="bare">https://doi.org/10.1145/42404.42410</a></p></li><li><p><a id="linear"></a>[6] Hiemstra, D., Kushmerick, N., Domeniconi, C., Paice, C. D., Carroll, M. W., Jensen, C. S., … Mankovskii, S. (2009). Linear Hashing. In Encyclopedia of Database Systems (Vol. 0, pp. 1619–1622). Boston, MA: Springer US. <a href="https://doi.org/10.1007/978-0-387-39940-9_742" class="bare">https://doi.org/10.1007/978-0-387-39940-9_742</a></p></li><li><p><a id="extendible"></a>[7] Ronald Fagin, Jurg Nievergelt, Nicholas Pippenger, and H. Raymond Strong. 1979. Extendible hashing&#8201;&#8212;&#8201;a fast access method for dynamic files. ACM Trans. Database Syst. 4, 3 (1979), 315–344. DOI:https://doi.org/10.1145/320083.320092</p></li><li><p><a id="linear_star"></a>[8] Witold Litwin, Marie-Anne Neimat, and Donovan A Schneider. 1993. LH<sup>*</sup>: Linear Hashing for distributed files. Proc. 1993 ACM SIGMOD Int. Conf. Manag. data (1993), 327–336. DOI:https://doi.org/10.1145/170035.170084</p></li><li><p><a id="extendible_star"></a>[9] Victoria Hilford, Farokh B. Bastani, and Bojan Cukic. 1997. EH<sup>*</sup> - Extendible Hashing in a distributed environment. Proc. - IEEE Comput. Soc. Int. Comput. Softw. Appl. Conf. (1997).</p></li><li><p><a id="beehive"></a>[10] Venugopalan Ramasubramanian and Emin Gun Sirer. 2004. Beehive: O(1)lookup performance for power-law query distributions in peer-to-peer overlays. System 1, 1 (2004), 8. Retrieved from <a href="http://portal.acm.org/citation.cfm?id=1251175.1251183" class="bare">http://portal.acm.org/citation.cfm?id=1251175.1251183</a></p></li><li><p><a id="zht"></a>[11] Tonglin Li, Xiaobing Zhou, Kevin Brandstatter, Dongfang Zhao, Ke Wang, Anupam Rajendran, Zhao Zhang, and Ioan Raicu. 2013. ZHT: A light-weight reliable persistent dynamic scalable zero-hop distributed hash table. Proc. - IEEE 27th Int. Parallel Distrib. Process. Symp. IPDPS 2013 (2013), 775–787. DOI:https://doi.org/10.1109/IPDPS.2013.110</p></li><li><p><a id="dynamo"></a>[12] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, Gunavardhan Kakulapati, Avinash Lakshman, Alex Pilchin, Swaminathan Sivasubramanian, Peter Vosshall, and Werner Vogels. 2007. Dynamo: Amazon’s Highly Available Key-value Store. Proc. Symp. Oper. Syst. Princ. (2007), 205–220. DOI:https://doi.org/10.1145/1323293.1294281</p></li><li><p><a id="load"></a>[13] Vahab Mirrokni, Mikkel Thorup, and Morteza Zadimoghaddam. 2016. Consistent Hashing with Bounded Loads. (2016), 587–604. Retrieved from <a href="http://arxiv.org/abs/1608.01350" class="bare">http://arxiv.org/abs/1608.01350</a></p></li></ul></div></div></div><div class="sect1"><h2 id="_补充">补充</h2><div class="sectionbody"><div class="paragraph"><p>最近恰巧看到2篇不错的文章：</p></div><div class="ulist"><ul><li><p><a href="https://medium.com/@fchern/%E8%A8%AD%E8%A8%88%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84hash-table-%E4%B8%80-303d9713abab">設計高效能的Hash Table（一）</a></p></li><li><p><a href="https://medium.com/@fchern/%E8%A8%AD%E8%A8%88%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84hash-table-%E4%BA%8C-9b5dc744219f">設計高效能的Hash Table（二）</a></p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://hcoona.github.io/tags/Algorithms/">Algorithms</category>
      
      <category domain="http://hcoona.github.io/tags/Data-Structure/">Data Structure</category>
      
      
      <comments>http://hcoona.github.io/Data-Structure/hash-table-summary-and-advanced-topics/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>工作中常用到的 C++ 功能子集</title>
      <link>http://hcoona.github.io/Tips/practical-cpp-subset/</link>
      <guid>http://hcoona.github.io/Tips/practical-cpp-subset/</guid>
      <pubDate>Mon, 09 Apr 2018 06:45:05 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;用 C&amp;#43;&amp;#43; 语言也有一些年头了，在此总结一些工作中比较实用的 C&amp;#43;&amp;#43; 的功能子集。这里的主要使用场景是系统编程，不包括各种通用类库。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>用 C&#43;&#43; 语言也有一些年头了，在此总结一些工作中比较实用的 C&#43;&#43; 的功能子集。这里的主要使用场景是系统编程，不包括各种通用类库。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect1"><h2 id="_advanced_c">Advanced C</h2><div class="sectionbody"><div class="paragraph"><p>在工作中使用 C&#43;&#43; 更多的是将其作为一种更加先进的 C 语言来使用。C&#43;&#43; 比之 C 语言带来了以下好用的特性：</p></div><div class="ulist"><ul><li><p>RAII</p></li><li><p>Smart Pointers</p></li><li><p>Move Semantics</p></li><li><p>Namespace</p></li><li><p>Access Control (private, protected &amp; public)</p></li><li><p>Generics (Template)</p></li><li><p>Structured Exception Handling</p></li><li><p>Lambda Expression</p></li><li><p>Enum class</p></li></ul></div><div class="paragraph"><p>Smart Pointer 使得 C&#43;&#43; 可以在一定程度上自动管理对象的生命周期。RAII 使得我们可以将任意资源的分配和回收与对象的生命周期相关联。两者结合，使得我们可以在一定程度上自动管理资源的生命周期。这使得 C&#43;&#43; 一跃成为可以和 Python &amp; Java 一争长短的现代开发语言。</p></div><div class="paragraph"><p>RAII 将资源的管理与对象的生命周期互相绑定，但是有时我们需要暂时解除这种绑定并将他们重新绑定。此时我们就需要 Move Semantics，这带来了资源所有权的 hand-off 能力。</p></div><div class="paragraph"><p>比之 Namespace + Access Control，其实我更想要的是 Module，但是这个 proposal 也是难产了好久了 <a href="#module">[1]</a>。有了 Module 之后，我还希望一个语法糖：扩展方法。也就是 <code>f(obj, &#8230;&#8203;)</code> 等同于 <code>obj.f(&#8230;&#8203;)</code> 这样的功能。这样有些方法就没必要非要写在 class 里面了。</p></div><div class="paragraph"><p>C&#43;&#43; 有了泛型是极好的，但是仍有两个缺点。一个是所有的泛型都要写到头文件里，这也是没有 Module <a href="#module">[1]</a> 的一个缺陷。另一个是没有一个好的办法约束泛型参数，Concept 这个 proposal 也是难产了好久了 <a href="#concept">[2]</a>。此外 C&#43;&#43; 的 Template 能力太强，不做库开发的话强烈建议不要使用模板元编程，只用其中泛型相关的部分即可。需要一些元编程的部分怎么办呢？单独在构建过程中加一个预处理阶段，使用其他 template engine 去展开 source code 即可，不容易出错，可读性强，而且报错信息友好。</p></div><div class="paragraph"><p>C&#43;&#43; 有结构化异常处理。我知道有些人宁愿把错误码和结果一起返回，也不愿意用异常处理机制。但是我只想说，异常处理谁用谁知道。此外，异常处理在 normal execution path 上是 zero cost 的 <a href="#exception">[3]</a>。</p></div><div class="paragraph"><p>Lambda Expression 替代了函数指针，这个就不多说了，这么多年才把这个功能做对也是不容易了。</p></div><div class="paragraph"><p>Enum class 也终于让 enum 不再只是个常数定义的另一种写法了。</p></div></div></div><div class="sect1"><h2 id="_面向对象编程">面向对象编程</h2><div class="sectionbody"><div class="paragraph"><p>面向对象编程（OOP）一般是没啥用的，也不应该用。但是 C&#43;&#43; 中泛型用起来太麻烦了，而且 RTTI 太弱了，以至于大多数情况下我们都是用继承来实现多态（<a href="https://en.wikipedia.org/wiki/Subtyping">子类型多态</a>），而非泛型。</p></div><div class="paragraph"><p>Java 这种号称纯 OOP 的语言，其实大家用到的基于继承关系的多态功能也很少，更多的时候是搞出来一个接口，然后大家都用接口交互，或者是泛型约束于接口。实际上 Java 中的接口起到的更多的是 C&#43;&#43; 中 Concepts <a href="#concept">[2]</a> 的作用。只有在用容器去装这些*不同类型*的实例（Instance）的时候，才真正用到一点点子类型多态。这种场景并不多见，更多情况下，在配置好了的状态下，启动应用后，某个容器其实只需要装某个特定类型的实例。然而也不是没有用容器装多个类型的实例的场景，只是说比较少，而且大多数都可以通过让容器去装 lambda 函数的方式来搞定。实在搞不定的只能弄个接口类型出来了，谁让 C&#43;&#43; 中没有 <code>Object</code> 类型呢，毕竟你又不能 <code>delete (void *)p</code>。</p></div><div class="paragraph"><p>而且 OOP 还搞出来不少问题，其中比较显著的问题都通过 GoF 的《设计模式》一书总结了，然而不用 OOP 就没这些问题 <a href="#patterns">[4]</a>。</p></div><div class="paragraph"><p>但是 OOP 在有些场景下还是挺有用的，比如说 UI，比如说容器。但是用的时候得小心点，OOP 总是诱惑你在不应该 OO 的地方 OO，这是基于你与生俱来的在现实世界中学习到的先验知识认为应该有继承关系，但是在数学上不存在子类型关系的地方带来的认知冲突。</p></div><div class="paragraph"><p>总之，C&#43;&#43; 有 OOP 的能力还是很好的，只是用的时候要非常非常的小心，并且还要注意 C&#43;&#43; 中值语义（Value Semantics）和对象语义（Object Semantics）的区别 <a href="#value">[5]</a>。</p></div></div></div><div class="sect1"><h2 id="_其他">其他</h2><div class="sectionbody"><div class="paragraph"><p>C&#43;&#43; 中还有一些比较容易混淆的概念（暂时只想起来一个）：</p></div><div class="ulist"><ul><li><p><code>const</code> 和 <code>constexpr</code></p></li></ul></div><div class="paragraph"><p>C&#43;&#43; 中的 <code>const</code> 干了太多事情了。现在只需记住一个原则，Java 的 <code>final</code> 在 C&#43;&#43; 中应该用 <code>constexpr</code>，为一个对象创建只读版本的接口时才使用 <code>const</code>。</p></div><div class="paragraph"><p>使用 C&#43;&#43; 提供动态链接库接口是一件非常麻烦的事情。我的建议是不要用 pimpl 模式和 Windows COM 那样的做法；简单一点，直接包装出一个 C 版本的 API 就好了。</p></div><div class="paragraph"><p>没事别把大对象放在栈上，<code>new</code> 一个对象没多大开销，用 <code>unique_ptr</code> 也可以解决生命周期的问题。</p></div></div></div><div class="sect1"><h2 id="_未来">未来</h2><div class="sectionbody"><div class="paragraph"><p>我比较期待 C&#43;&#43; 提供这些功能：</p></div><div class="ulist"><ul><li><p>Module <a href="#module">[1]</a></p></li><li><p>Concepts <a href="#concept">[2]</a></p></li><li><p>Async/Await <a href="#await">[6]</a></p></li></ul></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="module"></a>[1] <a href="https://isocpp.org/files/papers/N4047.pdf">[N4047] A Module System for C++</a></p></li><li><p><a id="concept"></a>[2] <a href="www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1758.pdf">[N1758] Concepts for C&#43;&#43;0x&#8201;&#8212;&#8201;Open Standards</a></p></li><li><p><a id="exception"></a>[3] <a href="http://llvm.org/docs/ExceptionHandling.html">Exception Handling in LLVM</a></p></li><li><p><a id="patterns"></a>[4] <a href="http://norvig.com/design-patterns/design-patterns.pdf">Design Patterns in Dynamic Programming&#8201;&#8212;&#8201;Peter Norvig</a></p></li><li><p><a id="value"></a>[5] <a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics#val-vs-ref-semantics">Reference and Value Semantics&#8201;&#8212;&#8201;ISO C&#43;&#43; FAQ</a></p></li><li><p><a id="await"></a>[6] <a href="https://isocpp.org/files/papers/N4402.pdf">[N4402] Resumable Functions (revision 4) - Standard C&#43;&#43;</a></p></li><li><p><a id="imperfect"></a>[7] Matthew Wilson. Imperfect C++: Practical Solutions for Real-Life Programming. ISBN: 978-0321228772.</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Programming-Language/">Programming Language</category>
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      
      <comments>http://hcoona.github.io/Tips/practical-cpp-subset/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[ICDE&#39;18] Anna: A KVS for any scale</title>
      <link>http://hcoona.github.io/Paper-Note/anna-kvs/</link>
      <guid>http://hcoona.github.io/Paper-Note/anna-kvs/</guid>
      <pubDate>Sat, 07 Apr 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Anna 是 Berkeley 大学研究的一种 Key-Value 存储 &lt;a href=&quot;#anna&quot;&gt;[1]&lt;/a&gt;。其开创性的使用 lattice 的方式允许用户自定义冲突解决方式，进而可以自定义一致性级别，在特定场景下极大的提升系统性能。Anna 使用了 Actor 模型而非传统的共享内存模型构建系统，使得系统可以以几乎一致的方式处理单机/分布式场景下的通信和协调，并且充分发挥硬件提供的并发能力。论文中没有详细叙述实现这两者的具体细节，由于这两者的实现方式都有一定难度，期待接下来的研究能够披露出进一步的细节。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Anna 是 Berkeley 大学研究的一种 Key-Value 存储 <a href="#anna">[1]</a>。其开创性的使用 lattice 的方式允许用户自定义冲突解决方式，进而可以自定义一致性级别，在特定场景下极大的提升系统性能。Anna 使用了 Actor 模型而非传统的共享内存模型构建系统，使得系统可以以几乎一致的方式处理单机/分布式场景下的通信和协调，并且充分发挥硬件提供的并发能力。论文中没有详细叙述实现这两者的具体细节，由于这两者的实现方式都有一定难度，期待接下来的研究能够披露出进一步的细节。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>整体结构上 Anna 与 Amazon Dynamo <a href="#dynamo">[2]</a> 相同。区别在于 Dynamo 中节点是由物理节点构成，而 Anna 是由 Actor 构成。Anna 的 Actor 绑定在每个节点的可用线程上，以此避免线程切换开销，提供更高性能的服务。Anna 的读写处理无需 coordinator 而 Dynamo 的 sloppy quorum 需要。</p></div><div class="paragraph"><p>Anna 的基本思想来源于 <a href="#hat">[3]</a> 和 <a href="#crdt1">[4]</a>（<a href="#crdt2">[5]</a> 是 <a href="#crdt1">[4]</a> 的一个补充）。定义 Highly Available 的含义为 <em>guaranteesa response from each non-failing server in the presence of arbitrarynetwork partitions between them</em>。如图 <a href="#figure-1">Partial ordering of HAT</a> 所示，红色的表示在 HA 的限制下不可能实现的一致性级别，其他则是在 HA 的限制下也有可能实现的一致性级别。那么既要 HA，又要 Replication 的话，怎么达到一致性呢？答案就是*最终一致性*：在收到客户端请求时立刻做出响应，然后在后台定期传播这一变动，在一定的协议下令所有 replication 达成一致。这一最终一致性协议如何设计？Anna 根据之前在 Bloom 语言 <a href="#bloom">[6]</a> 中获得的经验 <a href="#lattices">[7]</a>，使用 lattice 这样一种结构让用户自行定义 CRDT <a href="#crdt1">[4]</a>。在进行冲突解决时，即可根据用户定义的 CRDT 提供所需的一致性保证。</p></div><div id="figure-1" class="imageblock"><div class="content"><img data-src="/images/highly-available-transactions-ordering.png" alt="Partial ordering of HAT"></div><div class="title">Figure 1: Partial ordering of HAT</div></div><div class="paragraph"><p>对于 CRDT 的设计，要求其符合 ACI 属性，如图 <a href="#figure-2">ACI properties</a> 所示。</p></div><div id="figure-2" class="imageblock"><div class="content"><img data-src="/images/anna-aci-properties.png" alt="ACI properties"></div><div class="title">Figure 2: ACI properties</div></div><div class="paragraph"><p>符合这样的性质有以下好处。幂等性使得我们可以轻易处理 <em>at least once</em> 语义的消息传播带来的问题。结合性和交换性使得我们可以任意排列组合这些操作。这样我们只需记录客户端请求的 merge 操作日志，然后在副本之间进行同步即可，无需处理他们之间的序关系。我理解 lattice 内部记录了因果关系和 versioning，因此这里实际上处理起来和 Dynamo 差不多，只是在冲突解决方面比 Dynamo 更加灵活。</p></div><div class="paragraph"><p>Anna 的性能测试显示其比较其他 Key-Value Store 具有显著优势。我认为这有几方面可能：</p></div><div class="ulist"><ul><li><p>Anna 具有更好的多线程性能</p></li><li><p>Anna 具有更低的一致性级别</p></li><li><p>Anna 具有更低的 Durability</p></li></ul></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="anna"></a>[1] Chenggang Wu, Jose M Faleiro, Yihan Lin, and Joseph M Hellerstein. 2018. Anna : A KVS For Any Scale. ICDE 2018. Retrieved from <a href="https://icde2018.org/index.php/program/research-track/long-papers/" class="bare">https://icde2018.org/index.php/program/research-track/long-papers/</a></p></li><li><p><a id="dynamo"></a>[2] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, Gunavardhan Kakulapati, Avinash Lakshman, Alex Pilchin, Swaminathan Sivasubramanian, Peter Vosshall, and Werner Vogels. 2007. Dynamo: Amazon’s Highly Available Key-value Store. SOSP 2007, 205–220. DOI:https://doi.org/10.1145/1323293.1294281</p></li><li><p><a id="hat"></a>[3] Peter Bailis, Aaron Davidson, Alan Fekete, Ali Ghodsi, Joseph M. Hellerstein, and Ion Stoica. 2013. Highly Available Transactions: Virtues and Limitations. Proc. VLDB Endow. 7, 3 (2013), 181–192. DOI:https://doi.org/10.14778/2732232.2732237</p></li><li><p><a id="crdt1"></a>[4] Marc Shapiro, Nuno Preguiça, Carlos Baquero, and Marek Zawirski. 2011. Conflict-Free Replicated Data Types. In Stabilization, Safety, and Security of Distributed Systems, 386–400. DOI:https://doi.org/10.1007/978-3-642-24550-3_29</p></li><li><p><a id="crdt2"></a>[5] Marc Shapiro, Nuno Preguiça, Carlos Baquero, and Marek Zawirski. 2011. A comprehensive study of Convergent and Commutative Replicated Data Types. (2011).</p></li><li><p><a id="bloom"></a>[6] Peter Alvaro, Neil Conway, J Hellerstein, and Wr Marczak. 2011. Consistency Analysis in Bloom: a CALM and Collected Approach. Cidr 3, 2 (2011), 249–260. Retrieved from <a href="http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper35.pdf" class="bare">http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper35.pdf</a></p></li><li><p><a id="lattices"></a>[7] Neil Conway, William R. Marczak, Peter Alvaro, Joseph M. Hellerstein, and David Maier. 2012. Logic and lattices for distributed programming. In Proceedings of the Third ACM Symposium on Cloud Computing - SoCC ’12, 1–14. DOI:https://doi.org/10.1145/2391229.2391230</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Facebook/">Facebook</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/anna-kvs/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每个程序员都应该会点形式化证明</title>
      <link>http://hcoona.github.io/Tips/programmer-should-know-formal-verification/</link>
      <guid>http://hcoona.github.io/Tips/programmer-should-know-formal-verification/</guid>
      <pubDate>Thu, 05 Apr 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我认为每个程序员都应该会点形式化证明，这有助于思考，更有助于写出正确的实现。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>我认为每个程序员都应该会点形式化证明，这有助于思考，更有助于写出正确的实现。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>在最近的面试中，我发现近一半的面试者不能正确完成二分搜索（的一个变种）。这些面试者有些是有 3-5 年工作经验，有些是刚毕业的计算机专业的优秀学生。我很惊讶于他们没有一个人能够给出一个完整的，细致而全面的二分搜索算法的解释和正确实现。有些面试者尽管能够写出正确的算法，但是在后面的询问过程中发现他们并没有考虑清楚边界情况，只是恰好写对了。这不禁让我感叹，每个程序员都应该会点数学归纳法。</p></div><div class="paragraph"><p>问题描述如下：给定一个单调非下降的数组，要求在其中进行二分搜索，找到第一个大于等于给定数字的位置（<code>std::lower_bound</code>）。这一限定是比较宽泛的，比如说没有限制每次递归中比较的次数，没有限定只能使用小于等于运算符，没有考虑没找到的情况下（目标位置溢出右边界）返回什么，等等。</p></div><div class="paragraph"><p>为了更进一步的叙述方便，我在此说明一些记号的含义：</p></div><div class="ulist"><ul><li><p>给定的目标元素记为 <code>t</code>。</p></li><li><p>给定的数组记为 <code>arr</code>，其长度为 <code>n</code>。</p></li><li><p><code>arr[k]</code> 为数组中位置为 <code>k</code> 的值。</p></li><li><p>数组的连续子区间 \([b, e)\) 中含有 <code>arr[b]</code>，<code>arr[b + 1]</code>，&#8230;&#8203;，<code>arr[e - 1]</code> 的值。其中间元素的位置 \(m = b + \lfloor (e - b) / 2 \rfloor\)。</p></li></ul></div><div class="paragraph"><p>二分搜索的方法是，检查目标区间的中间元素与目标元素的大小关系，以此为依据将目标区间划分为 2 部分，然后在其中的一部分中继续进行上述步骤，直到目标区间足够小，能够简单的确定要查找的元素的位置。然后使用这一简单方法，确定最终要找的元素的位置。</p></div><div class="paragraph"><p>一般来说，面试者会考虑三种情况：</p></div><div class="olist arabic"><ol class="arabic"><li><p><code>arr[m]</code> &lt; <code>t</code>，此时需要在右侧区间（不含中间元素）\([m + 1, e)\) 中继续进行搜索。</p></li><li><p><code>arr[m]</code> = <code>t</code>，此时需要在左侧区间（含中间元素）\([b, m + 1)\) 中继续进行搜索。</p></li><li><p><code>arr[m]</code> &gt; <code>t</code>，此时需要在左侧区间（含中间元素）\([b, m + 1)\) 中继续进行搜索。含中间元素的原因是有可能在给定的数组中没有和目标元素相等的元素。</p></li></ol></div><div class="paragraph"><p>这三种情况考虑的如果没有漏洞的话，就能保证*要找的元素始终在新的区间中*，记此性质为 <em>Safety Property 1</em>。</p></div><div class="paragraph"><p>这一步是大多数面试者都能正确做到的。但是我见过的所有的面试者都没有去考虑这样一件事：新的区间是否比原区间小？事实上，我们需要保证*新的查找区间总是比原查找区间小*，这样算法才能够不断有进展，记此性质为 <em>Liveness Property 1</em>。</p></div><div class="paragraph"><p><em>Safety Property 1</em> 和 <em>Liveness Property 1</em> 结合对应着<a href="https://zh.wikipedia.org/zh-hans/数学归纳法">数学归纳法</a>中的<a href="https://zh.wikipedia.org/zh-hans/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E6%8E%A8%E9%80%92%E6%AD%A5%E9%AA%A4">递推步骤</a>。</p></div><div class="paragraph"><p>令 \(e = m + 1\)，解得 \(e = b + 1\) 或 \(e = b + 2\)，即查找区间有 1 个元素或 2 个元素。显然，\(b = m + 1\) 永远都不会成立。由此才能确定，当查找区间收缩到空区间或只含有小于等于 2 个元素时，需要进行特殊处理。所谓特殊处理，即是指处理违反 <em>Liveness Property 1</em> 的情况。此时一一检查区间中的元素即可，如果要找的元素不存在，此时返回 <code>-1</code> 或 <code>e</code> 都是合理的选择。这样的操作保证了*当查找区间中只有 1 个或 2 个元素时，能够返回要找的元素的位置*，记此性质为 <em>Safety Property 2</em>。这一性质对应数学归纳法中的<a href="https://zh.wikipedia.org/zh-hans/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E8%B5%B7%E5%A7%8B%E6%AD%A5%E9%AA%A4">起始步骤</a>。</p></div><div class="paragraph"><p>无需进行形式化证明，只需按照证明的思路进行思考，写出的程序就可以很有信心。</p></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Algorithms/">Algorithms</category>
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/Tips/programmer-should-know-formal-verification/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单机存储引擎的基础方法</title>
      <link>http://hcoona.github.io/Tips/storage-engine-basic/</link>
      <guid>http://hcoona.github.io/Tips/storage-engine-basic/</guid>
      <pubDate>Thu, 05 Apr 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是一篇关于单机存储引擎基本思路的总结和分析。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>这是一篇关于单机存储引擎基本思路的总结和分析。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>看了 Facebook Haystack 的论文 <a href="#haystack">[1]</a> 后，对于其单机对象存储引擎的设计感觉十分简洁，进而对其他单机引擎的设计产生了一些兴趣。</p></div><div class="paragraph"><p>看了 <a href="#ddia">[2]</a> 之后，对单机存储引擎有了一个非常粗略的了解。首先，需要处理的内容分为两类：数据及其索引。此时有两种方案：</p></div><div class="olist arabic"><ol class="arabic"><li><p>数据和索引放到一起（聚簇索引，Clustered Index），例如 Berkeley DB，InnoDB，LevelDB</p></li><li><p>数据和索引分别存放，例如 MyISAM，Facebook Haystack</p></li></ol></div><div class="paragraph"><p>对于索引，只考虑精确索引，有以下分类：</p></div><div class="ulist"><ul><li><p>平坦结构</p><div class="ulist"><ul><li><p>哈希表，例如 Bitcask</p></li></ul></div></li><li><p>树结构</p><div class="ulist"><ul><li><p>B 树族，例如 Berkeley DB，InnoDB，MyISAM</p></li><li><p>LSM 树，例如 LevelDB</p></li><li><p>分形树，例如 PerconaFT</p></li><li><p>R 树，例如 PostGIS</p></li><li><p>T 树（纯内存结构)，例如 EXtremeDB</p></li></ul></div></li></ul></div><div class="sect1"><h2 id="_方案比较个人看法">方案比较（个人看法）</h2><div class="sectionbody"><div class="paragraph"><p>数据和索引放在一起存储的方案，其优点在于：</p></div><div class="olist arabic"><ol class="arabic"><li><p>索引到 Key 之后无需再进行一次 IO 操作即可直接取出 Value</p></li><li><p>索引和数据的一致性高</p></li><li><p>如果索引是有序的，则数据也是有序存放的，进行扫描时效率高</p></li></ol></div><div class="paragraph"><p>数据和索引不放在一起存储的方案，其优点在于：</p></div><div class="olist arabic"><ol class="arabic"><li><p>数据和索引可以以不同的方式进行组织</p></li><li><p>索引的大小显著减少</p></li></ol></div><div class="paragraph"><p>如果索引能够全放入内存，则不应该使用聚簇索引。写请求较多的情况下，最好不要使用聚簇索引。需要支持扫描请求的话，并且数据存储于 HDD 的情况下，应该考虑聚簇索引。如果在意启动时间，应该使用聚簇索引。具体解释见 <a href="#_update_1">Update 1</a></p></div><div class="paragraph"><p>对于索引方案，可以看到很少有使用哈希表做索引的存储引擎。个人认为这是因为哈希表必须全部装入内存，并且很难进行增量持久化。这对于传统数据库场景和文件系统场景都是不可接受的，因为占用了太多内存。B 树和 LSM 树比较受欢迎也是因为索引可以部分装入内存，这样热点索引载入内存，其他留在磁盘上，剩下的内存就可以做其他事情了，最差也可以做热点数据的缓存用。</p></div><div class="paragraph"><p>LSM 树是近几年新兴的索引结构，其比较 B 树的优点是读写性能更高。这是得益于其分裂、合并的操作可以在后台进行。LSM 树的缺点是写放大，这在论文 <a href="#pebbles">[3]</a> 中有所改进。LSM 的另一个问题是在写请求较多时，后台合并的速度不够快以至于很难完成分裂、合并等操作，以至于整体性能的持续下降。</p></div><div class="paragraph"><p>几乎所有的存储引擎没有采用 Facebook Haystack 的方案，使用异步写入 Index File 的方式增量持久化内存索引信息。这是因为大部分存储引擎是为了小 Value 设计的。对于 Facebook Haystack 的场景，平均个 Value 大约有 80KB 左右的大小，一个 100GB 的数据库也只能存储约 1.3 million 个对象，其索引大小应不会超过 10MB。常见的数据库使用场景应该不是这样的，但是我没有统计数据。但是个人认为，对于纯 Key-Value Store 的场景（无需在节点上进行 join 之类的计算），可以接受比较大的索引大小，比如说 10GB 的索引。在这样的情况下，Facebook Haystack 的设计方案还是很有吸引力的，相当于一次同步的顺序写入操作即可完成写请求。如果比较在意索引占用内存的话，也可以使用 LSM 树进行索引，但是将索引和数据分离仍然能够受益，见论文 <a href="#wisckey">[4]</a>。</p></div></div></div><div class="sect1"><h2 id="_update_1">Update 1</h2><div class="sectionbody"><div class="paragraph"><p>个人非常同意评论区 <a href="https://www.zhihu.com/people/dd42c8e2fcde8a82098cc0363cca02fb">@CatKang</a> 的看法：选择数据和索引分离还是在一起这个问题得考虑三个维度：<strong>索引特性，对象大小，请求特征</strong>。</p></div><div class="paragraph"><p>由于已经有两位知友就我对于如何选择聚簇索引的看法提出一些问题，我希望把这一段讨论进一步展开一些，给出我提出这一建议的具体原因。</p></div><div class="dlist"><dl><dt class="hdlist1"><strong>如果索引能够全放入内存，则不应该使用聚簇索引</strong></dt><dd><p>使用聚簇索引很可能就不能将索引全部载入内存中，在这种情况下有点得不偿失。全内存索引性能高，索引结构上受到的限制极少。如有可能，应该尽量使用全内存索引。</p></dd><dt class="hdlist1"><strong>写请求较多的情况下，最好不要使用聚簇索引</strong></dt><dd><p>并非不要使用聚簇索引，而是建议考虑非聚簇索引。不使用聚簇索引，可以更自由的组织写入数据的存放方式，进而获得更高的写入性能，比如说像 Haystack 那样顺序写单文件，又比如说并行写 SSD 上不同 cell 的多个文件。使用聚簇索引可以避免使用非聚簇索引带来的一些问题，例如扫描性能可能下降，删除场景浪费空间，索引和数据的 Crash 一致性问题，等等。但是不可避免的，数据的写入受限于索引的组织方式。使用 B 树，随机写带来性能下降。使用 LSM 树进行索引，（个人看法）也不过是将随机写延迟到后台线程进行，随机写转化为顺序写的代价就是写放大，并且在持续高写入场景下，还会有 compact 和写入请求争用写入带宽的问题。</p></dd><dt class="hdlist1"><strong>需要支持扫描请求的话，并且数据存储于 HDD 的情况下，应该考虑聚簇索引</strong></dt><dd><p>扫描请求最好是数据有序排放，一次扫描正好访问一个连续空间，性能高。此时如果索引本身是有序的，再采用聚簇索引，对扫描请求的支持效率是最高的。</p></dd><dt class="hdlist1"><strong>如果在意启动时间，应该使用聚簇索引</strong></dt><dd><p>非聚簇索引的索引和数据有 Crash 一致性问题。在 Crash-Recover 的场景下，需要从数据恢复索引的最新状态，带来启动时间的增加。</p></dd></dl></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="haystack"></a>[1] Beaver, D., Kumar, S., Li, H. C., Sobel, J., Vajgel, P., &amp; Facebook, I. (2010). Finding a Needle in Haystack: Facebook’s Photo Storage. In Proc. USENIX Symp. Operating Systems Design and Implementations (OSDI’10) (pp. 1–14).</p></li><li><p><a id="ddia"></a>[2] Martin Kleppmann. 2016. Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems (1st ed.). O’Reilly Media, Inc.</p></li><li><p><a id="pebbles"></a>[3] Pandian Raju, Rohan Kadekodi, Vijay Chidambaram, and Ittai Abraham. 2017. PebblesDB: Building Key-Value Stores using Fragmented Log-Structured Merge Trees. In Proceedings of the 26th Symposium on Operating Systems Principles - SOSP ’17, 497–514. DOI:https://doi.org/10.1145/3132747.3132765</p></li><li><p><a id="wisckey"></a>[4] Thanumalayan Sankaranarayana Pillai Lanyue Lu and Remzi H. Arpaci-Dusseau Andrea C. Arpaci-Dusseau. 2016. WiscKey: Separating Keys from Values in SSD-Conscious Storage. Fast ’16 13, 1 (2016), 1–28. DOI:https://doi.org/10.1145/3033273</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      
      <comments>http://hcoona.github.io/Tips/storage-engine-basic/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[OSDI&#39;14] F4: Facebook&#39;s Warm BLOB Storage System</title>
      <link>http://hcoona.github.io/Paper-Note/facebook-f4/</link>
      <guid>http://hcoona.github.io/Paper-Note/facebook-f4/</guid>
      <pubDate>Sun, 01 Apr 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;F4 是 Facebook 为了降低存储成本而开发的，应用于只读可删除不可写场景的，对象存储系统。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>F4 是 Facebook 为了降低存储成本而开发的，应用于只读可删除不可写场景的，对象存储系统。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>加入了 F4 后 Facebook 的对象存储整体架构如下图所示：</p></div><div class="imageblock"><div class="content"><img data-src="/images/facebook-blob-architecture.png" alt="Overall BLOB storage architecture"></div></div><div class="paragraph"><p>其中 Haystack 负责 Hot 对象的存储，F4 负责 Warm 对象的的存储。在其上通过 Router Tier 将请求正确的路由到相应的系统中去。由于 Facebook 的对象存储主要用于图片和视频，应用场景主要是 Feed 流，因此对象的热度和其创建时间有着非常高的相关性。在 Haystack 中对象被顺序写入 Physical Volume 中，当 Physical Volume 写满后（比如说 100GB）被设为只读但是可删除。在过一段时间之后，整个 Physical Volume 的 BLOBs 都不再 Hot 了，此时整个 Physical Volume 被移入 F4 存储系统中继续提供服务。在 F4 中，Physical Volume 被拆散成若干份（取决于采用的 Erasure Encoding 需要），使用 Erasure Encoding 生成 Parity 后得到若干 Blocks，这些 Blocks 分布到不同的节点上。不同 DataCenter 的 2 个不同 Block 会做一次 XOR 然后将结果存在另一个 DataCenter 中，如下图所示：</p></div><div class="imageblock"><div class="content"><img data-src="/images/facebook-f4-geo-xor.png" alt="Geo-replicated XOR Coding"></div></div><div class="paragraph"><p>如果采用 Reed-Solomon(10, 4) 编码的话，相当于每个 Physical Volume 先被放大到 1.4 倍，然后两个 Physical Volume 再扩大一个 Physical Volume 这么多，因此相当于平均每个 BLOB 放大了 \(1.4 + 1.4/2 = 2.1\) 倍。F4 系统的架构如下图所示：</p></div><div class="imageblock"><div class="content"><img data-src="/images/facebook-f4-architecture.png" alt="F4 single cell architecture"></div></div><div class="paragraph"><p>一个读请求的处理流程如下：</p></div><div class="olist arabic"><ol class="arabic"><li><p>通过 Name Node 找到对应的 Storage Node</p></li><li><p>通过 Index API 找到对应的 Block 和 Offset</p></li><li><p>通过 File API 读取对应的 Block 的对应 Offset</p></li><li><p>如果这个 Block 坏掉了，就去找 Backoff Node 读取。Backoff Node 联系任意 10 个 Block + Parity 进行单 Block 的恢复</p></li></ol></div><div class="paragraph"><p>其他一些跟错误恢复相关的：</p></div><div class="ulist"><ul><li><p>在 Rebuilder Node 上进行整个 Physical Volume 的恢复</p><div class="ulist"><ul><li><p>可以取到所有已知的 Blocks + Parity 进行恢复</p></li><li><p>不行的话还可以通过 XOR 恢复</p></li></ul></div></li><li><p>在 Coordinator Node 的协调下将 Blocks 根据 Placement Policy 分布到不同的 Storage Node 上</p></li></ul></div><div class="paragraph"><p>F4 因为只需要处理只读的情况，因此设计上比较简单。新的写请求会落到 Haystack 中，然后将 F4 中对应的 BLOB 删掉（只删除索引即可），因为写后马上就会迎来一波热点服务（出现在朋友的 Feed 流中）。</p></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="f4"></a>[1] Subramanian Muralidhar, Wyatt Lloyd, Southern California, Sabyasachi Roy, Cory Hill, Ernest Lin, Weiwen Liu, Satadru Pan, Shiva Shankar, Viswanath Sivakumar, Linpeng Tang, and Sanjeev Kumar. 2014. f4: Facebook’s Warm BLOB Storage System. Osdi’14 (2014), 383&#8212;&#8203;398. Retrieved from <a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/muralidhar" class="bare">https://www.usenix.org/conference/osdi14/technical-sessions/presentation/muralidhar</a></p></li><li><p><a id="haystack"></a>[2] Beaver, D., Kumar, S., Li, H. C., Sobel, J., Vajgel, P., &amp; Facebook, I. (2010). Finding a Needle in Haystack: Facebook’s Photo Storage. In Proc. USENIX Symp. Operating Systems Design and Implementations (OSDI’10) (pp. 1–14).</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Facebook/">Facebook</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/facebook-f4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[OSDI&#39;10] Finding a needle in Haystack: Facebook&#39;s photo storage</title>
      <link>http://hcoona.github.io/Paper-Note/facebook-haystack/</link>
      <guid>http://hcoona.github.io/Paper-Note/facebook-haystack/</guid>
      <pubDate>Sat, 31 Mar 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Haystack 是 Facebook 为了其图片存储场景进行特殊优化的热存储系统，系统接口是简单 Key-Value 存储。论文主要描述了其单机存储引擎的构建，针对一次写入多次读取从不修改的场景进行优化。&lt;strong&gt;本笔记只涉及到论文中单机存储引擎的部分&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Haystack 是 Facebook 为了其图片存储场景进行特殊优化的热存储系统，系统接口是简单 Key-Value 存储。论文主要描述了其单机存储引擎的构建，针对一次写入多次读取从不修改的场景进行优化。<strong>本笔记只涉及到论文中单机存储引擎的部分</strong>。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p>Facebook 图片存储场景有这样的一些特点：</p></div><div class="olist arabic"><ol class="arabic"><li><p>新写入的图片会很快变得很热，并且随着时间推迟慢慢变冷（feed 流场景）</p></li><li><p>写入的 1 个图片会产生 4 种不同的大小（Thumbnails，Small，Medium，Large），大部分的读请求是 Small 大小的</p></li><li><p>读请求远大于写请求，并且一旦写入就不会进行修改，很少进行删除</p></li><li><p>对于热点请求在系统外部已经有了 SDN，因此大部分 Cache 方案效果都不会太好</p></li><li><p>主要处理长尾请求或还没来得及推给 SDN 的请求</p></li><li><p>平均对象大小为 64KB ~ 85KB（根据 §1 给出的数据）</p></li></ol></div><div class="paragraph"><p>在 Haystack 之前，Facebook 采用 NFS + NAS 的方式来进行服务。有一些 NAS 服务器提供存储服务，一张图片一个文件。WebServer 通过 NFS 协议挂载这些 NAS。这样遇到的问题是读一张图片需要 3 次磁盘随机访问：</p></div><div class="olist arabic"><ol class="arabic"><li><p>读文件系统索引，从而找到 inode</p></li><li><p>读 inode 从而找到实际数据所在的位置</p></li><li><p>读实际数据</p></li></ol></div><div class="paragraph"><p>尽管做了不少尝试，但是由于用户请求大多数是长尾请求，因此通过 cache 来减少这一流程的尝试基本上都失败了。在这种情况下，最好的选择是减少 Metadata 的大小，然后将所有的 Metadata 都装入内存。注意这种方式是可行的，因为</p></div><div class="olist arabic"><ol class="arabic"><li><p>数据是一次写入，多次读取，从不修改，很少删除</p></li><li><p>不需要任何访存控制</p></li><li><p>不需要任何结构</p></li></ol></div><div class="paragraph"><p>Haystack 的结构比较简单，分为三部分：Haystack Store，Haystack Directory and Haystack Cache。论文中着重描述了 Store 部分的构造，而对后两者描述较少。这是可以理解的，因为这一问题主要是单机 Key-Value 存储引擎如何对这一特殊场景进行优化的问题。</p></div><div class="paragraph"><p>Haystack Store 的结构自顶向下是这样的：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Hashtable（虽然文中没有直接说，但是在 §3.6.2 中提到了）</p></li><li><p>Index File（用于快速重建 Hashtable，§3.4.4）</p></li><li><p>Physical File（约 100GB 大小，存放实际数据，§3.4）</p></li><li><p>XFS（1GB extents，§3.4.5）</p></li><li><p>RAID-6 （256KB stripe size，§3.4.5，§4.4.6）</p></li></ol></div><div class="paragraph"><p>一个写请求的流程大概是这样的（<strong>有自行脑补部分</strong>，因为有些细节原论文没写）：</p></div><div class="olist arabic"><ol class="arabic"><li><p>根据 Logical Volumn ID 查内存表直接找到文件句柄</p></li><li><p>如果文件不够大的话，进行 pre-allocate</p></li><li><p>在文件末尾顺序写入内容（此处不确定是如何处理并发的）</p></li><li><p>更新内存中的 Hashtable 并向客户端响应成功</p></li><li><p>异步更新 Index File（此处不确定是如何处理并发的，因为第 3 步很有可能是更小的 object 先完成，这样的话如何保证 Index File 中 needle 的顺序和 Physical File 中 needle 的顺序一致？）</p></li></ol></div><div class="paragraph"><p>对于并发处理有两个可能的猜测：</p></div><div class="olist arabic"><ol class="arabic"><li><p>在写入请求中已经知道 data 的大小，进而可以推算出 needle 的大小。只需维护写入位置的 offset 即可并发写入多个 needle</p></li><li><p>并发写入顺序化后再进行处理（这样对 HDD 写操作比较友好？）</p></li></ol></div><div class="paragraph"><p>一个删除请求只设置数据区的删除标记并调整内存中的数据结构，不管 Index File。读取时如果发现某一对象已经被删除，则再次调整内存中的映射。最终通过 stop and copy 的方式完成 GC。在论文 <a href="#f4">[2]</a> 中提到，删除操作已经不依赖于 Physical File 和 Index File 的 delete 标记了，转而直接操作 Journal File 和 Hashtable。</p></div><div class="sect1"><h2 id="_其他疑问">其他疑问</h2><div class="sectionbody"><div class="ulist"><ul><li><p>为什么非得保证 Index File 中 needle 的顺序和 Physical File 中一致？难道不是只记录最后一个 needle 的位置就行了吗？这样也许并发的处理会简单一些。</p></li><li><p>needle 结构中的 Header 和 Footer 是怎么起到 recovery 的作用的？为什么需要两个一样作用的东西？</p></li><li><p>Superblock 是什么？</p></li><li><p>与其他单机引擎的比较？（InnoDB，BerkeleyDB，LevelDB）尤其是与 LSM 类引擎的比较。（LSM-trie: an LSM-tree-based ultra-large key-value store for small data；LSM-tree managed storage for large-scale key-value store；Ceph: a scalable, high-performance distributed file system ；Atlas: Baidu&#8217;s key-value storage system for cloud data）</p><div class="ulist"><ul><li><p>其他引擎并不对读场景特别优化，而是支持读写平衡的</p></li><li><p>有些引擎还支持快速 scan 等功能，Haystack 中 value 不是有序组织的，可能 scan 起来性能会降低</p></li><li><p>LSM 引擎的写放大可能会是个问题，见论文 <a href="#pebbles">[3]</a></p></li></ul></div></li></ul></div></div></div><div class="sect1"><h2 id="_参考实现">参考实现</h2><div class="sectionbody"><div class="paragraph"><p><a href="https://github.com/chrislusf/seaweedfs" class="bare">https://github.com/chrislusf/seaweedfs</a></p></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="haystack"></a>[1] Beaver, D., Kumar, S., Li, H. C., Sobel, J., Vajgel, P., &amp; Facebook, I. (2010). Finding a Needle in Haystack: Facebook’s Photo Storage. In Proc. USENIX Symp. Operating Systems Design and Implementations (OSDI’10) (pp. 1–14).</p></li><li><p><a id="f4"></a>[2] Subramanian Muralidhar, Wyatt Lloyd, Southern California, Sabyasachi Roy, Cory Hill, Ernest Lin, Weiwen Liu, Satadru Pan, Shiva Shankar, Viswanath Sivakumar, Linpeng Tang, and Sanjeev Kumar. 2014. f4: Facebook’s Warm BLOB Storage System. Osdi’14 (2014), 383&#8212;&#8203;398. Retrieved from <a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/muralidhar" class="bare">https://www.usenix.org/conference/osdi14/technical-sessions/presentation/muralidhar</a></p></li><li><p><a id="pebbles"></a>[3] Pandian Raju, Rohan Kadekodi, Vijay Chidambaram, and Ittai Abraham. 2017. PebblesDB: Building Key-Value Stores using Fragmented Log-Structured Merge Trees. In Proceedings of the 26th Symposium on Operating Systems Principles - SOSP ’17, 497–514. DOI:https://doi.org/10.1145/3132747.3132765</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Facebook/">Facebook</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/facebook-haystack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[USENIX ATC&#39;14] In Search of an Understandable Consensus Algorithm (Raft)</title>
      <link>http://hcoona.github.io/Paper-Note/raft/</link>
      <guid>http://hcoona.github.io/Paper-Note/raft/</guid>
      <pubDate>Thu, 29 Mar 2018 03:23:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Raft 是一种分布式共识算法，用于解决在异步通信网络中存在节点失效且本地存储可靠的情况下多个分布式节点达成一致的问题。在已经提出 Paxos 算法用于解决这一问题的情况下继续提出 Raft 算法，主要是为了解决 Paxos 理解困难的问题。Paxos 算法更偏向于理论研究，对于实现的很多细节虽然略有提及，但是并没有进行深入的讲解和讨论，因此对于算法的实现和优化而言还有很多困难。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Raft 是一种分布式共识算法，用于解决在异步通信网络中存在节点失效且本地存储可靠的情况下多个分布式节点达成一致的问题。在已经提出 Paxos 算法用于解决这一问题的情况下继续提出 Raft 算法，主要是为了解决 Paxos 理解困难的问题。Paxos 算法更偏向于理论研究，对于实现的很多细节虽然略有提及，但是并没有进行深入的讲解和讨论，因此对于算法的实现和优化而言还有很多困难。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="paragraph"><p><strong>个人认为</strong>，Raft 算法本身，在理解上并不比 Paxos 具有更多优势。就好像数学中的<a href="https://en.wikipedia.org/wiki/Non-standard_analysis">非标准分析</a>之于<a href="https://en.wikipedia.org/wiki/(ε,_δ)-definition_of_limit">\(\epsilon-\delta\)极限表示法</a>下的<a href="https://en.wikipedia.org/wiki/Real_analysis">标准实分析</a>。虽然使用非标准分析表述微积分内部的概念比较易于理解，但是其保证其正确的基础证明非常难以理解，而标准实分析中表述微积分内部的概念虽然有点绕，但是其基础证明的难度却没有那么高。对比而言，Paxos 的 safety 和 liveness 性质就很好理解，而 Raft 协议虽然给出了一些性质约束，但是由此能够得出 linearizability consistency 的证明却要难以理解的多 <a href="#raft_fv">[3]</a>。此外，这篇论文中还给出了在 Paxos Made Simple <a href="#paxos">[2]</a> 中没有讨论清楚的一些实现细节，因此对算法的实现人员比较友好，但是相对而言，对其进行进一步优化的难度也要大得多。</p></div><div class="sect1"><h2 id="_基本思路">基本思路</h2><div class="sectionbody"><div class="paragraph"><p>Single-decree Paxos 协议中，如果想要高效的推进算法进度，也是需要选主的。但是 Paxos 论文中引入选主这一问题相当晚，直到最后一步没有 lead 时候有可能不能推进算法进行的时候，才提出可以引入主节点，通过总是让主节点获胜的方法来使得算法进行下去。而在 Multi-decrees Paxos 的场景中，如果已经有了（唯一的）主节点，又可以对算法进行相当程度的优化。Raft 协议就是针对这一点进行展开的，即先选出唯一的主节点，再由该主节点主导 log replication 过程。在此，Raft 协议还做了一个假设，即 <strong>client 的请求只由主节点进行处理</strong>。考虑到上述要求，Raft 协议的第一部分要求就是选主，对此有如下限制：</p></div><div class="olist arabic"><ol class="arabic"><li><p>任意时刻最多只能有 1 个主节点</p></li><li><p>client 的请求只由主节点进行处理</p></li><li><p>主节点从不修改自己的（状态机指令）日志，至对其进行 append 操作</p></li><li><p>主节点已经提交过的日志，在换主后，必将出现在新主节点的日志中</p></li></ol></div><div class="paragraph"><p>用论文中的说法就是这样的：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>Election Safety</strong></td><td class="hdlist2"><p>at most one leader can be elected in a given term. §5.2</p></td></tr><tr><td class="hdlist1"><strong>Client interaction</strong></td><td class="hdlist2"><p>Clients of Raft send all of their requests to the leader. §8</p></td></tr><tr><td class="hdlist1"><strong>Leader Append-Only</strong></td><td class="hdlist2"><p>a leader never overwrites or deletes entries in its log; it only appends new entries. §5.3</p></td></tr><tr><td class="hdlist1"><strong>Leader Completeness</strong></td><td class="hdlist2"><p>if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms. §5.4 （此处 term 表示 leader 的任期）</p></td></tr></table></div><div class="paragraph"><p>其中 <em>Leader Append-Only</em> 和 <em>Leader Completeness</em> 这两个性质约束了选主的时候，新的主节点必须拥有最新的 committed 的日志。</p></div><div class="paragraph"><p>在有了主节点之后，问题就简单了。主节点只需将 client 的请求定序，并复制给其他节点即可。由此引申出如下性质：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>Log Matching</strong></td><td class="hdlist2"><p>if two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index. §5.3</p></td></tr><tr><td class="hdlist1"><strong>State Machine Safety</strong></td><td class="hdlist2"><p>if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. §5.4.3</p></td></tr></table></div><div class="paragraph"><p>直觉上应该没什么问题，主节点永远拥有最新的状态，所有的请求都发给主节点，主节点在 replica 到多数后回应请求结果。liveness 主要集中在选主上面，即是否能在这样的约束条件下保证能够选出主节点，本论文没有证明这一结论。</p></div></div></div><div class="sect1"><h2 id="_实现细节">实现细节</h2><div class="sectionbody"><div class="paragraph"><p>Raft 协议的核心在于选主。Raft 使用心跳机制用于检测主节点的存活，从而触发选主流程。每个节点有三种状态：跟随者（Follower），候选者（Candidate），领导者（Leader）。每个节点初始处于跟随者的状态。如果它认为领导者节点已经失效，则进行选主流程：</p></div><div class="olist arabic"><ol class="arabic"><li><p>首先增加 term 顺序号，然后将自己的状态转为一个候选者。</p></li><li><p>然后提议选举自己成为领导者，并将这一请求广播给其他节点</p></li><li><p>重复上述步骤，直到以下几种情况发生：</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>赢得选举</p></li><li><p>其他节点已经成为了领导者</p></li></ol></div></li></ol></div><div class="paragraph"><p>当一个节点得到多数节点的认可时，可认为其赢得选举。每个节点按照先到先得的原则同意其他节点的选举请求（此处原因可参考 Paxos，即只有一个节点选举时也会赢得选举）。考虑到 <em>Leader Append-Only</em> 和 <em>Leader Completeness</em> 这两个性质，在此过程中应该对选主过程做出合理限制，以免新任领导者节点没有最新的 committed 的状态，从而违背 <em>State Machine Safety</em> 性质。这一限制即，在选主请求中，携带当前自己已知的最新的 committed index。每个节点在应答其他节点的选主请求时，如果对方具有比自己当前最新 committed index 更低的值，就拒绝其选主请求。</p></div><div class="paragraph"><p>Raft 选择随机等待重试的方法来尽量避免选举平局的出现。根据 <a href="#imp">[4]</a> 中的结论，<strong>在不依赖于真实物理时间的情况下（包括随机量）</strong>，只需有 1 个节点失效即有可能导致选主失败，因此我们只能尽量避免这一情况，而不存在确定性的策略，没有 corner case 的解决这一问题。尽管还有其他可能的策略来尽量避免这一局面的出现，但是 Raft 论文的作者认为随机 back-off 的策略比较简单而且不容易出现 corner case，个人认同这一观点。</p></div><div class="paragraph"><p>有了主节点（领导者）后，其他问题就好办了。所有的客户端请求都统一发给主节点，这些请求在主节点上被定序，然后顺序的进行处理。主节点将接到的请求广播给所有其他节点，一旦多数节点确认接收到这一请求，即可认为该请求已经 committed，至此主节点将这一操作应用到自身的状态机上，并将结果返回给客户端。</p></div><div class="paragraph"><p>尽管主节点可能在没有来得及将一个请求发送给多数节点时就挂掉了，此时会有两种可能性</p></div><div class="olist arabic"><ol class="arabic"><li><p>这一请求被下一任领导者继续完成</p></li><li><p>这一请求被下一任领导者放弃，并使用其他内容覆盖</p></li></ol></div><div class="paragraph"><p>尽管这两种情况可能以任意顺序交替发生，但是仍然可以保证当且仅当一个请求被扩散到多数节点后才被 committed，一旦 committed 就不会被重写覆盖。原论文 <a href="#raft">[1]</a> 中没有进行形式化证明，但是直觉上感觉是正确的，因为在选主的时候做出了合理的限制。论文 <a href="#raft_fv">[3]</a> 中含有正确性证明（不确定，没看完）。</p></div><div class="paragraph"><p>一般来说，一个状态机系统的操作日志不会是无限长的。因此在必要的时候，我们要对状态机操作日志进行压缩（compact）。Raft 论文中使用状态机快照（snapshot）来进行日志压缩，但是其他多种方案也可以达到这一目的，例如 LSM（Log-Structured Merge tree）。一个快照可以被看作是在此时之前的所有操作日志顺序执行的结果。在保留了一定数目的操作日志后，更老的日志子集就被状态机快照所取代。快照的一个问题是，有可能某个节点落后主节点太多，以至于所需的操作日志已经变成了快照而不可获取单独的操作日志项。这既有可能是因为慢节点，也有可能是因为网络分区，还有可能是新添加的节点。对于此种情况，该节点只能获取最新的快照，进行状态机恢复，然后继续获取并应用在此之后的操作日志。</p></div></div></div><div class="sect1"><h2 id="_成员变换">成员变换</h2><div class="sectionbody"><div class="paragraph"><p>成员变换之所以成为一个问题，是因为由于成员组成不同，在切换的时刻，可能由这两组不同的成员分别各自选出主节点，从而出现两个主节点，违背了 <em>Election Safety</em> 性质。</p></div><div class="paragraph"><p>Paxos 由于不要求一定有主节点，也不要求只有一个主节点，因此可以不用进行特殊处理，只是将成员列表作为状态机的一个状态即可。Paxos 论文 <a href="#paxos">[2]</a> 中设计每个提议者（proposer）最多只能缓冲 \(\alpha\) 条来自客户端的指令，因此只需将成员变更的命令放在将要提交的第 \(\alpha + 1\) 条指令处即可。在此成员变更指令生效前，新加入的节点只作为学习者（learner）的角色即可。此外也可以参考论文 <a href="#paxos_vert">[5]</a> 中的方法。</p></div><div class="paragraph"><p>Raft 处理这一问题采用重叠（overlapped）集群的方式，在成员变更的过程中，要求两个重叠集群一致认可同一个主节点。需要注意的是，被移出集群的节点可能形成一个小的封闭系统自发选主，从而干扰正常集群。在此需要进行特殊处理，即当一个跟随者（Follower）认为领导者存活时（通过心跳包），不再接受其他节点的选主请求。</p></div></div></div><div class="sect1"><h2 id="_与_paxos_的简单对比">与 Paxos 的简单对比</h2><div class="sectionbody"><div class="paragraph"><p>Raft 应该算是 Paxos 的一个简化特例版本，由于提供了更多的工程细节，省略了一些证明的过程，所以变得更容易理解和实现。但是如果需要进一步优化，则 Paxos 应该是一个更好的选择。目前已知的两个优化的点是：</p></div><div class="olist arabic"><ol class="arabic"><li><p>无主节点的并行提交（Raft 的前提就是有且只有一个主节点，这上面完全优化不了）</p></li><li><p>状态机指令的可交换性（例如 key-value store 场景下对两个不同 key 的操作是可交换的，Raft 不存在并行提交，所以对此也无从优化）</p></li></ol></div></div></div><div class="sect1"><h2 id="_references">References</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="raft"></a>[1] Diego Ongaro, and John Ousterhout. 2014. In Search of an Understandable Consensus Algorithm. Atc ’14 22, 2 (2014), 305–320. DOI:https://doi.org/10.1145/1529974.1529978</p></li><li><p><a id="paxos"></a>[2] Leslie Lamport. 2001. Paxos Made Simple. ACM SIGACT News 32, 4 (2001), 51–58. DOI:https://doi.org/10.1145/568425.568433</p></li><li><p><a id="raft_fv"></a>[3] Doug Woos, James R Wilcox, and Steve Anton, et al. 2016. Planning for change in a formal verification of the raft consensus protocol. In Proceedings of the 5th ACM SIGPLAN Conference on Certified Programs and Proofs - CPP 2016, 154–165. DOI:https://doi.org/10.1145/2854065.2854081</p></li><li><p><a id="imp"></a>[4] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. 1985. Impossibility of distributed consensus with one faulty process. J. ACM 32, 2 (April 1985), 374–382. DOI:https://doi.org/10.1145/3149.214121</p></li><li><p><a id="paxos_vert"></a>[5] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. 2009. Vertical paxos and primary-backup replication. Proc. 28th ACM Symp. Princ. Distrib. Comput. - Pod. ’09 February (2009), 312. DOI:https://doi.org/10.1145/1582716.1582783</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Consensus-Algorithm/">Consensus Algorithm</category>
      
      <category domain="http://hcoona.github.io/tags/Consistency-Theory/">Consistency Theory</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/raft/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：Paxos Made Simple</title>
      <link>http://hcoona.github.io/Paper-Note/paxos-made-simple/</link>
      <guid>http://hcoona.github.io/Paper-Note/paxos-made-simple/</guid>
      <pubDate>Fri, 16 Mar 2018 13:44:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Paxos 是一种分布式共识算法，用于解决在异步通信网络中存在节点失效且本地存储可靠的情况下多个分布式节点达成一致的问题。文中的算法只解决了决议一条法案（decree）的情况。如果需要决议多条法案，可以将该算法执行多次，每次分别对应一条法案。可以想象，有可能存在一些步骤在多次决议时无需重复执行，因此在多次决议法案的情况下，该算法可以进一步优化，但没有在本文中进行具体展开。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>Paxos 是一种分布式共识算法，用于解决在异步通信网络中存在节点失效且本地存储可靠的情况下多个分布式节点达成一致的问题。文中的算法只解决了决议一条法案（decree）的情况。如果需要决议多条法案，可以将该算法执行多次，每次分别对应一条法案。可以想象，有可能存在一些步骤在多次决议时无需重复执行，因此在多次决议法案的情况下，该算法可以进一步优化，但没有在本文中进行具体展开。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect1"><h2 id="_算法原理">算法原理</h2><div class="sectionbody"><div class="paragraph"><p>为了确保算法的正确性，我们需要以下 3 个基础的 safety 性质：</p></div><div class="olist arabic"><ol class="arabic"><li><p>Only a value that has been proposed may be chosen,</p></li><li><p>Only a single value is chosen, and</p></li><li><p>A process never learns that a value has been chosen unless it actually has been.</p></li></ol></div><div class="paragraph"><p>其中 1 排除了选中错误的提案的情况，2 排除了节点之间不一致的情况，3 排除了事先选中提案的情况（non-triviality）。</p></div><div class="paragraph"><p>除了需要保证算法的正确性，我们还需要保证算法确实能够进行到我们想要的状态。但是在此时我们还无需精确地定义 liveness 条件，而是考虑如何在保证正确性的情况下，使得某一个值最终能被选中，并且一个进程最终能够得知这一结果。</p></div><div class="paragraph"><p>根据以上要求，我们引入 3 个角色：提议者（proposer），仲裁者（acceptor）和学习者（learner）。每个进程都可以扮演其中一个或多个角色。</p></div><div class="paragraph"><p>最简单的方法就是我们选定唯一一个仲裁者，所有提议者都向这一仲裁者提议，仲裁者只需接受第一个收到的提案即可满足上述所有要求。但是这种方法一旦这唯一的仲裁者失效，我们就不能获得任何进展了。因此我们必须设立多个仲裁者，集体进行多数表决。多数表决可以满足上面提到的所有基础 safety 性质，尤其是 2（反证法可证明）。</p></div><div class="paragraph"><p>在不考虑节点失效和消息丢失的情况下，我们希望即便全局只存在 1 个提案，我们也能选中这一提案。这就要求我们满足如下性质：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>P1</strong></td><td class="hdlist2"><p>An acceptor must accept the first proposal that it receives.</p></td></tr></table></div><div class="paragraph"><p>但是这一要求会带来这样一个问题，每个提议者同时分别向一个不同的仲裁者提交不同的提案，此时每个仲裁者都接受了一个不同的提案，从而无法形成多数派。这一问题并非只能由非常罕见的情况触发，例如即便是只有两个提案同时分别被恰好一半的仲裁者所接受，此时由于一个仲裁者节点失效，导致剩下的仲裁者以同样的数量分别支持两个不同的提案，此时虽然有且仅有一个提案被选中了，我们却不能得知这是哪个提案。</p></div><div class="paragraph"><p>因此性质 P1 和多数表决选中提案的方式决定了我们必须允许仲裁者接受多个提案。为此我们将每一个不同的提案内容进行标号，使得每一个不同的提案内容都具有不同的标号，而标号具有全序关系。这样，每个提案就都具有 \((n, v)\) 这样的形式。因此我们就可以允许仲裁者选中多个提案，只需保证这些提案具有相同的提案内容 \(v\)  即可。通过在提案编号上应用数学归纳法，我们可以用如下性质来保证这一点：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>P2</strong></td><td class="hdlist2"><p>If a proposal with value \(v\) is chosen, then every higher-numbered proposal that is chosen has value \(v\) .</p></td></tr></table></div><div class="paragraph"><p>一个提案想被选中，必须先由仲裁者接受。因此我们可以考虑在仲裁者接受提案时，对其加以约束以满足性质 P2：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>P2a</strong></td><td class="hdlist2"><p>If a proposal with value \(v\) is chosen, then every higher-numbered proposal accepted by any acceptor has value \(v\) .</p></td></tr></table></div><div class="paragraph"><p>由于通信是异步的，就会存在某个仲裁者，其并不清楚其他某个仲裁者已经接受了一个提案这种情况。此时，如果这一仲裁者收到了一份新的提案，由于性质 P1，它必须接受这份提案，而这就有可能和性质 P2a 相违背。由于所有提案都是先由提议者提出的才被仲裁者接受的，因此我们可以考虑加强条件，由提议者保证这一性质：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>P2b</strong></td><td class="hdlist2"><p>If a proposal with value \(v\) is chosen, then every higher-numbered proposal issued by any proposer has value \(v\).</p></td></tr></table></div><div class="paragraph"><p>对提案编号 \(n\) 使用数学归纳法，可知满足以下性质即可保证性质 P2b：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>P2c</strong></td><td class="hdlist2"><p>For any \(v\) and \(n\), if a proposal with value \(v\) and number \(n\) is issued, then there is a set \(\mathbb&#123;S&#125;\) consisting of a majority of acceptors such that either (a) no acceptor in \(\mathbb&#123;S&#125;\) has accepted any proposal numbered less than \(n\), or (b) \(v\) is the value of the highest-numbered proposal among all proposals numbered less than \(n\) accepted by the acceptors in \(\mathbb&#123;S&#125;\).</p></td></tr></table></div><div class="paragraph"><p>为了满足性质 P2c，提议者若想提议编号为 \(n\) 的提案，必须知道是否存在小于编号 \(n\) 的提案已经或者将要（在编号为 \(n\) 的提案被多数仲裁者所接受之前）被多数仲裁者所接受。我们可以获知已经被接受的提案，但是很难预测将要发出的编号为 \(n\) 的提案被多数仲裁者接受之前是否还会有其他提案被多数仲裁者所接受。为了避免这一情况，我们可以提前要求仲裁者做出承诺，不去接受小于编号为 \(n\) 的任何提案。由于 P2c 蕴含 P2b，P2b 蕴含 P2a，P2a 蕴含 P2，我们可以使用如下的算法来保证 P2c，进而满足性质 P2：</p></div><div class="olist arabic"><ol class="arabic"><li><p>A proposer chooses a new proposal number \(n\) and sends a request to each member of some set of acceptors, asking it to respond with:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>A promise never again to accept a proposal numbered less than \(n\), and</p></li><li><p>The proposal with the highest number less than \(n\) that it has accepted, if any.</p></li></ol></div><div class="paragraph"><p>I&#8217;ll call such a request a <em>prepare</em> request with number \(n\)</p></div></li><li><p>If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number \(n\) and value \(v\), where \(v\) is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals.</p></li></ol></div><div class="paragraph"><p>这一方法实际上违背了性质 P1。考虑到性质 P1 适用于只发起 accept 请求的情况，而我们的算法实际上存在两种请求：prepare 和 accept。收到一个 prepare 请求意味着接下来还会收到一个具有相同提案编号的 accept 请求，因此如果我们收到一个不同编号的 accept 请求时，总是可以忽略这一请求，同时不违背我们至少可以保证还有一个提案可以接受这一性质。由此我们可以得到性质 P1 的加强形式：</p></div><div class="hdlist"><table><tr><td class="hdlist1"><strong>P1a</strong></td><td class="hdlist2"><p>An acceptor can accept a proposal numbered \(n\) iff it has not responded to a <em>prepare</em> request having a number greater than \(n\).</p></td></tr></table></div><div class="paragraph"><p>由于 P1a 蕴含 P1 ，我们就得到了一个能够满足所有 safety 性质的算法。对其细节进行一些优化，可以得到以下版本：</p></div><div class="dlist"><dl><dt class="hdlist1"><strong>Phase 1</strong></dt><dd><div class="olist arabic"><ol class="arabic"><li><p>A proposer selects a proposal number \(n\) and sends a prepare request with number \(n\) to a majority of acceptors.</p></li><li><p>If an acceptor receives a <em>prepare</em> request with number n greater than that of any <em>prepare</em> request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.</p></li></ol></div></dd><dt class="hdlist1"><strong>Phase 2</strong></dt><dd><div class="olist arabic"><ol class="arabic"><li><p>If the proposer receives a response to its <em>prepare</em> requests (numbered \(n\)) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered \(n\) with a value \(v\), where \(v\) is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.</p></li><li><p>If an acceptor receives an <em>accept</em> request for a proposal numbered \(n\), it accepts the proposal unless it has already responded to a <em>prepare</em> request having a number greater than \(n\).</p></li></ol></div></dd></dl></div><div class="paragraph"><p>提议者只需遵循上述算法，就允许发起多个提议。提议者也可以在任何时间放弃一个已经发起的提案而不影响正确性。一个仲裁者如果因为已经承诺不再接受更低编号的提案而忽略（ignore）一个提议时，尽管不影响正确性，但是为了性能考虑，最好告诉该提议者目前已知的最大提案编号。</p></div><div class="paragraph"><p>这一算法可以正确的选中一个提案，但是还需要学习者使得所有进程都知道这一结果。尽管可以让所有的仲裁者在自己选中某一提案的时候都将这一结果告知所有的学习者，这一方案需要多次（两个集合的笛卡儿积的大小）广播，性能较低。此时只需选择几个 distinguished learner 告知，再由它们告知所有 learner 即可。需要考虑到，由于消息可能丢失，可能所有的 distinguished learner 都不能得知当前被选中的提案。此时只需令提议者再次发起提案，直到有一个提案被选中，即可知道被选中的提案是什么。</p></div><div class="paragraph"><p>这一算法虽然可以保证正确性，但是不能保证在算法结束前时时都有进展，即不能保证最终一定能达到一致决议的状态。例如两个提议者交替的提议新的提案，每个提案编号都比对方的提案编号高，这样每次的 <em>prepare</em> 请求都会成立，但是 <em>accept</em> 请求都会被拒绝，使得算法不能停机。为了保证算法能够停机，我们需要选出一个唯一的 distinguished proposer，（<strong>此处开始到本段结束不确定</strong>）只有这个提议者会在发现自己的提议被多数仲裁者忽略（ignore）时，重新选择一个新的足够大的提案号重新提交提案（其他提议者在消息丢失时可以用原来的提案号重发来保证多数仲裁者能够收到这个提案，但是被仲裁者拒绝时不重新提交提案）。这意味着，在决议冲突的情况下，总是令 distinguished proposer 获胜。此外也可以采用计算机网络中冲突避免的方式来解决这一问题，比如说发生冲突时乘性增加重新提交提案的时间间隔，不冲突时加性减少时间间隔。这样就可以实现完全不需要 leader 的情况，但是潜在的风险就是 latency 增加。</p></div><div class="paragraph"><p>如果系统中足够多的部分（包括提议者，仲裁者和通信网络等组件）工作正常，那么选举出唯一的 distinguished proposer 即可保证 liveness。（原文并没有证明这一点，不过据说在 <a href="#paxos_revisiting">[4]</a> 中有一个关于 liveness 的证明，目测在 <a href="#paxos_parliament">[3]</a> 中含有一个不太正式的证明，在 <a href="#paxos_generalized">[5]</a> 中有一个对该算法加强形式的算法的证明，但是我都还没有看）论文 <a href="#impossibility">[2]</a> 中蕴含了这样一个结论，一个可靠的选举算法必须依赖于随机性或 real time（比如说 timeout 机制）。无论选举的结果如何，本论文中提到的算法的正确性都是可以保证的。（无论是否有 distinguished proposer，无论是否只有一个 distinguished proposer，都可以保证算法的正确性）</p></div></div></div><div class="sect1"><h2 id="_其他细节">其他细节</h2><div class="sectionbody"><div class="paragraph"><p>算法需要保证每个不同的提案都有不同的提案编号，这可以通过事先给每个提议者分别指定一个不相交的数集来做到。例如，一共有 3 个提议者，则提议者 1 的提案编号只能从除以 3 余 0 的非负整数集合中取。</p></div><div class="paragraph"><p>算法中的提案内容 \(v\) 可能需要多次传递，因此也应该保证其大小不会过大。但是有的时候确实需要对一个较大的对象达成共识，比如说 block replica。个人认为可以使用类似于 GFS 中的控制流和数据流相分离的策略 <a href="#gfs">[6]</a>，通过流式传输以节点链的顺序将较大的值事先标记并传播到每一个节点上，各个节点使用 LRU 之类的策略缓存这一内容，然后通过 Paxos 算法进行决议，这样提案内容 \(v\) 只需能够索引到这一较大的值即可。</p></div><div class="paragraph"><p>之前的算法只能对单一法令（decree）进行决议。在实际使用中，我们经常需要使用这样的算法维护分布式节点中每个节点的状态一致 <a href="#stm">[7]</a>。为此我们可以令每个节点保存最近的若干条状态机的指令，对指令日志进行 replica 的方式来保证状态机状态的一致。这样，我们只需确定每一条状态机指令在这个日志中的位置，即可保证状态机的一致性，即对指令日志中的每个位置运行一次 single-decree Paxos 算法。（<strong>此处开始到本段结束为个人理解</strong>）令每个进程都同时扮演提议者，仲裁者和学习者这三种角色。由于我们同时需要至少一个 distinguished learner 和唯一一个 distinguished proposer，因此不妨通过选主算法在这些进程中选出一个 leader，同时扮演 distinguished learner 和 distinguished proposer。所有的状态机指令总是发给 leader。如果状态机指令发给了其他节点，由于在决议冲突中总是 leader 获胜，将会导致该指令总是失败。每个节点保持运行固定数量的 single-decree Paxos 算法实例（instance），比如说 \(\alpha\) 个。在没有接收到任何状态机指令的时候，这些算法实例即可完成算法的 Phase 1，并且总是 leader 获胜。当 leader 收到状态机指令时，只需将该指令确定位置，并令对应该位置的 Paxos 算法实例进行 Phase 2 即可（原作者说这应该是共识算法的复杂度下界，貌似论文 <a href="#lb">[8]</a> 证明了这一点，但是我还没看）。由于通信是异步的，因此可能会导致状态机指令中编号靠前的指令还没有提交完成 Phase 2，但是后面的指令已经提交完成 Phase 2。此时，若 leader 失效，重新选主，就会在状态机指令日志中留下一些空洞。而且由于原来的 leader 失效，也没有其他节点能够知道对应该位置的状态机指令是什么。为了不使整个状态机的运行卡住，新的 leader 可以选择在这些位置填入空指令来跳过这些空洞位置，使得整个过程继续运行下去。上面提到的针对状态机指令进行 replica 的算法，只适用于固定的节点集合。如果需要在运行时调整节点集合，最简单的方法就是将调整集合的指令也作为一条状态机指令，当前的节点集合作为状态机所维护的状态。</p></div><div class="paragraph"><p>从两阶段提交（2PC）的角度理解 Paxos：Phase 1 要求多数节点做 Promise（<em>prepare</em>），Phase 2 要求这些节点 Commit（<em>accept</em>）。从 Quoraum 的角度理解：已经选出 Leader 的情况下，直接执行 Phase 2，此时只需写成功多数节点即可。</p></div></div></div><div class="sect1"><h2 id="_reference">Reference</h2><div class="sectionbody"><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="paxos_simple"></a>[1] Leslie Lamport. 2001. Paxos Made Simple. ACM SIGACT News 32, 4 (2001), 51–58. DOI:https://doi.org/10.1145/568425.568433</p></li><li><p><a id="impossibility"></a>[2] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. 1985. Impossibility of distributed consensus with one faulty process. J. ACM 32, 2 (April 1985), 374–382. DOI:https://doi.org/10.1145/3149.214121</p></li><li><p><a id="paxos_parliament"></a>[3] Leslie Lamport. 1998. The Part-Time Parliament. ACM Trans. Comput. Sys-tems 16, 2 (1998), 133–169. DOI:https://doi.org/10.1145/279227.279229</p></li><li><p><a id="paxos_revisiting"></a>[4] Roberto De Prisco, Butler Lampson, and Nancy Lynch. 2000. Revisiting the paxos algorithm. Theor. Comput. Sci. 243, 1–2 (2000), 35–91. DOI:https://doi.org/10.1016/S0304-3975(00)00042-6</p></li><li><p><a id="paxos_generalized"></a>[5] Leslie Lamport. 2005. Generalized Consensus and Paxos. April (2005), 60. DOI:https://doi.org/MSR-TR-2005-33</p></li><li><p><a id="gfs"></a>[6] Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung. 2003. The Google file system. Proc. Ninet. ACM Symp. Oper. Syst. Princ. - SOSP ’03 (2003), 29. DOI:https://doi.org/10.1145/945449.945450</p></li><li><p><a id="stm"></a>[7] Fred B. Schneider and Fred B. 1990. Implementing fault-tolerant services using the state machine approach: a tutorial. ACM Comput. Surv. 22, 4 (December 1990), 299–319. DOI:https://doi.org/10.1145/98163.98167</p></li><li><p><a id="lb"></a>[8] Leslie Lamport. 2006. Lower bounds for asynchronous consensus. Distrib. Comput. 19, 2 (2006), 104–125. DOI:https://doi.org/10.1007/s00446-006-0155-x</p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      <category domain="http://hcoona.github.io/tags/Consensus-Algorithm/">Consensus Algorithm</category>
      
      <category domain="http://hcoona.github.io/tags/Consistency-Theory/">Consistency Theory</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/paxos-made-simple/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>论文笔记：[SOSP 2007] Dynamo: Amazon&#39;s Highly Available Key-value Store</title>
      <link>http://hcoona.github.io/Paper-Note/amazon-dynamo/</link>
      <guid>http://hcoona.github.io/Paper-Note/amazon-dynamo/</guid>
      <pubDate>Sun, 11 Mar 2018 16:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;如题所述，该论文讲述了一种构建高可用 Key-Value 存储的方案，高可用主要是针对于写请求，存储的环境是可信环境，存储的对象的大小一般不超过 1MB。实现方法类似于 Chord + MVRs(multi-valued registers)，但是另有不少针对性能的优化。Dynamo 提供 observable causal consistency。根据 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/34431818&quot;&gt;论文笔记：[PODC 2015] Limitations of Highly-Available Eventually-Consistent Data Stores&lt;/a&gt;，这已经是这一类系统所能提供的最高一致性了。[3]&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如题所述，该论文讲述了一种构建高可用 Key-Value 存储的方案，高可用主要是针对于写请求，存储的环境是可信环境，存储的对象的大小一般不超过 1MB。实现方法类似于 Chord + MVRs(multi-valued registers)，但是另有不少针对性能的优化。Dynamo 提供 observable causal consistency。根据 <a href="https://zhuanlan.zhihu.com/p/34431818">论文笔记：[PODC 2015] Limitations of Highly-Available Eventually-Consistent Data Stores</a>，这已经是这一类系统所能提供的最高一致性了。[3]</p><span id="more"></span><p>Dynamo 的主要需求和限制如下：</p><ol><li>need an “always writable” data store where no updates are rejected due to failures or concurrent writes</li><li>all nodes are assumed to be trusted</li><li>do not require support for hierarchical namespaces or complex relational schema</li><li>99.9% of read and write operations to be performed within a few hundred milliseconds</li><li>zero-hop routing for DHT</li></ol><p>此外还有个隐性需求藏在论文中：Periodical archiving of the dataset is a mandatory requirement for most of Amazon storage services.</p><p>为了满足写请求的高可用性，Dynamo 不在写时处理冲突，而是通过 vector versioning 同时保存多个结果，在读的时候如果能够通过 vector version 确定序关系则进行合并，并将合并后的结果写回源，否则只能选择简单的 LWW (last write wins) 或者是由客户自行处理。</p><p>与一般 Key-Value 存储不同的是，Dynamo 的 get&#x2F;put 请求需要额外携带一个 context，这个 context 对用户不透明。从论文来看，这个 context 至少包括两个内容：vector version (<em>when a client wishes to update an object, it must specify which version it is updating. This is done by passing the context it obtained from an earlier read operation, which contains the vector clock information</em>) 以及这次请求中各个节点的响应速度 (<em>the coordinator for a write is chosen to be the node that replied fastest to the previous read operation which is stored in the context information of the request</em>)。</p><p>Dynamo 的 replication 策略混合了 proactive 和 passive 两种策略 [3]。其 proactive 策略是一种 “sloppy quorum” 策略，需要预先配置好 N&#x2F;R&#x2F;W 值，并满足 R + W &gt; N（一般取 N &#x3D; 3, R &#x3D; W &#x3D; 2）。首先按照 chord 的方法定位要 get&#x2F;put 的位置，从此位置向后数 N 个健康的物理节点。get 或 put 时，需要向所有 N 个节点发起请求，但是只需有 R 或 W 个节点成功，即可向客户端返回结果。其 passive 策略是这样的，每个节点将自己所负责的区间 build 出一棵 Merkle 树，并通过 gossip 协议进行传播。按照 proactive replica 策略，会有 N 个节点负责同一个区间，这些节点通过 Merkle 树可以快速的比较出差异部分并进行同步。</p><p>当有节点失效时，按照上面的 proactive replication 策略会将本属于该节点 A 的值写入其他节点 B。此时 B 会将此值（持久化的）存储到一个特殊列表中，并记录 hinted handoff 标记，以了解该值应该被传输给节点 A。这一纪录会在 B 的后台任务检测到 A 恢复后，将该值传递给 A。</p><p>可以看出，这种读写请求在系统内部处理起来还是比较复杂的。Dynamo 对于每个请求都在 coordinator 节点上创建一个状态机。The state machine contains all the logic for identifying the nodes responsible for a key, sending the requests, waiting for responses, potentially doing retries, processing the replies and packaging the response to the client.Each state machine instance handles exactly one client request. For instance, a read operation implements the following state machine:</p><ol><li>send read requests to the nodes</li><li>wait for minimum number of required responses</li><li>if too few replies were received within a given time bound, fail the request</li><li>otherwise gather all the data versions and determine the ones to be returned and</li><li>if versioning is enabled, perform syntactic reconciliation and generate an opaque write context that contains the vector clock that subsumes all the remaining versions.</li></ol><p>For the sake of brevity the failure handling and retry states are left out.</p><h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><p>Dynamo 在 Chord + MVRs 的基础上做了大量的优化：</p><ol><li>zero-hop routing</li><li>virtual node on DHT ring</li><li>coordinator choosing optimization</li><li>client-drive coordinating</li><li>resolve conflicts on read</li><li>async write to disk</li><li>vector versioning 的大小控制</li><li>vector versioning merge result write-back (read repair)</li><li>feedback controlled background task</li></ol><p>下面分别讲解上面提到的优化措施。</p><h3 id="zero-hop-routing"><a href="#zero-hop-routing" class="headerlink" title="zero-hop routing"></a>zero-hop routing</h3><p>zero-hop routing 是为了减少路由造成的延迟。Chord routing 的时间复杂度是 $O(\log n)$，这对于一个在线系统而言是比较难接受的。单机从磁盘中顺序读取 1MB 数据也只需要 10ms，而一次 RPC 查询可能就需要 1ms。Dynamo 选择通过 gossip 协议，使得每个节点都（弱一致性）知道全局所有节点的信息。这样，zero-hop routing 就成为可能。对于一般情况，用户请求通过 SLB 均匀的抵达某一个节点，然后该节点立刻知道该将这个请求转发给哪个节点。另一种情况，即上面提到的 client-drive coordinating，client 周期性的从任意节点 pull 整个系统的节点信息，从而在接下来的通信中，直接知道该将请求发送到哪个节点。这一全局信息的大小可用以下数据进行估计：</p><ol><li>IP 地址：4 bytes</li><li>端口号：2 bytes</li><li>一系列 virtual node id：Q &#x2F; S * 16 bytes<ul><li>每个 virtual node id 的大小取决于 hash 空间的大小，论文中使用 MD5，因此每个 id 的大小为 16 bytes</li><li>根据中提到的策略 3，virtual node per physical node &#x3D; 区间总量&#x2F;系统中的节点数量</li></ul></li></ol><p>一共有 S 个节点，每个节点需要 (6 + Q &#x2F; S * 16) bytes，即整体需要 (6S + 16Q) bytes，其中 Q 为 hash 空间中预先划分好的片段数量，并且 Q 远大于 S。假设 S &#x3D; 1k，则 Q &#x3D; 100k，这样需要维护约 1.6MB 的路由信息。</p><p>但是考虑到 Q 个区间是预先划分的，属于每个节点都预先知道的公共信息，因此可以不用传输 virtual node id，而是传输 virtual node id index 即可。此时每个节点的信息需要 (6 + Q &#x2F; S * 4) bytes，即整体需要 (6S + 4Q) bytes。假设 S &#x3D; 1k, Q &#x3D; 100k，则需要维护约 406KB 的路由信息。这个量级应该是可以接受的。</p><p>论文中还提到可以用 [4] 中提到的算法进行平均 $O(1)$ 的路由，然而其最坏情况下仍然是 $O(\log n)$ 的。<del>而且在确定 preference list 的时候，需要知道 physical node 和 virtual node 的对应关系，否则选择 N 个节点的时候就会选到少于 N 个物理节点</del>（每个节点只需维护其之后的 N 个物理节点信息即可）。<del>个人怀疑并不能使用这种方法。</del></p><h3 id="virtual-node-on-DHT-ring"><a href="#virtual-node-on-DHT-ring" class="headerlink" title="virtual node on DHT ring"></a>virtual node on DHT ring</h3><p>一个物理节点可以具有多个虚拟节点，在 DHT 环中，每个虚拟节点被视为 DHT 环上的一个节点。</p><p>Using virtual nodes has the following advantages:</p><ul><li>If a node becomes unavailable, the load handled by this node is evenly dispersed across the remaining available nodes.</li><li>When a node becomes available again, or a new node is added to the system, the newly available node accepts a roughly equivalent amount of load from each of the other available nodes.</li><li>The number of virtual nodes that a node is responsible can decided based on its capacity, accounting for heterogeneity in the physical infrastructure.</li></ul><p>Chord DHT ring 中，每个区间的范围是不固定的，并且节点的加入或离去都可能会影响这个区间范围。对于 Dynamo 系统而言会带来以下问题：</p><ol><li>the nodes handing the key ranges off to the new node have to <strong>scan</strong> their local persistence store to retrieve the appropriate set of data items.</li><li>the Merkle trees for the <strong>new ranges need to be recalculated</strong></li><li>there was no easy way to <strong>take a snapshot</strong> of the entire key space due to the randomness in key ranges.</li></ol><p>这些问题对于采用 RocksDB 作为单机引擎而言可能不是个大问题，但是当时还没有这种系统。Dynamo 选择的是 Berkeley Database for 10KB objects, MySQL for larger size。</p><p>Dynamo 系统采用以下策略来确定 virtual node 和划分 DHT 空间。In this strategy, the hash space is divided into Q equally sized partitions&#x2F;ranges and each node is assigned Q&#x2F;S tokens(virtual node id) where S is the number of nodes in the system, Q is usually set such that Q &gt;&gt; N. <strong>Each node needs to maintain the information regarding the partitions assigned to each node.</strong></p><h3 id="coordinator-choosing-optimization"><a href="#coordinator-choosing-optimization" class="headerlink" title="coordinator choosing optimization"></a>coordinator choosing optimization</h3><p>any of the top N nodes in the preference list is allowed to coordinate the writes. In particular, since <strong>each write usually follows a read operation, the coordinator for a write is chosen to be the node that replied fastest to the previous read operation</strong> which is stored in the context information of the request. This optimization enables us to pick the node that has the data that was read by the preceding read operation thereby <strong>increasing the chances of getting “read-your-writes” consistency</strong></p><h3 id="client-drive-coordinating"><a href="#client-drive-coordinating" class="headerlink" title="client-drive coordinating"></a>client-drive coordinating</h3><p>上面讲 zero-hop routing 的时候大略讲过这一点。具体而言，client 的 get&#x2F;put 请求首先要路由到一个合适的 coordinator 节点上，这个节点可以是在 preference list 中任选一个节点，或者是干脆就由 client 来负责。这个 coordinator 需要建立状态机来维护整套工作流程。当 client 和 Dynamo 在同一个 data center 内时，这是可行的，并且能显著减少延迟。论文中 Table 2 显示，99.9% latency 从 60ms+ 减少到了 30ms+，平均 latency 从 ~4ms 减少到了 1-2ms。</p><p>A client periodically picks a random Dynamo node and downloads its current view of Dynamo membership state. Using this information the client can determine which set of nodes form the preference list for any given key. (Currently clients poll a random Dynamo node every 10 seconds for membership updates.)</p><h3 id="resolve-conflicts-on-read"><a href="#resolve-conflicts-on-read" class="headerlink" title="resolve conflicts on read"></a>resolve conflicts on read</h3><p>这一优化是针对写请求的高可用性，而非针对性能的优化。具体的实现细节参照论文中的 4.4 节以及 <a href="https://zhuanlan.zhihu.com/p/34057588">论文笔记：Time, clocks, and the ordering of events in a distributed system</a>。可以理解的，对于一个最终一致性系统，一定有可能发生两个不同的客户端同时写两个不同的节点这种事情。对于这种情况，如果要在写的时候控制一致性，要不然就拒绝掉其中的一个写请求，要不一个写请求会被另一个写请求所覆盖。采用前者所述策略，我们会丧失高可用性。采用后者所述策略，相当于 LWW (last write wins)，但是我们丧失了一些信息。LWW 对于有些业务场景来说可能是不合适的，毕竟有时业务方可以根据内容进行无损合并，见 <a href="https://zhuanlan.zhihu.com/p/33912913">论文笔记：[Inria RR-7506] A comprehensive study of Convergent and Commutative Replicated Data Types</a>。</p><h3 id="async-write-to-disk"><a href="#async-write-to-disk" class="headerlink" title="async write to disk"></a>async write to disk</h3><p>Dynamo provides the ability to trade-off durability guarantees for performance. In the optimization each storage node maintains an object buffer in its main memory. Each write operation is stored in the buffer and gets periodically written to storage by a <em>writer thread</em>. In this scheme, read operations first check if the requested key is present in the buffer. If so, the object is read from the buffer instead of the storage engine.</p><p>This optimization has resulted in <strong>lowering the 99.9th percentile latency by a factor of 5 during peak traffic even for a very small buffer of a thousand objects</strong>. Also, as seen in the figure, write buffering smooths out higher percentile latencies. Obviously, this scheme <strong>trades durability for performance</strong>. In this scheme, a server crash can result in missing writes that were queued up in the buffer. <strong>To reduce the durability risk, the write operation is refined to have the coordinator choose one out of the N replicas to perform a “durable write”.</strong> Since the coordinator waits only for W responses, the performance of the write operation is not affected by the performance of the durable write operation performed by a single replica.</p><h3 id="vector-versioning-的大小控制"><a href="#vector-versioning-的大小控制" class="headerlink" title="vector versioning 的大小控制"></a>vector versioning 的大小控制</h3><p><strong>A possible issue with vector clocks is that the size of vector clocks may grow if many servers coordinate the writes to an object.</strong> In practice, this is not likely because the writes are usually handled by one of the top N nodes in the preference list. In case of network partitions or multiple server failures, <strong>write requests may be handled by nodes that are not in the top N nodes in the preference list causing the size of vector clock to grow.</strong> In these scenarios, it is desirable to limit the size of vector clock. To this end, <strong>Dynamo employs the following clock truncation scheme: Along with each (node, counter) pair, Dynamo stores a timestamp that indicates the last time the node updated the data item. When the number of (node, counter) pairs in the vector clock reaches a threshold (say 10), the oldest pair is removed from the clock.</strong> Clearly, this truncation scheme can lead to inefficiencies in reconciliation as the descendant relationships cannot be derived accurately. However, this problem has not surfaced in production and therefore this issue has not been thoroughly investigated.</p><h3 id="vector-versioning-merge-result-write-back-read-repair"><a href="#vector-versioning-merge-result-write-back-read-repair" class="headerlink" title="vector versioning merge result write-back (read repair)"></a>vector versioning merge result write-back (read repair)</h3><p>After the read response has been returned to the caller the state machine waits for a small period of time to receive any outstanding responses. If stale versions were returned in any of the responses, the coordinator updates those nodes with the latest version. This process is called <em>read repair</em> because it repairs replicas that have missed a recent update at an opportunistic time and relieves the anti-entropy protocol from having to do it.</p><h3 id="feedback-controlled-background-task"><a href="#feedback-controlled-background-task" class="headerlink" title="feedback controlled background task"></a>feedback controlled background task</h3><p>Each of the background tasks uses this controller to reserve runtime <strong>slices</strong> of the resource shared across all background tasks. A feedback mechanism based on the monitored performance of the foreground tasks is employed to change the number of slices that are available to the background tasks. For example, the background controller checks to see how close the 99th percentile database read latency (over the last 60 seconds) is to a preset threshold (say 50ms).</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>在阅读论文的过程中，我遇到一些问题，其中有些问题在论文中找到了答案，但是另一些问题论文中并没有给出具体的方案。</p><p>论文 4.6 节提到：In essence, the preference list of a key is constructed such that the storage nodes are spread across multiple data centers. This scheme of replicating across multiple datacenters allows us to handle entire data center failures without a data outage. 这个做法感觉并不容易做到。直觉上，我们需要总共 S &#x2F; N 个位于其他 DC (datacenter) 的节点，这些节点均匀的分布在整个 DHT 空间上。但是这一方案难免会有 N 个节点都在同一个 DC 的情况。</p><p>论文中提到 coordinator 需要对每个请求创建一个状态机来处理整个读写流程。若此时 coordinator 失效了会怎么样？个人认为是不要紧的，首先用户没有得到回复，相当于请求超时，此时用户应认为这次请求有两种可能的状态：失败或成功。如果一个节点都没写成功，那么这个写请求就相当于丢失了，即请求失败。如果至少有一个节点写成功了，那么之后通过 Merkle tree 同步的时候，会将这一记录同步到所有需要存储的节点。如果这一记录所在的节点在同步之前就失效了，则这个记录就没了，相当于请求失败了。如果在失效之前被用户读到了，那么根据 read repair 优化，这个记录会被扩散到所有需要存储的节点上。节点失效但是之后又回来了，产生了写冲突，也会被 vector versioning 所处理。</p><p>接下来的是论文没有提到，但是我想到的几个问题。</p><p>节点的加入和退出会导致 virtual node tokens 的重新分配，这一过程是如何进行的呢？如果新加入的节点主动从其他节点中偷取一个 token，则有可能同时新加入的节点选择了相同的 token。如果系统中的节点发现了新加入的节点后，主动给出一个 token，也许是比较不错的一种选择，但是可能需要记录自己把 token 给出过给谁，或者以某一个概率给出。比如说当发现自己的 token 数大于 Q &#x2F; S 时，把自己的 token 给当前 token 数量最少的节点，并且将对应的记录全都标记上 hand-off hint。token 可以在记录传输得差不多了的时候再给出去，此时新记录的信息标记 hand-off hint，读取的时候不差这一份数据。当节点退出系统时，其所拥有的 tokens 该怎么处理？显然不能由这一节点主动给别人，因为节点失效退出时没有机会执行动作。看来只能等系统中的节点发现自己的 token 数小于 Q &#x2F; S 时，看看有没有漏的 token 捡一个。那么问题来了，如果两个节点取到了同一个 token 怎么办？怎么保证我取的 token 和现有的 tokens 组成的 tokens 是均匀分布在整个 DHT 空间中的？后者可能不好办，我们姑且认为等概率的就行。前者的话，如果不借助共识算法的话估计很难搞定。可能最简单的方法还是在系统外安排一组协调者，采用共识算法选主保证没有单点，然后发现并且均匀分配这些 tokens。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, Gunavardhan Kakulapati, Avinash Lakshman, Alex Pilchin, Swaminathan Sivasubramanian, Peter Vosshall, and Werner Vogels. 2007. Dynamo: Amazon’s Highly Available Key-value Store. Proc. Symp. Oper. Syst. Princ. (2007), 205–220. DOI:<a href="https://doi.org/10.1145/1323293.1294281">https://doi.org/10.1145/1323293.1294281</a></p><p>[2] Hagit Attiya, Faith Ellen, and Adam Morrison. 2017. Limitations of Highly-Available Eventually-Consistent Data Stores. IEEE Trans. Parallel Distrib. Syst. 28, 1 (2017), 141–155. DOI:<a href="https://doi.org/10.1109/TPDS.2016.2556669">https://doi.org/10.1109/TPDS.2016.2556669</a></p><p>[3] Stephanos Androutsellis-Theotokis and Diomidis Spinellis. 2004. A survey of peer-to-peer content distribution technologies. ACM Comput. Surv. 36, 4 (December 2004), 335–371. DOI:<a href="https://doi.org/10.1145/1041680.1041681">https://doi.org/10.1145/1041680.1041681</a></p><p>[4] Venugopalan Ramasubramanian and Emin Gun Sirer. 2004. Beehive: O(1)lookup performance for power-law query distributions in peer-to-peer overlays. System 1, 1 (2004), 8. Retrieved from <a href="http://portal.acm.org/citation.cfm?id=1251175.1251183">http://portal.acm.org/citation.cfm?id=1251175.1251183</a></p><p>[5] Leslie Lamport. 1978. Time, clocks, and the ordering of events in a distributed system. Commun. ACM 21, 7 (July 1978), 558–565. DOI:<a href="https://doi.org/10.1145/359545.359563">https://doi.org/10.1145/359545.359563</a></p><p>[6] Marc Shapiro, Nuno Preguiça, Carlos Baquero, and Marek Zawirski. 2011. A comprehensive study of Convergent and Commutative Replicated Data Types. (2011).</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Paper-Note/">Paper Note</category>
      
      
      <category domain="http://hcoona.github.io/tags/Distributed-System/">Distributed System</category>
      
      <category domain="http://hcoona.github.io/tags/Distributed-Storage/">Distributed Storage</category>
      
      <category domain="http://hcoona.github.io/tags/Paper-Note/">Paper Note</category>
      
      
      <comments>http://hcoona.github.io/Paper-Note/amazon-dynamo/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>什么是 C++ 中的 const</title>
      <link>http://hcoona.github.io/PL/what-is-const/</link>
      <guid>http://hcoona.github.io/PL/what-is-const/</guid>
      <pubDate>Tue, 28 Apr 2015 14:44:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;C++中的`const`是一个非常容易混淆的概念，我认为这主要是因为`const`的设计不够完善导致的，尽管目前C++11中新加入了`constexpr`关键词，解决了一部分问题，但是还有很多本质上的问题没有得到解决，甚至很多人都没有认识到这些问题的本质。我在这里解释一下我对C++中`const`的理解，并且试图分析其所解决的本质问题，对于部分问题，给出一些其他方案。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>C++中的`const`是一个非常容易混淆的概念，我认为这主要是因为`const`的设计不够完善导致的，尽管目前C++11中新加入了`constexpr`关键词，解决了一部分问题，但是还有很多本质上的问题没有得到解决，甚至很多人都没有认识到这些问题的本质。我在这里解释一下我对C++中`const`的理解，并且试图分析其所解决的本质问题，对于部分问题，给出一些其他方案。</p></div><div class="paragraph"><p><span id="more"></span></p></div><div class="sect1"><h2 id="_c中的const的3种用法">C++中的`const`的3种用法</h2><div class="sectionbody"><div class="paragraph"><p>C++中的`const`有3种用法：</p></div><div class="olist arabic"><ol class="arabic"><li><p>修饰一个变量（类型），表示这个变量（类型）不可修改</p></li><li><p>修饰一个变量（类型），表示这是一个常量</p></li><li><p>修饰一个成员函数，表示这个成员函数不会修改类的内部状态</p></li></ol></div><div class="paragraph"><p>这三种用法中，第2种已经被新的关键字`constexpr`所取代，而第1种和第2种用法或多或少有些问题。</p></div></div></div><div class="sect1"><h2 id="_const表示变量类型不可修改">`const`表示变量（类型）不可修改</h2><div class="sectionbody"><div class="paragraph"><p>代码实例：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="type">const</span> <span class="type">int</span> a = <span class="built_in">f</span>();cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// OK</span>a = <span class="number">5</span>; <span class="comment">// Compile Error! `a` is readonly.</span></code></pre></div></div><div class="paragraph"><p>其实大家在使用这种方式的时候，只是想表明被修饰的*变量*<code>a`是只读的。但是C++在这里有一个问题，就是`const`修饰的并不是变量，而是*变量的类型*。这里变量`a`的类型是`int const</code>，这个类型和`int`是不兼容的，这经常导致一些非常傻逼的情况：</p></div><div class="olist arabic"><ol class="arabic"><li><p>将函数的返回值类型设置为`const`类型的</p></li><li><p>将函数的参数类型设置为`const`类型的，到后来发现有一个很深的依赖函数需要修改这个值</p></li></ol></div><div class="paragraph"><p>第1种情况在修饰栈上对象的时候就是一种纯傻逼行为，因为函数返回的时候一拷贝就能去掉`const`修饰符，相当于什么都没干；在修饰指针（含引用）类型的时候，则需要更多的考虑以防出现第2种情况这样缺乏远见的行为。</p></div><div class="paragraph"><p>C++之所以这么做，就是因为对象有可能是在栈上的，也有可能是堆上的，而这两种情况对于用户是不透明的，用户必须知道这个对象是在哪儿的，并且在代码中反映出这种不同，这对于C++程序员而言是相当痛苦的。当一个对象是在堆上的时候，尽管我们不允许修改指向这个对象实例的指针，但是仍然有可能修改其所指向的对象实例的内容。为了防止这种情况发生，C++设计的时候让`const`修饰类型，这样我们使用只读类型的时候，无论是在栈上还是堆上都不能修改对象实例的内容了。</p></div></div></div><div class="sect1"><h2 id="_const修饰成员函数">`const`修饰成员函数</h2><div class="sectionbody"><div class="paragraph"><p>示例代码：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">private</span>:    <span class="type">int</span> m_id;<span class="keyword">public</span>:    <span class="function"><span class="type">int</span> <span class="title">get_id</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>;    <span class="function"><span class="type">void</span> <span class="title">set_id</span><span class="params">(<span class="type">int</span> id)</span></span>;&#125;</code></pre></div></div><div class="paragraph"><p>这个问题和上一个问题是高度相关的，正因为`const`在表示只读时修饰的是类型，所以就需要标记出哪些成员函数是只读的，这些成员函数可以在只读类型中继续使用，而其他成员函数不可以。</p></div><div class="paragraph"><p>说到这里，我们突然发现，<code>const`的这种用法竟然是在定义一个新的类型——`X`类型的只读类型`X const</code>。</p></div><div class="paragraph"><p>这也是为什么很多程序员都不愿意在成员函数上标记`const`。</p></div></div></div><div class="sect1"><h2 id="_c中的readonly关键字">C#中的`readonly`关键字</h2><div class="sectionbody"><div class="paragraph"><p>C#中有两个关键字，<code>readonly`和`const</code>。前者用于修饰一个变量，表示该变量只读。后者也是用于修饰一个变量，表示该变量是编译时期常量。我认为这是一种比较好的设计，因为这种设计中，两个关键字分别表示两种完全不同的语义，并且`readonly`的语义符合人们修饰一个变量而非其类型的预期。</p></div><div class="paragraph"><p>`readonly`只能控制栈上（含寄存器）对象不被修改，比如`int`类型的变量，或者对象引用本身。如果想要控制堆上变量不被修改，则需要针对这一类型定义一种新的只读接口，使用这一只读接口类型才能控制堆上变量本身不被修改。</p></div><div class="paragraph"><p>示例代码</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cs"><span class="keyword">interface</span> <span class="title">AReadOnly</span> &#123;    <span class="function"><span class="built_in">int</span> <span class="title">GetId</span>()</span>;&#125;<span class="keyword">class</span> <span class="title">A</span> &#123;    <span class="keyword">private</span> <span class="built_in">int</span> m_id;    <span class="function"><span class="keyword">public</span> <span class="title">GetId</span>()</span>;    <span class="function"><span class="keyword">public</span> <span class="title">SetId</span>(<span class="params"><span class="built_in">int</span> id</span>)</span>;&#125;AReadOnly a_const = <span class="keyword">new</span> A();</code></pre></div></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/PL/">PL</category>
      
      
      <category domain="http://hcoona.github.io/tags/Programming-Language/">Programming Language</category>
      
      
      <comments>http://hcoona.github.io/PL/what-is-const/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>对“编程小练习：拆分自然数”的解答</title>
      <link>http://hcoona.github.io/interview/split-nature-number-answer/</link>
      <guid>http://hcoona.github.io/interview/split-nature-number-answer/</guid>
      <pubDate>Mon, 18 Aug 2014 16:00:00 GMT</pubDate>
      
      <description>在老赵的博客上看到这样一道题，觉得非常有意思，难度适中，非常适合作面试题。试着用自己的方法解释清楚这道题的解法。</description>
      
      
      
      <content:encoded><![CDATA[<div class="pdf-container" data-target="/assets/Split Nature Number.pdf" data-height="500px"></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/interview/">interview</category>
      
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/interview/split-nature-number-answer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从一道面试题看不同编程语言的表述能力</title>
      <link>http://hcoona.github.io/Tips/different-programming-languages/</link>
      <guid>http://hcoona.github.io/Tips/different-programming-languages/</guid>
      <pubDate>Sat, 02 Aug 2014 16:00:00 GMT</pubDate>
      
      <description>很多人都不明白，不同的编程语言具有不同的表述能力，这就是我们为什么有了汇编之后还需要更高级的编程语言。在软件规模愈发庞大的现在，C 和 C++ 语言表述能力的不足越发的明显了。我们应该尽可能的选用高级的编程语言完成我们的任务，在需要性能的地方，使用 Profiling，而不是在一开始就选用 C/C++ 这样的语言去工作。</description>
      
      
      
      <content:encoded><![CDATA[<p>很多人都不明白，不同的编程语言具有不同的表述能力，这就是我们为什么有了汇编之后还需要更高级的编程语言。在软件规模愈发庞大的现在，C 和 C++ 语言表述能力的不足越发的明显了。我们应该尽可能的选用高级的编程语言完成我们的任务，在需要性能的地方，使用 Profiling，而不是在一开始就选用 C&#x2F;C++ 这样的语言去工作。</p><p>最近一段时间，突然看到一个很吸引眼球的题，而这道题貌似 ThoughtWorks 也考过类似的内容。题目很简单，但是怎么写都让我觉得很别扭，知道有一天我用 DrRacket 写了一下，才恍然大悟。在没有模式匹配的语言中，这道题就是怎么写怎么别扭，没办法的。下面我们来分别比较一下 C 语言和 Scheme 这两种古老的语言的实现。</p><p>题目描述（大意）：</p><pre><code>依序遍历 0 到 100 闭区间内所有的正整数，如果该数字能被 3 整除，则输出该数字及 ‘*’ 标记；如果该数字能被 5 整除，则输出该数字及 ‘#’ 标记；如果该数字既能被 3 整除又能被 5 整除，则输出该数字及 ‘*#’ 标记。</code></pre><p>首先先看看 C 语言的常规实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*#&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d#&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ; <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略了 <code>main</code> 函数等关系不是很大的部分。我选择逻辑最清晰的两层 <code>if-else</code> 的方式，比起其他“聪明”的方法，可读性最高，逻辑最清晰，最省计算量，同时也最容易添加、修改程序逻辑。</p><p>我们再来看看 Scheme 的实现：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">#lang racket</span><br><span class="line">(<span class="name"><span class="built_in">require</span></span> math/number-theory)</span><br><span class="line">(<span class="name"><span class="built_in">require</span></span> racket/match)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">range-closed</span> from to [<span class="name">step</span> <span class="number">1</span>])</span><br><span class="line">  (<span class="name">range</span> from (<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> to) step))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">let</span></span> ([<span class="name">numbers</span> (<span class="name">range-closed</span> <span class="number">1</span> <span class="number">100</span>)])</span><br><span class="line">  (<span class="name">for</span> ([<span class="name">x</span> numbers])</span><br><span class="line">    (<span class="name">match</span> `(,(divides? <span class="number">3</span> x) . ,(divides? <span class="number">5</span> x))</span><br><span class="line">      [&#x27;(<span class="literal">#t</span> . <span class="literal">#t</span>) (<span class="name">printf</span> <span class="string">&quot;~A*#&quot;</span> x)]</span><br><span class="line">      [&#x27;(<span class="literal">#t</span> . <span class="literal">#f</span>) (<span class="name">printf</span> <span class="string">&quot;~A*&quot;</span> x)]</span><br><span class="line">      [&#x27;(<span class="literal">#f</span> . <span class="literal">#t</span>) (<span class="name">printf</span> <span class="string">&quot;~A#&quot;</span> x)]</span><br><span class="line">      [<span class="name"><span class="built_in">else</span></span> (<span class="name">void</span>)])))</span><br></pre></td></tr></table></figure><p>经过对比我们发现，Scheme 语言由于具备（由库提供）模式匹配功能，从而使得程序的逻辑较 C 语言清晰不止一筹。仔细的总结一下 Scheme 实现的优点：</p><ol><li>有意义明确的方法来产生一个闭区间的所有数字：<code>range-closed</code>；</li><li>无需手工确定闭区间的左右边界：<code>for</code> 循环；</li><li>有意义明确的方法表示整除：<code>divides?</code>；</li><li>有一致的命名规则表示返回布尔值的方法：后缀<code>?</code>；</li><li>通过模式匹配，判断了被 3 和 5 整除的所有情况，和该种情况下对应的动作：<code>&#39;(#t, #t) &#39;(#t, #f) &#39;(#f, #t) else</code>。</li></ol><p>我甚至还没有说 Scheme 中可以在方法中定义方法，而 C 语言不可以（GNU 扩展可以）；C 语言其他类型可以被直接当做布尔值使用，以至于发明出了 <code>NULL == ptr</code> 这样扭曲的表达方式（但是我估计这里没有人想用 <code>if (i % 3)</code> 吧？）。</p><p>这只是非常简单的一道练习题，就能够暴露出了 C&#x2F;C++ 语言的诸多弱点。我不是说 C&#x2F;C++ 语言一点好处都没有，但是绝大多数情况下，我们应该选用其他具有更强表达能力的语言。</p><p>珍爱生命，远离低级语言！</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/Tips/different-programming-languages/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>检查加法溢出的几种方法的比较</title>
      <link>http://hcoona.github.io/Tips/check-overflow-continued/</link>
      <guid>http://hcoona.github.io/Tips/check-overflow-continued/</guid>
      <pubDate>Wed, 19 Feb 2014 16:00:00 GMT</pubDate>
      
      <description>实际使用中会有需要提前检测出是否会发生算数溢出，C# 语言中提供了 checked 关键字来解决这一问题，C/C++ 语言又该怎样做呢？本文从汇编语句的层面，对几种检查加法溢出的方法进行了比较和分析。受实验环境和个人知识所限，本文的应用范围仅限于 X86-64 体系结构。</description>
      
      
      
      <content:encoded><![CDATA[<p>实际使用中会有需要提前检测出是否会发生算数溢出，C# 语言中提供了 checked 关键字来解决这一问题，C&#x2F;C++ 语言又该怎样做呢？本文从汇编语句的层面，对几种检查加法溢出的方法进行了比较和分析。受实验环境和个人知识所限，本文的应用范围仅限于 X86-64 体系结构。</p><p>但是需要注意的是，即便是其他的体系结构，也很有可能提供了类似的指令用于检测溢出位。[1]</p><p>为方便起见，下面讨论将以两个 32 bit 有符号整数的加法操作为例。对于无符号整数的操作，只需检查 Carry 位即可。[2]</p><p>本文中用到的方法有三种：</p><ol><li>使用嵌入汇编代码检查处理器的 Overflow 标记；</li><li>将 32 位加法转换为 64 位加法，然后再与 <code>INT_MAX</code> 或 <code>INT_MIN</code> 进行比较；</li><li>对运算结果所在的区间进行判断和验证。</li></ol><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><h3 id="嵌入汇编检查处理器-Overflow-标记"><a href="#嵌入汇编检查处理器-Overflow-标记" class="headerlink" title="嵌入汇编检查处理器 Overflow 标记"></a>嵌入汇编检查处理器 Overflow 标记</h3><p>该方法的理论基础是这样的：[3]</p><pre><code>The status register in a traditional processor design includes at least three central flags: Zero, Carry, and Overflow, which are set or cleared automatically as effects of arithmetic and bit manipulation operations.</code></pre><p>在 X86 体系结构中，我们可以利用这些标记来判断最近的一次算数操作是否发生了溢出。特别的，X86 提供了 <code>JO</code> 和 <code>JNO</code> 指令，根据 Overflow 标记进行条件跳转。[4]</p><p>可惜事情并不是总这么美好，有时编译器会使用 <code>LEA</code> 指令对算数操作进行优化。由于 <code>LEA</code> 指令不是一个算数操作指令，所以并不会设置 Overflow 标记，从而会令我们这种检测方式失效。一个折中的解决方法是，使用嵌入汇编指令，强制编译器生成 <code>ADD</code> 指令进行加法运算。</p><h3 id="将-32-位加法转换为-64-位加法，然后再与-INT-MAX-或-INT-MIN-进行比较"><a href="#将-32-位加法转换为-64-位加法，然后再与-INT-MAX-或-INT-MIN-进行比较" class="headerlink" title="将 32 位加法转换为 64 位加法，然后再与 INT_MAX 或 INT_MIN 进行比较"></a>将 32 位加法转换为 64 位加法，然后再与 <code>INT_MAX</code> 或 <code>INT_MIN</code> 进行比较</h3><p>显然，32 位加法操作至多可能生成 33 位的结果，X86 处理器中提供对 64 位整数运算的一些支持，因此我们可以使用 64 位整数运算进行计算，然后将运算结果与 32 位整数的边界值进行比较，从而判断溢出。</p><h3 id="对运算结果所在的区间进行判断和验证"><a href="#对运算结果所在的区间进行判断和验证" class="headerlink" title="对运算结果所在的区间进行判断和验证"></a>对运算结果所在的区间进行判断和验证</h3><p>由于补码的定义，导致一旦发生溢出，结果的区间是可以预先判断的。如果两个正整数相加发生了溢出，则结果一定小于其中任一操作数；如果两个负整数相加发生了溢出，则结果一定大于其中任一操作数。[5]</p><p>根据这一原理，我们可以对结果所在的区间进行验证，从而得知是否发生了溢出。</p><h2 id="实验代码简述"><a href="#实验代码简述" class="headerlink" title="实验代码简述"></a>实验代码简述</h2><p>为了最大程度发挥编译器优化的优势，我构造了以下代码用于实验：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">asm</span> (<span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span> (a)</span><br><span class="line">        : <span class="string">&quot;r&quot;</span> (a), <span class="string">&quot;r&quot;</span> (b));</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">goto</span> <span class="params">(<span class="string">&quot;jo %l0&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="comment">/* no output */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="comment">/* no input */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="comment">/* no clobber */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : OVERFLOW)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">OVERFLOW:</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">long</span> <span class="type">long</span>)a + (<span class="type">long</span> <span class="type">long</span>)b;</span><br><span class="line">    <span class="keyword">if</span> (tmp &lt;= (<span class="type">long</span> <span class="type">long</span>)INT_MAX &amp;&amp; tmp &gt;= (<span class="type">long</span> <span class="type">long</span>)INT_MIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = (<span class="type">int</span>)((<span class="type">unsigned</span> <span class="type">int</span>)a + (<span class="type">unsigned</span> <span class="type">int</span>)b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; a) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &lt;= <span class="number">0</span> &amp;&amp; tmp &gt; a) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T1</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add1</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T2</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add2</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">T3</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add3</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 <code>Add1</code>，<code>Add2</code> 和 <code>Add3</code> 方法分别对应上面提出的三种方法的 C 语言实现。使用 <code>inline</code> 标记指示编译器进行内联以进行更深层次的优化。其中 <code>Add2</code> 和 <code>Add3</code> 方法参考了微软的 SafeInt 库。[6]</p><p><code>T1</code>，<code>T2</code> 和 <code>T3</code> 方法分别对应了三个测试方法。此处没有直接为 <code>a</code> 和 <code>b</code> 指定一个值，而是使用 <code>scanf</code> 函数进行输入，以防止编译器在优化时直接进行离线计算，将生成的结果直接写入目标位置。</p><h2 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h2><p>我使用下面的语句生成汇编代码：</p><pre><code>gcc -O3 -march=native -S test.c -o test.s</code></pre><p>顺便说一下我的实验环境：</p><ul><li>CPU: Intel Core2 P7450</li><li>GCC: 4.8.2</li></ul><p>由于完整的代码比较长，这里只摘录部分关键代码。<code>T1</code> 生成的代码中，与 <code>Add1</code> 相关的代码（内联后）片段如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  movl 12(%rsp), %edx</span><br><span class="line">  movl 8(%rsp), %esi</span><br><span class="line">  addl %esi, %ecx</span><br><span class="line">  jo   .L26</span><br><span class="line">  # No Overflow</span><br><span class="line">.L26:</span><br><span class="line">  # Overflow</span><br></pre></td></tr></table></figure><p>很简单，这段汇编代码就是将 <code>scanf</code> 函数的结果存到寄存器中，然后执行 <code>addl</code> 运算，之后（根据溢出位的设置情况）进行条件跳转。</p><p><code>T2</code> 生成的代码中，与 <code>Add2</code> 相关的代码（内联后）片段如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  movl   12(%rsp), %edx</span><br><span class="line">  movl   $2147483648, %edi</span><br><span class="line">  movl   8(%rsp), %esi</span><br><span class="line">  movslq %edx, %rax</span><br><span class="line">  movslq %esi, %rcx</span><br><span class="line">  addq   %rax, %rcx</span><br><span class="line">  movl   $4294967295, %eax</span><br><span class="line">  addq   %rcx, %rdi</span><br><span class="line">  cmpq   %rax, %rdi</span><br><span class="line">  ja     .L30</span><br><span class="line">  # No Overflow</span><br><span class="line">.L30:</span><br><span class="line">  # Overflow</span><br></pre></td></tr></table></figure><p><code>movslq</code> 可以将 <code>long</code> 长度的数据移动并进行符号位扩展到 <code>quad</code> 长度的位置。这段代码首先将 <code>scanf</code> 的结果取出到 32 位寄存器 <code>edx</code> 和 <code>esi</code> 中，然后又分别将结果进行符号扩展并移动到 64 位寄存器 <code>rax</code> 和 <code>rcx</code> 中。接下来进行 64 位加法运算，结果保存在 <code>rcx</code> 寄存器中。然后编译器做了一个人脑看来相当复杂的优化，我证明了这个优化是正确的，但是不准备在这里详细展开。</p><p><code>T3</code> 生成的代码中，与 <code>Add3</code> 相关的代码（内联后）片段如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  movl8(%rsp), %esi</span><br><span class="line">  movl12(%rsp), %edx</span><br><span class="line">  testl%esi, %esi</span><br><span class="line">  leal(%rdx,%rsi), %ecx</span><br><span class="line">  js.L34</span><br><span class="line">  cmpl%ecx, %esi</span><br><span class="line">  jg.L45</span><br><span class="line">.L35:</span><br><span class="line">    # No Overflow</span><br><span class="line">.L34:</span><br><span class="line">  cmpl%ecx, %esi</span><br><span class="line">  jge.L35</span><br><span class="line">  movl%edx, %eax</span><br><span class="line">  shrl$31, %eax</span><br><span class="line">  testb%al, %al</span><br><span class="line">  je.L35</span><br><span class="line">.L36:</span><br><span class="line">    # Overflow</span><br><span class="line">.L45:</span><br><span class="line">  testl%edx, %edx</span><br><span class="line">  js.L35</span><br><span class="line">  jmp.L36</span><br></pre></td></tr></table></figure><p>不用分析也知道，这段代码比较复杂，运行效率不会比前两段代码效率更高。</p><h2 id="实验设计简述"><a href="#实验设计简述" class="headerlink" title="实验设计简述"></a>实验设计简述</h2><p>使用预先生成的随机数，分别调用 <code>Add1</code>，<code>Add2</code>，<code>Add3</code> 以及不检查溢出直接进行加法运算，统计时间性能。此时，需对这几个函数稍作修改，不能在发生溢出时调用 <code>exit</code> 函数，而是使用 <code>setjmp</code> 和 <code>longjmp</code> 进行处理。</p><p>主要代码如下：</p><p>（因本人工作平台迁移到 Windows，暂时无法进行实验，后面实验缺失）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] ARM Processors: Condition Codes 1: Condition Flags and Codes. July, 2010. <a href="http://community.arm.com/groups/processors/blog/2010/07/16/condition-codes-1-condition-flags-and-codes">http://community.arm.com/groups/processors/blog/2010/07/16/condition-codes-1-condition-flags-and-codes</a></p><p>[2] Ian! D. Allen. The CARRY flag and OVERFLOW flag in binary arithmetic. <a href="http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt">http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt</a></p><p>[3] Status register. <a href="http://en.wikipedia.org/wiki/Status_register">http://en.wikipedia.org/wiki/Status_register</a></p><p>[4] X86 instruction listings. <a href="http://en.wikipedia.org/wiki/X86_instruction_listings">http://en.wikipedia.org/wiki/X86_instruction_listings</a></p><p>[5] Randal E. Bryant and David R. O’Hallaron. Computer System: A Programmer’s Perspective, 2ed. Addison-Wesley. February 2010.</p><p>[6] SafeInt. <a href="http://safeint.codeplex.com/">http://safeint.codeplex.com/</a></p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      
      <comments>http://hcoona.github.io/Tips/check-overflow-continued/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>谈补码</title>
      <link>http://hcoona.github.io/Tips/twos-complement/</link>
      <guid>http://hcoona.github.io/Tips/twos-complement/</guid>
      <pubDate>Fri, 24 Jan 2014 16:00:00 GMT</pubDate>
      
      <description>现在一谈到补码，很多人都会立刻说补码就是反码加一，虽然没说错，但是却没说到点子上。我更希望能够听到有人说补码就是负数对应原码的表示方式。这篇文章主要论述补码的本质，以及有符号整数二进制表示的原因。</description>
      
      
      
      <content:encoded><![CDATA[<div class="pdf-container" data-target="/assets/Twos Complement.pdf" data-height="500px"></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Computer-System/">Computer System</category>
      
      
      <comments>http://hcoona.github.io/Tips/twos-complement/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用内嵌汇编检查溢出</title>
      <link>http://hcoona.github.io/Tips/check-overflow-via-inline-asm/</link>
      <guid>http://hcoona.github.io/Tips/check-overflow-via-inline-asm/</guid>
      <pubDate>Sun, 27 Oct 2013 16:00:00 GMT</pubDate>
      
      <description>在面试中经常考到，实际项目中也经常需要面临这样一个问题，即如何判断一个整数操作是否发生了溢出。C# 语言提供了 checked 关键字用于处理这一问题，在 C 语言中我们可以使用内嵌汇编语句来检查溢出。</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>在面试中经常考到，实际项目中也经常需要面临这样一个问题，即如何判断一个整数操作是否发生了溢出。C#语言提供了`checked`关键字用于处理这一问题，在C语言中我们可以使用内嵌汇编语句来检查溢出。</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>In computer processors, the overflow flag (sometimes called V flag) is usually a single bit in a system status register used to indicate when an arithmetic overflow has occurred in an operation, indicating that the signed two&#8217;s-complement result would not fit in the number of bits used for the operation (the ALU width).</p></div></blockquote></div><div class="paragraph"><p>C语言中不能够直接访问寄存器，但是可以通过内嵌汇编语言，来访问寄存器的值。不过这样做有一点缺陷是，汇编代码与计算机体系结构相关，在可移植性上需要更多考虑。</p></div><div class="paragraph"><p>经过查资料，在X86体系结构中，可以通过汇编指令`JO`和`JNO`来实现基于Overflow flag的条件跳转。JO (Jump on Overflow)意味着有溢出时跳转，JNO (Jump on Not Overflow)则反之。下面通过一个小例子来解释如何进行溢出检查。</p></div><div class="paragraph"><p>输入：一个符合`[+|-]?\n+`正则表达式的字符串。</p></div><div class="paragraph"><p>输出：输入的字符串是否可以转换为一个`int`型常量而不发生溢出。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="type">bool</span> <span class="title">TryParseInt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> *pn)</span></span><span class="function"></span>&#123;    <span class="type">bool</span> isAddOp = <span class="literal">true</span>;    <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span>) &#123;        str++;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) &#123;        isAddOp = <span class="literal">false</span>;        str++;    &#125;    <span class="type">int</span> n = <span class="number">0</span>;    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>) &#123;        n *= <span class="number">10</span>;        <span class="function">__asm__ <span class="title">goto</span> <span class="params">(<span class="string">&quot;jo %l0&quot;</span></span></span><span class="params"><span class="function">            : <span class="comment">/* no output */</span></span></span><span class="params"><span class="function">            : <span class="comment">/* no input */</span></span></span><span class="params"><span class="function">            : <span class="comment">/* no clobber */</span></span></span><span class="params"><span class="function">            : PARSE_INT_FAILD</span></span><span class="params"><span class="function">        )</span></span>;        <span class="keyword">if</span> (isAddOp) &#123;            n += *str - <span class="string">&#x27;0&#x27;</span>;        &#125; <span class="keyword">else</span> &#123;            n -= *str - <span class="string">&#x27;0&#x27;</span>;        &#125;        <span class="function">__asm__ <span class="title">goto</span> <span class="params">(<span class="string">&quot;jo %l0&quot;</span></span></span><span class="params"><span class="function">            : <span class="comment">/* no output */</span></span></span><span class="params"><span class="function">            : <span class="comment">/* no input */</span></span></span><span class="params"><span class="function">            : <span class="comment">/* no clobber */</span></span></span><span class="params"><span class="function">            : PARSE_INT_FAILD</span></span><span class="params"><span class="function">        )</span></span>;        str++;    &#125;    *pn = n;    <span class="keyword">return</span> <span class="literal">true</span>;PARSE_INT_FAILD:    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre></div></div><div class="sect1"><h2 id="_失效情况">失效情况</h2><div class="sectionbody"><div class="paragraph"><p>有时候编译器会使用`LEA`指令进行计算上的优化，由于`LEA`指令不会设置任何标志位，因此不能够使用`JO`来检测到运算溢出。</p></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/Tips/check-overflow-via-inline-asm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>重载和覆盖的区别</title>
      <link>http://hcoona.github.io/interview/the-differences-between-overloading-and-overriding/</link>
      <guid>http://hcoona.github.io/interview/the-differences-between-overloading-and-overriding/</guid>
      <pubDate>Mon, 07 Oct 2013 16:00:00 GMT</pubDate>
      
      <description>重载和覆盖是笔试和面试中经常考的两个概念。这两个概念从概念本身到实现机理都不相同，但是表现形式却有相似之处。本文从实现机理入手，深入讲解两者的不同之处。</description>
      
      
      
      <content:encoded><![CDATA[<style type="text/css">table {    margin: 0 auto;    text-align: center;    border-collapse: collapse;}td {    padding: 0 5px;}table, td, th {    border: 1px solid;}</style><p>重载(Overloading)和覆盖(Overriding)是笔试和面试中经常考的两个概念。这两个概念从概念本身到实现机理都不相同，但是表现形式却有相似之处。本文从实现机理入手，深入讲解两者的不同之处。</p><h2 id="重载和覆盖的概念"><a href="#重载和覆盖的概念" class="headerlink" title="重载和覆盖的概念"></a>重载和覆盖的概念</h2><p>重载(Overloading)主要指函数重载或方法重载。</p><pre><code>Function overloading or method overloading is a feature found in various programming languages such as Ada, C++, C#, D, and Java, that allows creating several methods with the same name which differ from each other in the type of the input and the output of the function. It is simply defined as the ability of one function to perform different tasks.</code></pre><p>覆盖(Overriding)则是面向对象技术中特有的一个概念。</p><pre><code>Method overriding, in object oriented programming, is a language feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its superclasses or parent classes. The implementation in the subclass overrides (replaces) the implementation in the superclass by providing a method that has same name, same parameters or signature, and same return type as the method in the parent class. The version of a method that is executed will be determined by the object that is used to invoke it. If an object of a parent class is used to invoke the method, then the version in the parent class will be executed, but if an object of the subclass is used to invoke the method, then the version in the child class will be executed. Some languages allow a programmer to prevent a method from beinMethod overriding, in object oriented programming, is a language feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by one of its superclasses or parent classes. The implementation in the subclass overrides (replaces) the implementation in the superclass by providing a method that has same name, same parameters or signature, and same return type as the method in the parent class. The version of a method that is executed will be determined by the object that is used to invoke it. If an object of a parent class is used to invoke the method, then the version in the parent class will be executed, but if an object of the subclass is used to invoke the method, then the version in the child class will be executed. Some languages allow a programmer to prevent a method from being overridden.g overridden.</code></pre><h2 id="重载和覆盖的实现方式"><a href="#重载和覆盖的实现方式" class="headerlink" title="重载和覆盖的实现方式"></a>重载和覆盖的实现方式</h2><p>这里主要讲述重载和覆盖在C++语言中的实现方式。主要参考资料为*The Design and Evolution of C++*中的第三章。</p><p>函数的重载是在编译时期确定的。几个不同的函数可以具有同样的名字，编译器通过调用参数类型的不同，来确认调用的函数；如果不能通过调用参数类型的不同来确认，编译器会报错。</p><p>方法的覆盖是在运行时期确定的。在C++语言中，父类中将允许覆盖的函数标记为虚函数，子类中严格使用与父类中标记为虚函数的函数相同的函数名、参数类型和返回值类型，重新定义这一函数，通过这样一种方式，来完成方法的覆盖。编译时期，编译器生成一个虚函数指针列表，在这一列表中，存储了所有的虚函数的定义的代码所在的位置。运行时期，通过虚函数列表指针来确定虚函数指针列表的位置，进而确定所调用的虚函数的定义的代码所在的位置。</p><p>假设有如下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MA</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MB</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MC</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MC</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，编译器将类<code>A</code>中三个方法的代码，以及类<code>B</code>中<code>MC</code>方法的代码放到代码段中，然后为类<code>A</code>和类<code>B</code>分别生成虚函数指针列表。类<code>A</code>或<code>B</code>的实例视分配方法而定，会分配到栈或者堆上。类<code>A</code>的实例的内存布局通常如下：</p><table><tbody><tr>    <td width="50%">vptr</td>    <td>a</td></tr><tr>    <td colspan="2">b</td></tr></tbody></table><p>其中<code>vptr</code>指向这样一个表格：</p><table><tbody><tr><td>A中MC方法的代码的地址</td></tr></tbody></table><p>而类<code>B</code>的实例的内存布局通常如下：</p><table><tbody><tr>    <td width="50%">a</td>    <td></td></tr><tr>    <td colspan="2">b</td></tr><tr><td>vptr</td><td>c</td></tr></tbody></table><p>其中<code>vptr</code>指向这样一个表格：</p><table><tbody><tr><td>B中MC方法的代码的地址</td></tr></tbody></table><h2 id="笔试、面试中常考的一类题型"><a href="#笔试、面试中常考的一类题型" class="headerlink" title="笔试、面试中常考的一类题型"></a>笔试、面试中常考的一类题型</h2><p>重载和覆盖的概念和实现方式斗截然不同，但是为什么笔试、面试的时候还经常考呢？主要是他们的表现形式比较相近，并且还有“函数隐藏”这个东西在捣乱。“函数隐藏”不是一个好的概念，我的观点是在任何时候都不要使用“函数隐藏”，并且在一些新型的语言中，也对“函数隐藏”作出了一定限制，比如说在C#语言中，必须使用<code>new</code>关键字标注，才能够使用“函数隐藏”。我之前也发过一篇文章讨论过“函数隐藏”的不必要性，<a href="http://www.cnblogs.com/HCOONa/archive/2010/07/11/member-function-hide-is-not-necessary.html">原文见此</a>。</p><p>先说一下函数隐藏，这是重载的一种特殊情况。如果在子类中定义了一个同父类中的方法具有完全相同的函数名、参数类型和返回值类型时，如果父类中的这一方法没有标记为虚方法，则会发生函数隐藏。在子类中，必须通过特殊的语法才能够调用父类中的同名方法。由于这是重载的一种特殊情况，调用这一函数时，判断还是发生在编译时期的。</p><p>下面来一个比较复杂的例子，也是笔试中比较容易考的类型：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MA</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MA</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MB</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MC</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MD</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MA</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MB</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MD</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">A a0;</span><br><span class="line">A a1 = <span class="built_in">B</span>();</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a0.<span class="built_in">MA</span>(<span class="number">0.5</span>);</span><br><span class="line">a1.<span class="built_in">MA</span>(<span class="number">0.5</span>);</span><br><span class="line">b.<span class="built_in">MA</span>(<span class="number">0.5</span>);</span><br><span class="line">a0.<span class="built_in">MB</span>(<span class="number">0.5</span>);</span><br><span class="line">a1.<span class="built_in">MB</span>(<span class="number">0.5</span>);</span><br><span class="line">b.<span class="built_in">MB</span>(<span class="number">0.5</span>);</span><br><span class="line">a0.<span class="built_in">MD</span>(<span class="number">0.5</span>);</span><br><span class="line">a1.<span class="built_in">MD</span>(<span class="number">0.5</span>);</span><br><span class="line">b.<span class="built_in">MD</span>(<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>问调用的这些函数分别是哪些函数？</p><p>首先呢<code>a0.MA(0.5)</code>和<code>a1.MA(0.5)</code>肯定调用的是<code>void A::MA(double)</code>，因为<code>MA</code>方法没有被声明为虚函数，因此在编译时期就可以确定应该调用的方法，由于在调用<code>MA</code>方法时，<code>a0</code>和<code>a1</code>声称自己类型都是<code>A</code>因此调用的是类<code>A</code>中的<code>MA</code>方法。而<code>b.MA(0.5)</code>调用的则是<code>void B::MA(double)</code>，因为基类<code>A</code>中的方法<code>void MA(double)</code>没有被声明为虚方法，因此要做静态判断。而<code>b</code>声称自己的类型是<code>B</code>，因此要调用<code>B</code>中的<code>MA</code>方法。</p><p>其次看<code>MB</code>这一组，由于只有一个<code>void A::MB(double)</code>函数定义，因此调用的都是这个函数。</p><p>最后看<code>MD</code>这一组。由于基类<code>A</code>中声明<code>MD</code>方法为虚函数，因此需要动态判断。<code>a0</code>在运行时期的类型就是<code>A</code>，因此调用的是<code>void A::MD(double)</code>。<code>a1</code>在运行时期的类型是<code>B</code>，因此调用的是<code>void B::MD(double)</code>。<code>b</code>在运行时期的类型是<code>B</code>，因此调用的是<code>void B::MD(double)</code>。</p><p>只要掌握好原理，牢记重载就看静态类型，覆盖就看动态类型，就能准确的判断调用的函数到底是哪一个了。</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/interview/">interview</category>
      
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/interview/the-differences-between-overloading-and-overriding/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面向对象技术中的三大特征</title>
      <link>http://hcoona.github.io/interview/three-characteristics-of-object-oriented-programming/</link>
      <guid>http://hcoona.github.io/interview/three-characteristics-of-object-oriented-programming/</guid>
      <pubDate>Sun, 06 Oct 2013 16:00:00 GMT</pubDate>
      
      <description>面试中经常会问面向对象技术中的三大特征，但是却没有一本书把这三个特征讲透彻，这里尝试综合几本书中的内容，从不同角度理解这三大特征。</description>
      
      
      
      <content:encoded><![CDATA[<p>面试中经常会问面向对象技术中的三大特征，但是却没有一本书把这三个特征讲透彻，这里尝试综合几本书中的内容，从不同角度理解这三大特征。</p><p>现在一般认为，面向对象技术中的三大特征分别是：封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）。</p><p>老实说，我不知道这个答案是怎么出来的，为此我特意在Google和各大学术搜索引擎上找了半天，也没找到出处；反倒是<a href="https://en.wikipedia.org/wiki/Object-oriented_programming#Fundamental_features_and_concepts">维基百科</a>，给出了几大特性，还有出处。</p><pre><code>Benjamin C. Pierce and some other researchers view any attempt to distill OOP to a minimal set of features as futile. He nonetheless identifies fundamental features that support the OOP programming style in most object-oriented languages:- Dynamic dispatch – when a method is invoked on an object, the object itself determines what code gets executed by looking up the method at run time in a table associated with the object. This feature distinguishes an object from an abstract data type (or module), which has a fixed (static) implementation of the operations for all instances. It is a programming methodology that gives modular component development while at the same time being very efficient.- Encapsulation (or multi-methods, in which case the state is kept separate)- Subtype polymorphism- Object inheritance (or delegation)- Open recursion – a special variable (syntactically it may be a keyword), usually called this or self, that allows a method body to invoke another method body of the same object. This variable is late-bound; it allows a method defined in one class to invoke another method that is defined later, in some subclass thereof.Similarly, in his 2003 book, Concepts in programming languages, John C. Mitchell identifies four main features: dynamic dispatch, abstraction, subtype polymorphism, and inheritance. Michael Lee Scott in Programming Language Pragmatics considers only encapsulation, inheritance and dynamic dispatch.</code></pre><p>既然如此，我就不讨论其出处和最初解释了，直接解释封装、继承和多态这三个概念，以免面试官以为我不懂面向对象技术。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装的主要意义是可以限制对于对象内容的访问。在C++中，有三种（不算友元的话）访问级别：public、protected和private。在Java、C#或其他语言中，可能还会有更加细致的访问控制方式。</p><p>这种对于对象内部访问的控制，有两点好处：</p><ol><li>可以保护内部数据不被意外修改。</li><li>可以对外隐藏内部实现细节，待以后需要修改实现方法时，不会破坏其他已有代码。</li></ol><p>下面举例说明这两点。</p><p>首先，看看没有面向对象技术的C语言如何实现一个栈：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE_MAX 10000</span></span><br><span class="line"><span class="type">int</span> stack[STACK_SIZE_MAX];</span><br><span class="line"><span class="type">int</span> stackTop = <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_STACK(x) (stack[stackTop++]=(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOP_STACK() (stack[stackTop-1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_STACK() (stack[--stackTop])</span></span><br></pre></td></tr></table></figure><p>可谓短小精悍，但是这段代码有几个问题：</p><ol><li>只能存储<code>int</code>类型。</li><li>只有一个栈。</li><li>线程不安全。</li><li>栈的大小有限。</li><li><code>stack</code>变量和<code>stackTop</code>变量有可能被意外或者有意的修改。</li></ol><p>第一个问题，即使是使用面向对象技术，也不能解决，而是通过泛型解决的。当然了，如果不考虑类型安全性，也可以使用<code>void *</code>类型存储。对于第二个问题，通常是采用模仿面向对象技术的方式来实现的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> stack_item_type;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stack_struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    stack_item_type * stack;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stack_struct</span> * stack_type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> stack_type <span class="title">new_stack_ex</span><span class="params">(<span class="type">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack_type stack = (stack_type)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> stack_struct));</span><br><span class="line">    stack-&gt;capacity = capacity;</span><br><span class="line">    stack-&gt;top = <span class="number">0</span>;</span><br><span class="line">    stack-&gt;stack = (stack_item_type *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(stack_item_type) * capacity);</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">delete_stack_ex</span><span class="params">(stack_type stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(stack-&gt;stack);</span><br><span class="line">    <span class="built_in">free</span>(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_stack_ex</span><span class="params">(stack_type stack, stack_item_type item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack-&gt;stack[stack-&gt;top++] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> stack_item_type <span class="title">top_stack_ex</span><span class="params">(stack_type stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack-&gt;stack[stack-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_stack_ex</span><span class="params">(stack_type stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack-&gt;top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着这样一种解决方式，问题二三四也都解决了。但是最后一个问题，必须要语言提供隐藏信息的机制支持，才能够解决。这就是C++引入的信息隐藏机制所解决的问题，即信息的封装。且看C++语言中如何实现一个栈：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> STACK_CAPACITY = <span class="number">10000</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">Push</span>(T item) &#123; stack[top++] = item; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">Top</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> stack[top - <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; top--; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> stack[STACK_CAPACITY];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">void</span>) : <span class="built_in">top</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过将<code>stack</code>变量和<code>top</code>变量的访问级别设为<code>private</code>，使得除了<code>Stack</code>类中的成员函数，没有任何方法能够访问这两个变量，有效的防止了意外的修改导致非预期结果。</p><p>另一方面，通过限制<code>Stack</code>中内容的访问，使得调用者只能通过<code>Stack</code>类中所公布的共有方法进行访问，又对<code>Stack</code>类的实现进行了抽象。这里相当于在调用者和实现者之间建立了一个接口（契约），使得双方达成了一种共识。这样带来一个额外的好处，只要接口不发生改变，一个类的内部实现可以任意变化。例如实现者认为使用数组实现的栈对象太浪费内存了，不如使用单链表实现，于是修改了实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    std::shared_ptr&lt;ListNode&gt; next;</span><br><span class="line">    <span class="built_in">ListNode</span>(T data, std::shared_ptr&lt;ListNode&gt; next)</span><br><span class="line">        : <span class="built_in">data</span>(data), <span class="built_in">next</span>(next)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Push</span><span class="params">(T item)</span> </span>&#123; list = std::make_shared&lt;ListNode&lt;T&gt;&gt;(item, list); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">Top</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> list-&gt;data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; list = list-&gt;next; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;ListNode&lt;T&gt;&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">void</span>) : <span class="built_in">list</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于对外开放的接口没有发生任何变化，所有<code>Stack</code>类的调用者都不需修改代码，这一点是C语言等没有提供这样强的封装机制的语言所无法实现的。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承最初的用意是直接复用父类中所写的代码，但是人们很快发现，仅仅是使用继承去复用代码，很容易造成更大的混乱，必须对此加以限制，这一限制就是里氏替换原则。里氏替换原则的内容可以描述为：“派生类（子类）对象能够替换其基类（超类）对象被使用。”以上内容并非利斯科夫的原文，而是译自罗伯特·马丁（Robert Martin）对原文的解读。这是一种符合直觉的限制，如果在用到父类型的地方不能够替换成子类型使用，说明这两个类不应该具有继承关系，即子类应该是一个（is-a）父类的特例。</p><p>下面说一个违反直觉的例子，这是一个不好的例子，只是为了说明问题而构造出来的例子，大家不要模仿这个例子。</p><p>直觉上，正方形是长方形的一种特例，因此应该让正方形继承自长方形。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getWidth</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getHeight</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> height; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">        : <span class="built_in">width</span>(width), <span class="built_in">height</span>(height)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">int</span> sideLength) : <span class="built_in">base</span>(sideLength, sideLength) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种情况下，任何使用到<code>Rectangle</code>的地方，都可以使用<code>Square</code>。但是假设<code>Rectangle</code>类还有两个成员函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> width)</span> </span>&#123; <span class="keyword">this</span>-&gt;width = width; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> height)</span> </span>&#123; <span class="keyword">this</span>-&gt;height = height; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> width)</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">setSideLength</span>(width); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> height)</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">setSideLength</span>(height); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSideLength</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        width = length;</span><br><span class="line">        height = length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则<code>Square</code>类不应该继承自<code>Rectangle</code>类，因为<code>Square</code>类处理改变宽和高的逻辑与<code>Rectangle</code>截然不同，并非对原有功能的扩充。这样一来，原本使用<code>Rectangle</code>的代码，如果使用的是<code>Square</code>，则有可能出现非预期的结果，例如这样的测试用例在传入的对象是一个<code>Square</code>的实例的时候，就会失败：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestArea</span><span class="params">(Rectangle &amp;rectangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> deltaWidth = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> originArea = rectangle.<span class="built_in">getArea</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> exceptedArea = originArea + deltaWidth * rectangle.<span class="built_in">getHeight</span>();</span><br><span class="line"></span><br><span class="line">    rectangle.<span class="built_in">setWidth</span>(rectangle.<span class="built_in">getWidth</span>() + deltaWidth);</span><br><span class="line">    <span class="type">int</span> actualArea = rectangle.<span class="built_in">getArea</span>();</span><br><span class="line">    <span class="built_in">TEST_ASSERT_EQUAL</span>(exceptedArea, actualArea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为原本长方形的长和宽可以被独立的改变，而正方形的要求更加严格，从而导致了对于里氏替换原则的违反。</p><p>对于支持逆变和协变，以及异常的语言，要求：</p><ul><li>子类中，方法的参数必须是逆变的。</li><li>子类中，方法的返回值必须是协变的。</li><li>如果父类中的方法没有抛出异常，那么子类中的该方法也不应抛出异常。</li><li>如果父类中的方法抛出了异常，那么子类中的该方法可以抛出该异常的子类异常。</li></ul><p>除此之外，子类的设计还应该遵循以下一般原则：</p><ul><li>子类中，前置条件不能被强化。</li><li>子类中，后置条件不能被弱化。</li><li>子类中，必须遵守父类中的不变式。</li><li>子类中如果引入了父类中不存在的方法，则不得通过这些方法改变继承自父类的状态。</li></ul><p>上面长方形正方形的例子，就是违反了后置条件不能被弱化的原则。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态（特指面向对象技术中的术语“多态”）是这样一种技术：直到运行时期，才确定被调用的方法应该执行的代码。</p><p>通常，在C&#x2F;C++、Java、C#这一类语言中，执行的代码是在编译期间就确定的，这被称为“早绑定”。编译器知道被调用的函数所在的位置，因此在调用这一函数时，直接将参数按照调用约定压栈，然后跳转到该函数所在的位置继续执行即可。但是多态可以延迟这一过程，直到运行时期，程序才知道调用的函数的代码的真正位置。由于执行的代码实在运行时期才确定的，这又被称为“晚绑定”。很多动态语言默认就是“晚绑定”的。</p><p>多态和继承的关系非常密切。在C++语言中，只有在父类中声明为虚函数的函数，才能在子类中被覆盖（Override），从而实现多态。</p><p>多态的好处在于，我们可以在不修改现有代码的基础上，扩充功能。还用上面栈的代码做例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Push</span><span class="params">(T)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">Top</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> CAPACITY&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> : <span class="keyword">public</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Push</span><span class="params">(T item)</span> <span class="keyword">override</span> </span>&#123; stack[top++] = item; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">Top</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> stack[top - <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; top--; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T stack[CAPACITY];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayStack</span>(<span class="type">void</span>) : <span class="built_in">top</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span> : <span class="keyword">public</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Push</span><span class="params">(T item)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list = std::make_shared&lt;ListNode&lt;T&gt;&gt;(item, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">Top</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> list-&gt;data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; list = list-&gt;next; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;ListNode&lt;T&gt;&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedListStack</span>(<span class="type">void</span>) : <span class="built_in">list</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在使用的时候，比如说有这样一个函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushZero</span><span class="params">(Stack&lt;<span class="type">int</span>&gt; &amp;stack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack.<span class="built_in">Push</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里调用的<code>Push</code>函数是哪个函数呢？首先肯定不是<code>Stack</code>类中的<code>Push</code>函数，因为<code>Stack</code>是个纯虚类，其<code>Push</code>方法根本就没有实现。其次，就要看传给这一函数的参数，其运行时期的真正类型是什么。如果传进来的<code>stack</code>变量是<code>ArrayStack</code>类型的，那么调用的就是<code>ArrayStack</code>类中的<code>Push</code>方法，如果传进来的是<code>LinkedListStack</code>类型的，那么调用的就是<code>LinkedListStack</code>中的<code>Push</code>方法。如果我们实现了另一个类，比如是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VectorStack</span> : <span class="keyword">public</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Push</span><span class="params">(T item)</span> <span class="keyword">override</span> </span>&#123; stack.<span class="built_in">push_back</span>(item); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">Top</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> stack.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; stack.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么如果传给<code>PushZero</code>的参数<code>stack</code>是<code>VectorStack</code>类型的，那么调用的就是<code>VectorStack</code>中的<code>Push</code>方法。注意，我们实现并不知道还会有<code>VectorStack</code>这样一个类，但是在之后，我们为了扩充<code>Stack</code>类的功能，新写了这样一个类，却没有修改<code>PushZero</code>函数中的任何代码，就可以发挥<code>VectorStack</code>类的作用。</p><p>C++语言中实现这一功能是采用的虚函数列表的方式，具体情况参见*The Design and Evolution of C++*中的3.5 Virtual Functions。</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/interview/">interview</category>
      
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/interview/three-characteristics-of-object-oriented-programming/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>一道面试题的多种解法</title>
      <link>http://hcoona.github.io/interview/different-solutions-to-an-interview-problem/</link>
      <guid>http://hcoona.github.io/interview/different-solutions-to-an-interview-problem/</guid>
      <pubDate>Wed, 04 Sep 2013 16:00:00 GMT</pubDate>
      
      <description>一棵二叉搜索树中，有一个节点不满足二叉搜索树的性质，找出这一节点。</description>
      
      
      
      <content:encoded><![CDATA[<p>一棵二叉搜索树中，有一个节点不满足二叉搜索树的性质，找出这一节点。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>先说一下二叉搜索树的性质：</p><ol><li>若它的左子树不为空，则左子树上的所有节点的值均小于它的根节点的值。</li><li>若它的右子树不为空，则右子树上的所有节点的值均大于它的跟节点的值。</li><li>它的左右子树也分别为一棵二叉搜索树。</li></ol><p>如果直接递归地判断二叉搜索树中的每一节点是否满足上述性质，固然可以解决问题，但是效率却出奇的低。实际上，中序遍历一棵二叉搜索树得到的结果，恰为一个升序序列。只需检查这一序列中不满足升序的元素，就可以找出二叉搜索树中不符合上述性质的节点。</p><p>因此，首先需要解决的问题就是二叉树的中序遍历。</p><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>根据二叉树的定义，我们可以建立这样的数据结构：</p><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="symbol">&#x27;a</span> btree =</span><br><span class="line">    | <span class="type">Nil</span></span><br><span class="line">    | <span class="type">Node</span> <span class="keyword">of</span> (<span class="symbol">&#x27;a</span> * <span class="symbol">&#x27;a</span> btree * <span class="symbol">&#x27;a</span> btree)</span><br><span class="line">;;</span><br></pre></td></tr></table></figure><p>对于这样的数据结构，我们只需要考虑两种情况：</p><ol><li>当前节点为<code>Nil</code>。</li><li>当前节点为<code>Node</code>。</li></ol><p>对应的中序遍历程序如下：</p><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> to_inorder tree =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> aux tree ls =</span><br><span class="line">        <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Nil</span> -&gt; ls</span><br><span class="line">        | <span class="type">Node</span> (d, l, r) -&gt; aux l (d :: (aux r ls))</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    aux tree <span class="literal">[]</span></span><br><span class="line">;;</span><br></pre></td></tr></table></figure><p>或者用我们熟悉的C++语言表示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">btree</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    btree *left;</span><br><span class="line">    btree *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToInOrder</span><span class="params">(btree&lt;T&gt; *node, std::vector&lt;T&gt; &amp;container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="built_in">ToInOrder</span>(node-&gt;left, container);</span><br><span class="line">        container.<span class="built_in">push_back</span>(node-&gt;data);</span><br><span class="line">        <span class="built_in">ToInOrder</span>(node-&gt;right, container);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过二叉树中序遍历，我们可以得到所需的序列，然后检查这一序列，就可以找到不符合二叉搜索树性质的节点了。</p><h2 id="只用O-1-的空间"><a href="#只用O-1-的空间" class="headerlink" title="只用O(1)的空间"></a>只用O(1)的空间</h2><p>之前所述的方法，需要O(n)的空间存放中序遍历的结果，但是实际上我们并不需要这一序列，而是只需要序列中的前一个元素的值即可。或者更进一步的，我们在中序遍历二叉搜索树的时候，如果能够知道当前节点的上一个节点，就可以验证该节点是否符合二叉搜索树的性质。</p><p>为了做到这一点，我们需要知道一棵子树的最后一个节点。这样，根节点的上一个节点就是左子树的最后一个节点，右子树的上一个节点就是根节点，左子树的上一个节点就是当前子树的上一个节点。</p><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> check tree =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> do_check tree previousNode =</span><br><span class="line">        <span class="keyword">let</span> latest tree =</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">rec</span> latest_aux tree parentNode =</span><br><span class="line">                <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">                | <span class="type">Nil</span> -&gt; parentNode</span><br><span class="line">                | <span class="type">Node</span> (_, _, r) -&gt; latest_aux r tree</span><br><span class="line">            <span class="keyword">in</span></span><br><span class="line">            latest_aux tree <span class="type">Nil</span></span><br><span class="line">        <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">rec</span> check_current_right currentNode previousNode =</span><br><span class="line">            <span class="keyword">match</span> currentNode <span class="keyword">with</span></span><br><span class="line">            | <span class="type">Nil</span> -&gt; <span class="type">Nil</span></span><br><span class="line">            | <span class="type">Node</span> (d, _, r) -&gt; <span class="keyword">match</span> previousNode <span class="keyword">with</span></span><br><span class="line">                                | <span class="type">Nil</span> -&gt; do_check r currentNode</span><br><span class="line">                                | <span class="type">Node</span> (pd, _, _) -&gt; <span class="keyword">if</span> pd &gt;= d <span class="keyword">then</span></span><br><span class="line">                                                        currentNode</span><br><span class="line">                                                     <span class="keyword">else</span></span><br><span class="line">                                                        do_check r currentNode</span><br><span class="line">        <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Nil</span> -&gt; <span class="type">Nil</span></span><br><span class="line">        | <span class="type">Node</span> (_, <span class="type">Nil</span>, _) -&gt; check_current_right tree previousNode</span><br><span class="line">        | <span class="type">Node</span> (_, l, _) -&gt; <span class="keyword">match</span> (do_check l previousNode) <span class="keyword">with</span></span><br><span class="line">                            | <span class="type">Nil</span> -&gt; check_current_right tree (latest l)</span><br><span class="line">                            | <span class="type">Node</span> _ <span class="keyword">as</span> ill_node -&gt; ill_node</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    do_check tree <span class="type">Nil</span></span><br><span class="line">;;</span><br></pre></td></tr></table></figure><p>但是实际上，我们在遍历左子树的同时，就能知道左子树的最后一个节点是谁，因此，稍作修改就可以抛弃<code>latest</code>函数。</p><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> check tree =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> do_check tree previousNode =</span><br><span class="line">        <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Nil</span> -&gt; (<span class="literal">true</span>, previousNode)</span><br><span class="line">        | <span class="type">Node</span> (d, l, r) -&gt;</span><br><span class="line">            <span class="keyword">let</span> (l_valid, l_node) = do_check l previousNode <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> l_valid <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">match</span> l_node <span class="keyword">with</span></span><br><span class="line">                | <span class="type">Nil</span> -&gt; do_check r tree</span><br><span class="line">                | <span class="type">Node</span> (pd, _, _) -&gt; <span class="keyword">if</span> pd &gt;= d <span class="keyword">then</span></span><br><span class="line">                                        (<span class="literal">false</span>, tree)</span><br><span class="line">                                     <span class="keyword">else</span></span><br><span class="line">                                        do_check r tree</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                (l_valid, l_node)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">match</span> (do_check tree <span class="type">Nil</span>) <span class="keyword">with</span></span><br><span class="line">    | (<span class="literal">true</span>, _) -&gt; <span class="type">Nil</span></span><br><span class="line">    | (<span class="literal">false</span>, n) -&gt; n</span><br><span class="line">;;</span><br></pre></td></tr></table></figure><p>对应的C++语言代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">static</span> std::tuple&lt;<span class="type">bool</span>, btree&lt;T&gt; *&gt; <span class="built_in">DoCheck</span>(btree&lt;T&gt; *tree, btree&lt;T&gt; *previousNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree) &#123;</span><br><span class="line">        <span class="type">bool</span> leftValid;</span><br><span class="line">        btree&lt;T&gt; *leftInvalidNode;</span><br><span class="line">        std::<span class="built_in">tie</span>(leftValid, leftInvalidNode) = <span class="built_in">DoCheck</span>&lt;T&gt;(tree-&gt;left, previousNode);</span><br><span class="line">        <span class="keyword">if</span> (leftValid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftInvalidNode) &#123;</span><br><span class="line">                <span class="keyword">if</span> (leftInvalidNode-&gt;data &gt;= tree-&gt;data) &#123;</span><br><span class="line">                    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="literal">false</span>, tree);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">DoCheck</span>&lt;T&gt;(tree-&gt;right, tree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">DoCheck</span>&lt;T&gt;(tree-&gt;right, tree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(leftValid, leftInvalidNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="literal">true</span>, previousNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> btree&lt;T&gt; * <span class="title">Check</span><span class="params">(btree&lt;T&gt; *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> valid;</span><br><span class="line">    btree&lt;T&gt; *invalidNode;</span><br><span class="line">    std::<span class="built_in">tie</span>(valid, invalidNode) = <span class="built_in">DoCheck</span>&lt;T&gt;(tree, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invalidNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这样的代码比起一开始的中序遍历代码要复杂太多了。那么如何既享受中序遍历代码的简洁，又实现这样的复杂功能呢？</p><h2 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h2><p>有的人认为，纯函数不应该具有状态。我并不认同这一看法，只要函数对于给定的输入必然给出同样的输出，那么这就是一个纯函数。适当的情况下，引入状态可以极大的简化程序的设计。对于上面提出的问题，我们只需引入状态，存储之前访问的节点的值，就可以使用非常少的代码解决问题。</p><p>最直接的想法如下：</p><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> check tree =</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">ref</span> <span class="type">Nil</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">ref</span> <span class="type">Nil</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> check_aux tree =</span><br><span class="line">        <span class="keyword">match</span> tree <span class="keyword">with</span></span><br><span class="line">        | <span class="type">Nil</span> -&gt; <span class="literal">()</span></span><br><span class="line">        | <span class="type">Node</span> (d, l, r) -&gt; check_aux l;</span><br><span class="line">                            <span class="keyword">match</span> !p <span class="keyword">with</span></span><br><span class="line">                            | <span class="type">Node</span> (pd, _, _) <span class="keyword">when</span> pd &gt;= d -&gt; i := tree</span><br><span class="line">                            | _ -&gt; p := tree; check_aux r</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    check_aux <span class="type">Nil</span>;</span><br><span class="line">    !i</span><br><span class="line">;;</span><br></pre></td></tr></table></figure><p>转化成C++语言的代码就有点麻烦了。C++语言标准不允许嵌套定义函数，因此比较直接的想法是使用全局变量：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> btree&lt;<span class="type">int</span>&gt; *previousNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> btree&lt;<span class="type">int</span>&gt; *<span class="title">DoCheck</span><span class="params">(btree&lt;<span class="type">int</span>&gt; *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree) &#123;</span><br><span class="line">        btree&lt;<span class="type">int</span>&gt; *r = <span class="built_in">DoCheck</span>(tree-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (r) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (previousNode &amp;&amp; previousNode-&gt;data &gt;= tree-&gt;data) &#123;</span><br><span class="line">                <span class="keyword">return</span> tree;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                previousNode = tree;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">DoCheck</span>(tree-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> btree&lt;<span class="type">int</span>&gt; *<span class="title">Check</span><span class="params">(btree&lt;<span class="type">int</span>&gt; *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    previousNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DoCheck</span>(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用全局变量会引起两个问题。第一个问题是，线程不安全；第二个问题是，全局变量不能是泛型的。第一个问题可以通过添加关键字<code>thread_local</code>来解决，但是第二个问题怎么办？我们可以模仿闭包的思想，使用仿函数将函数和数据捆绑到一起，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBinarySearchTreeFunctor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> btree&lt;T&gt; * <span class="title">operator</span><span class="params">()</span> <span class="params">(btree&lt;T&gt; *tree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        previousNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DoCheck</span>(tree);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">thread_local</span> btree&lt;T&gt; *previousNode;</span><br><span class="line">    <span class="function">btree&lt;T&gt; * <span class="title">DoCheck</span><span class="params">(btree&lt;T&gt; *tree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了不在每次使用仿函数的时候都创建一个新对象，我们还可以为该仿函数类添加单例模式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckBinarySearchTreeFunctor</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> CheckBinarySearchTreeFunctor instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CheckBinarySearchTreeFunctor CheckBinarySearchTreeFunctor::instance;</span><br></pre></td></tr></table></figure><p>难道这就是我们的终极解决方案了吗？</p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>上面的解决方案已经相当完美了，但是还不是终极的解决方案。为什么这么说呢？因为上面的方法将二叉树中序遍历的普遍算法和判定二叉搜索树是否正确这一特殊算法混在了一起，虽然后者应用了前者，但是却不能复用前者的算法，而是自己又实现了一遍。这使得我发现这一算法还有改进的余地。</p><p>想想STL里面的<code>for_each</code>函数，可以在遍历一个数据结构的时候，执行某一动作。参考这一点，我本应该给二叉树添加上中序遍历的迭代器的，不过这对于一个面试题而言就太重量级了，不如直接改造中序遍历的函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderVisit</span><span class="params">(btree&lt;T&gt; *tree, std::function&lt;<span class="type">void</span>(btree&lt;T&gt;*)&gt; action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree) &#123;</span><br><span class="line">        <span class="built_in">InOrderVisit</span>(tree-&gt;left, action);</span><br><span class="line">        <span class="built_in">action</span>(tree);</span><br><span class="line">        <span class="built_in">InOrderVisit</span>(tree-&gt;right, action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，判断二叉搜索树是否合法的函数就可以写成这样了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">btree&lt;T&gt; *<span class="title">Check</span><span class="params">(btree&lt;T&gt; *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    btree&lt;T&gt; *previousNode = <span class="literal">nullptr</span>;</span><br><span class="line">    btree&lt;T&gt; *invalidNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">InOrderVisit</span>(tree, [&amp;](btree&lt;T&gt; *node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (previousNode &amp;&amp; previousNode-&gt;data &gt;= node-&gt;data) &#123;</span><br><span class="line">            invalidNode = node;</span><br><span class="line">        &#125;</span><br><span class="line">        previousNode = node;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> invalidNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的<code>ToInOrder</code>方法也可以写成这样：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::vector&lt;T&gt; <span class="title">ToInOrder</span><span class="params">(<span class="type">const</span> btree&lt;T&gt; *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;T&gt; container;</span><br><span class="line">    <span class="built_in">InOrderVisit</span>(tree, [&amp;container](<span class="type">const</span> btree&lt;T&gt; *node) &#123;</span><br><span class="line">        container.<span class="built_in">push_back</span>(node-&gt;data);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/interview/">interview</category>
      
      
      <category domain="http://hcoona.github.io/tags/Interview/">Interview</category>
      
      
      <comments>http://hcoona.github.io/interview/different-solutions-to-an-interview-problem/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Solution to POJ 1061</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1061/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1061/</guid>
      <pubDate>Mon, 12 Aug 2013 16:00:00 GMT</pubDate>
      
      <description>将问题转换为二元线性丢番图方程，然后运用扩展欧几里德算法求解。</description>
      
      
      
      <content:encoded><![CDATA[<p>将问题转换为二元线性丢番图方程，然后运用扩展欧几里德算法求解。</p><p>原题链接：<a href="http://poj.org/problem?id=1061">POJ 1061 青蛙的约会</a>。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>题目相当于在GF(L)上的追及问题，但是又跟传统的追及问题有少许不同。传统的这类追及问题是在环形跑道上两个人同向跑步，只要两个人的速度不同，总有追上的时候。但是青蛙约会这一问题不一样，青蛙每次跳动是离散的运动，而不像人跑步是连续运动。这就使得，即使两只青蛙的速度不同，也有可能无法相遇，例如x&#x3D;1，y&#x3D;2，m&#x3D;2，n&#x3D;4，L&#x3D;4时，两只青蛙就永远都不会相遇。另一方面，环形跑道跑步的问题中，如果速度快的人在后面，则追及距离就是他们之间的距离，否则追及距离就是跑道长度减去它们之间的距离。但是青蛙约会问题不同，追及距离并不能够确定，因为有可能在下一个连续运动的相遇点他们都无法相遇，这使得问题大为复杂。这两点不同，使得我们不能够用传统追及问题的解决方法来解这道题。</p><h2 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h2><p>既然无法用追及问题的解决方案，我们就只能用“笨办法了”。首先，把所有的已知条件利用起来，可以得到如下等式（其中x，y，m，n，L均为整数常数）：</p><p>$$x+mk \equiv y+nk \pmod{L}, k \in \mathbb{Z}$$</p><p>经过一定变换，可以得到这样的等式：</p><p>$$(m-n)k+Lq&#x3D;y-x, k,q\in\mathbb{Z}$$</p><p>我们要求的则是k的最小正整数解。</p><p>做变换$a&#x3D;m-n，b&#x3D;L，c&#x3D;y-x，x&#x3D;k，y&#x3D;q$则上述二元一次不定方程可以表示为如下形式：</p><p>$$ax+by&#x3D;c$$</p><p>根据<a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">裴蜀定理</a>，当且仅当$gcd(a,b) | c$时，方程有解，且有无穷多组解。此时，若有一组特解$x_0$，$y_0$，则通解为：</p><p>$$x&#x3D;x_0+b&#x2F;d*t,y&#x3D;y_0-a&#x2F;d*t$$</p><p>其中t是整数。</p><p>我们想要求x的最小正整数解，不妨设$x&gt;&#x3D;0$，则如果$b&#x2F;d&gt;0$，$t&lt;&#x3D;-x_0*d&#x2F;b$，否则$t&gt;&#x3D;-x_0*d&#x2F;b$。</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = m - n, b = L, c = y - x;</span><br><span class="line"><span class="type">int</span> x0, gcd;</span><br><span class="line"><span class="built_in">tie</span>(x0, ignore, gcd) = <span class="built_in">Extended_GCD</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (a &amp;&amp; (c % gcd == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> scale = c / gcd;</span><br><span class="line">    <span class="type">double</span> t = -<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x0) * c / b;</span><br><span class="line">    <span class="type">int</span> x = x0 * scale + b / gcd * <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(t));</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x + b / gcd) : x;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c % L == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> INVALID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果$b&#x2F;d&gt;0$，则$t&lt;&#x3D;-x_0*d&#x2F;b$，使用<code>floor</code>函数就是正确的；否则$t&gt;&#x3D;-x_0*d&#x2F;b$，应该使用<code>ceil</code>函数，但是由于<code>ceil</code>函数的结果和<code>floor</code>函数的结果只差<code>1</code>，因此可以直接加上相差的部分。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Diophantine_equation">丢番图方程</a></li><li><a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">扩展欧几里德算法</a></li><li><a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">裴蜀定理</a></li><li><a href="http://www-groups.mcs.st-andrews.ac.uk/~martyn/teaching/1003/1003linearDiophantine.pdf">Linear Diophantine Equation (PDF) Theorem 4.6</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1061/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在Debian上部署GoAgent客户端</title>
      <link>http://hcoona.github.io/Tips/GoAgent-local-on-Debian/</link>
      <guid>http://hcoona.github.io/Tips/GoAgent-local-on-Debian/</guid>
      <pubDate>Wed, 24 Jul 2013 16:00:00 GMT</pubDate>
      
      <description>本文介绍如何在Debian平台上部署GoAgent客户端</description>
      
      
      
      <content:encoded><![CDATA[<p>本文介绍如何在Debian平台上部署GoAgent客户端。</p><ol><li>下载GoAgent。<a href="http://code.google.com/p/goagent/">传送门</a></li><li>解压缩下载到的文件中的Local文件夹，并拷贝到适当的目录中。</li><li>修改proxy.ini文件。</li><li>安装依赖包python-openssl libnss3-tools。</li><li>重建Certificate Database：<ol><li>mkdir -p $HOME&#x2F;.pki&#x2F;nssdb</li><li>certutil -d $HOME&#x2F;.pki&#x2F;nssdb -N (不设定密码)</li></ol></li><li>导入证书certutil -d sql:$HOME&#x2F;.pki&#x2F;nssdb -A -t TC -n GoAgent -i &#x2F;opt&#x2F;GoAgentLocal&#x2F;CA.crt。</li><li>在Firefox或Chrome中导入证书。</li><li>运行python &#x2F;opt&#x2F;GoAgentLocal&#x2F;proxy.py。</li><li>设定代理服务器为自动地址：<a href="http://127.0.0.1:8086/proxy.pac%E3%80%82">http://127.0.0.1:8086/proxy.pac。</a></li></ol><p>如果想要在Gnome3环境下开机自动启动代理程序：</p><ol><li>修改proxy.ini文件，将visible&#x3D;1改为0。</li><li>按Alt+F2输入gnome-session-properties并回车。</li><li>添加项proxy &#x2F;opt&#x2F;GoAgentLocal&#x2F;proxy.py。</li></ol>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      <category domain="http://hcoona.github.io/tags/Linux/">Linux</category>
      
      <category domain="http://hcoona.github.io/tags/Debian/">Debian</category>
      
      
      <comments>http://hcoona.github.io/Tips/GoAgent-local-on-Debian/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>使用 GhostScript 将 PDF 中的指定页面导出为清晰的 PNG 文件</title>
      <link>http://hcoona.github.io/Tips/export-pdf-using-ghostscript/</link>
      <guid>http://hcoona.github.io/Tips/export-pdf-using-ghostscript/</guid>
      <pubDate>Tue, 23 Jul 2013 16:00:00 GMT</pubDate>
      
      <description>通常使用 ImageMagick 导出 PDF 文件为图像，获得的图像通常都不够清晰。GhostScript因为能够解析PDF的底层，从而能够获得更为清晰的图像文件。</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>通常使用ImageMagick导出PDF文件为图像，获得的图像通常都不够清晰。GhostScript因为能够解析PDF的底层，从而能够获得更为清晰的图像文件。</p></div><div class="paragraph"><p>我使用的命令如下：</p></div><div class="listingblock"><div class="content"><pre>gs \ -sDEVICE=png16 \ -o %03d.png \ -dTextAlphaBits=4 \ -dAlignToPixels=1 \ -dFirstPage=1 \ -dLastPage=1 \ -r300 \  file.pdf</pre></div></div><div class="paragraph"><p>解释一下，如果你想导出的页面只有很少的几种颜色，则可以指定DEVICE为png256或者png16减小生成的文件大小，如果导出的页面只有黑白两种颜色，则可以使用pngmono。如果你想导出的页面中包含一张细节十分丰富的图片，那么我建议你使用jpeg格式。通常，如果你想要导出的图片可以打印出来也看的十分清楚，则最好指定DPI为300，否则110足矣。</p></div><div class="sect1"><h2 id="_参考资料">参考资料</h2><div class="sectionbody"><div class="ulist"><ul><li><p><a href="http://stackoverflow.com/questions/5527818/ghost-script-extract-a-single-page-from-a-pdf-and-convert-it-to-a-jpg">http://stackoverflow.com/questions/5527818/ghost-script-extract-a-single-page-from-a-pdf-and-convert-it-to-a-jpg</a></p></li><li><p><a href="http://www.ghostscript.com/doc/current/Use.htm#Rendering_parameters">http://www.ghostscript.com/doc/current/Use.htm#Rendering_parameters</a></p></li><li><p><a href="http://www.ghostscript.com/doc/current/Devices.htm#PNG">http://www.ghostscript.com/doc/current/Devices.htm#PNG</a></p></li></ul></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Tips/">Tips</category>
      
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      
      <comments>http://hcoona.github.io/Tips/export-pdf-using-ghostscript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>尾递归、CPS和将递归转化为循环的一般方法</title>
      <link>http://hcoona.github.io/Functional-Programming/tail-recursion-cps-and-recursion-to-loop/</link>
      <guid>http://hcoona.github.io/Functional-Programming/tail-recursion-cps-and-recursion-to-loop/</guid>
      <pubDate>Wed, 17 Jul 2013 16:00:00 GMT</pubDate>
      
      <description>本文介绍了什么是尾递归，什么是CPS，以及如何应用前两者将递归转化为循环。</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>本文介绍了什么是尾递归，什么是CPS，以及如何应用前两者将递归转化为循环。</p></div><div class="sect1"><h2 id="_尾递归_tail_recursion">尾递归 (Tail Recursion)</h2><div class="sectionbody"><div class="paragraph"><p>在 <a href="http://en.wikipedia.org/">Wikipedia</a> 中是这样定义尾递归的：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>尾部递归是一种编程技巧。递归函数是指一些会在函数内调用自己的函数，如果在递归函数中，递归调用返回的结果总被直接返回，则称为尾部递归。</p></div></blockquote></div><div class="paragraph"><p>尾递归相对于普通的递归有一个_好处_ <a href="#tail-recursion-optimization">[tail-recursion-optimization]</a>：由于在递归调用结束后没有任何其他的操作，直接将递归调用的结果作为当前调用的结果返回，因此不需要保存当前调用栈帧，在递归调用的时候，可以直接修改当前栈帧上的变量。</p></div><div class="paragraph"><p>总的来说，尾递归可以被认为等价于循环。</p></div><div class="paragraph"><p>我们来看一个例子：阶乘函数。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;    <span class="built_in">assert</span> (n &gt;= <span class="number">0</span>);    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);    &#125;&#125;</code></pre></div></div><div class="paragraph"><p>这个函数不是尾递归的，因为它在调用完自己后，还要进行一些操作，比如说乘\(n\)。但是我们可以轻易的将其改写为尾递归的：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">factorial_recursive_aux</span><span class="params">(<span class="type">int</span> acc, <span class="type">int</span> n)</span> </span>&#123;    <span class="keyword">if</span> (n) &#123;        <span class="keyword">return</span> <span class="built_in">factorial_recursive_aux</span>(acc * n, n - <span class="number">1</span>);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> acc;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">factorial_recursive</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;    <span class="built_in">assert</span> (n &gt;= <span class="number">0</span>);    <span class="keyword">return</span> <span class="built_in">factorial_recursive_aux</span>(<span class="number">1</span>, n);&#125;</code></pre></div></div><div class="paragraph"><p>通过引入一个参数`acc`，我们可以将原本在递归调用之后才进行的计算提前到递归调用时，从而将一个普通的递归调用转化为尾递归调用。根据上面提到的_优化原则_ <a href="#tail-recursion-optimization">[tail-recursion-optimization]</a>，我们还可以这样优化这一尾递归调用函数：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">factorial_recursive_opt</span><span class="params">(<span class="type">int</span> acc, <span class="type">int</span> n)</span> </span>&#123;FRO_START:    <span class="keyword">if</span> (n) &#123;        acc *= n;        n--;        <span class="keyword">goto</span> FRO_START;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> acc;    &#125;&#125;</code></pre></div></div><div class="paragraph"><p>容易发现，这样一个函数等价于这样一个循环：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="type">int</span> acc = <span class="number">1</span>;<span class="keyword">for</span> (; n; n--) &#123;    acc *= n;&#125;</code></pre></div></div><div class="paragraph"><p>注意，虽然这里用一个`while (n--)`更为简洁，但是我还是特别写了一个`for`循环以跟上面的代码一一对应。这是因为，在有些情况下，判断和更改变量的步骤更为复杂，此时用一个`while`循环就比较困难了。</p></div><div class="paragraph"><p>可惜将一个递归调用转换为尾递归调用并不总是这么容易。比如下面这个例子：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>);    &#125;&#125;</code></pre></div></div><div class="paragraph"><p>再比如更加复杂的归并排序，快速排序。</p></div><div class="paragraph"><p>因为下面的内容用函数式语言叙述更加方便，所以在此先给出Fibonacci函数对应的用FSharp语言写的代码：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight fsharp"><span class="keyword">let</span> <span class="keyword">rec</span> fibonacci n <span class="operator">=</span>    <span class="keyword">match</span> n <span class="keyword">with</span>    <span class="operator">|</span> _ <span class="keyword">when</span> n <span class="operator">&lt;=</span> <span class="number">0</span> <span class="operator">-&gt;</span> <span class="number">0</span>    <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">-&gt;</span> <span class="number">1</span>    <span class="operator">|</span> _ <span class="operator">-&gt;</span> (fibonacci (n <span class="operator">-</span> <span class="number">1</span>)) <span class="operator">+</span> (fibonacci (n <span class="operator">-</span> <span class="number">2</span>));;</code></pre></div></div></div></div><div class="sect1"><h2 id="_continuation_passing_style_cps">Continuation Passing Style (CPS)</h2><div class="sectionbody"><div class="paragraph"><p>在 <a href="http://en.wikipedia.org/">Wikipedia</a> 中是这样定义CPS的：</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>In functional programming, continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation.</p></div></blockquote></div><div class="paragraph"><p>理论总是那么抽象，我们不妨来看一个例子：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight fsharp"><span class="keyword">let</span> <span class="keyword">rec</span> factorial n <span class="operator">=</span>    <span class="keyword">match</span> n <span class="keyword">with</span>    <span class="operator">|</span> _ <span class="keyword">when</span> n <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">-&gt;</span> <span class="built_in">failwith</span> <span class="string">&quot;n must not be less than 0.&quot;</span>    <span class="operator">|</span> <span class="number">0</span> <span class="operator">-&gt;</span> <span class="number">1</span>    <span class="operator">|</span> _ <span class="operator">-&gt;</span> n <span class="operator">*</span> (factorial (n <span class="operator">-</span> <span class="number">1</span>));;<span class="keyword">let</span> factorial_cps n <span class="operator">=</span>    <span class="keyword">let</span> <span class="keyword">rec</span> factorial_aux n cont <span class="operator">=</span>        <span class="keyword">match</span> n <span class="keyword">with</span>        <span class="operator">|</span> <span class="number">0</span> <span class="operator">-&gt;</span> cont <span class="number">1</span>        <span class="operator">|</span> _ <span class="operator">-&gt;</span> factorial_aux (n <span class="operator">-</span> <span class="number">1</span>) (<span class="keyword">fun</span> acc <span class="operator">-&gt;</span> cont (acc <span class="operator">*</span> n))    <span class="keyword">in</span>    <span class="keyword">if</span> n <span class="operator">&lt;</span> <span class="number">0</span> <span class="keyword">then</span> <span class="built_in">failwith</span> <span class="string">&quot;n must not be less than 0.&quot;</span>    <span class="keyword">else</span> factorial_aux n (<span class="keyword">fun</span> x <span class="operator">-&gt;</span> x);;</code></pre></div></div><div class="paragraph"><p>可以看到，我们将原本会发生在递归调用之后进行的操作——乘`n`，通过Continuation的方式，保留到之后的某一时刻再进行调用（具体于这个例子而言，是在`n = 0`时）。并且在每次递归调用的时候，都将Continuation作为参数之一进行传递。这就是Continuation-passing style。</p></div><div class="paragraph"><p>CPS的好处就是，能够将原本不是尾递归的普通递归调用转化为尾递归形式。至此，如何将一般递归转化为循环的方法，就比较明朗了。</p></div><div class="paragraph"><p>接下来，我们来看一个比较复杂的_例子_ <a href="#lambda">[lambda]</a>：Fibonacci。（这里不考虑使用 <a href="http://en.wikipedia.org/wiki/Dynamic_Programming">动态规划 (Dynamic Programming)</a> 对其进行优化的情况）</p></div><div class="listingblock"><div class="content"><pre><code class="highlight fsharp"><span class="keyword">let</span> fibonacci_cps n <span class="operator">=</span>    <span class="keyword">let</span> <span class="keyword">rec</span> fibonacci_aux n cont <span class="operator">=</span>        <span class="keyword">match</span> n <span class="keyword">with</span>        <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">-&gt;</span> cont <span class="number">1</span>        <span class="operator">|</span> _ <span class="operator">-&gt;</span> fibonacci_aux                    (n <span class="operator">-</span> <span class="number">1</span>)                    (<span class="keyword">fun</span> acc1 <span class="operator">-&gt;</span> fibonacci_aux                                    (n <span class="operator">-</span> <span class="number">2</span>)                                    (<span class="keyword">fun</span> acc2 <span class="operator">-&gt;</span> cont (acc1 <span class="operator">+</span> acc2)))    <span class="keyword">in</span>    <span class="keyword">match</span> n <span class="keyword">with</span>    <span class="operator">|</span> _ <span class="keyword">when</span> n <span class="operator">&lt;=</span> <span class="number">0</span> <span class="operator">-&gt;</span> <span class="number">0</span>    <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">-&gt;</span> <span class="number">1</span>    <span class="operator">|</span> _ <span class="operator">-&gt;</span> fibonacci_aux n (<span class="keyword">fun</span> x <span class="operator">-&gt;</span> x);;</code></pre></div></div><div class="paragraph"><p>回顾一下我们之前写的`fibonacci`函数，我们容易发现，唯一的不同之处就在于，我们使用`fibonacci_aux`函数来完成以前`fibonacci`函数的主要功能（递归）。而`fibonacci_aux`函数与原来的`fibonacci`函数的不同之处，除了没有处理`n &#8656; 0`的情况以外，主要在于使用匿名函数将完成当前语句之后要做的事情作为参数进行传递。这样一来，通过将递归调用之后所做的操作通过参数进行传递，在执行完了所有的递归步骤之后，再进行计算，使得我们将一个复杂的普通递归调用转换成为了尾递归调用。</p></div><div class="paragraph"><p>对于这点不明白的听众，不妨手工展开`n = 4`的情况。</p></div><div class="literalblock"><div class="content"><pre>以下将fibonacci_aux简写为f   f 4 (fun x -&gt; x)=&gt; f 3 (fun x -&gt; f 2 (fun y -&gt; (fun xx -&gt; xx) (x + y)))=&gt; f 3 (fun x -&gt; f 2 (fun y -&gt; x + y))=&gt; f 3 (fun x -&gt; (fun y -&gt; x + y) 1)=&gt; f 3 (fun x -&gt; x + 1)=&gt; f 2 (fun x -&gt; f 1 (fun y -&gt; (fun xx -&gt; xx + 1) (x + y)))=&gt; f 2 (fun x -&gt; (fun y -&gt; (fun xx -&gt; xx + 1) (x + y)) 1)=&gt; f 2 (fun x -&gt; (fun xx -&gt; xx + 1) (x + 1))=&gt; (fun x -&gt; (fun xx -&gt; xx + 1) (x + 1)) 1=&gt; (fun xx -&gt; xx + 1) 2=&gt; 3</pre></div></div></div></div><div class="sect1"><h2 id="_递归转为循环">递归转为循环</h2><div class="sectionbody"><div class="paragraph"><p>到这里，我们至少知道了在函数式编程语言中，如何将一个一般递归调用转换为尾递归调用。下面，我们讨论在C++和C语言中，应该怎么做。</p></div><div class="sect2"><h3 id="_c中的尝试">C++中的尝试</h3><div class="paragraph"><p>对于C++11而言，由于引入了_Lambda_ <a href="#CXX11-lambda">[CXX11-lambda]</a>，使得理论上做这件事的难度和函数式编程语言差不多。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _FContTy&gt;</span><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fibonacci_aux</span><span class="params">(<span class="type">int</span> n, _FContTy cont)</span></span><span class="function"></span>&#123;    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;        <span class="keyword">return</span> <span class="built_in">cont</span>(<span class="number">1</span>);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="built_in">fibonacci_aux</span>(n - <span class="number">1</span>, [=](<span class="type">int</span> acc1) &#123;            <span class="keyword">return</span> <span class="built_in">fibonacci_aux</span>(n - <span class="number">2</span>, [=](<span class="type">int</span> acc2) &#123;                <span class="keyword">return</span> <span class="built_in">cont</span>(acc1 + acc2);            &#125;);        &#125;);    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span></span><span class="function"></span>&#123;    <span class="keyword">return</span> <span class="built_in">fibonacci_aux</span>(n, [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x; &#125;);&#125;</code></pre></div></div><div class="paragraph"><p>但是实际上，这段代码无论是使用_最新版本的VisualStudio_ <a href="#latest-vs">[latest-vs]</a>或者是_最新版本的G++_ <a href="#latest-gxx">[latest-gxx]</a>都无法编译（表现为长时间无响应，占用内存疯狂增长）。但是这并不是编译器的Bug，而是因为这段递归程序在编译时期转换成仿函数(Functor)时会产生一个无穷递归，感兴趣的听众手工模拟一下编译器的工作就能发现这一点。况且实际上最好的情况下，也会有两个fibonacci_aux函数产生（因为有两个不同的lambda作为参数cont），使得生成的代码实际上不是尾递归调用（而是间接尾递归调用）。</p></div><div class="paragraph"><p>编译器不够聪明，没办法处理好这件事，不过我们可以手工来处理这种情况。使用继承和多态的特性，我们可以统一`cont`的类型。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">class</span> <span class="title class_">ContF</span> &#123;<span class="keyword">protected</span>:    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Imp</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>= <span class="number">0</span>;<span class="keyword">public</span>:    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Imp</span>(x); &#125;&#125;;<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, shared_ptr&lt;ContF&gt; cont)</span></span>;<span class="keyword">class</span> <span class="title class_">ContIdentityF</span> : <span class="keyword">public</span> ContF &#123;<span class="keyword">protected</span>:    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Imp</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> x; &#125;&#125;;<span class="keyword">class</span> <span class="title class_">ContInnerF</span> : <span class="keyword">public</span> ContF &#123;<span class="keyword">private</span>:    <span class="type">int</span> x;    shared_ptr&lt;ContF&gt; cont;<span class="keyword">protected</span>:    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Imp</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;        <span class="keyword">return</span> cont-&gt;<span class="built_in">operator</span>() (x + y);    &#125;<span class="keyword">public</span>:    <span class="built_in">ContInnerF</span>(<span class="type">int</span> x, shared_ptr&lt;ContF&gt; cont) : <span class="built_in">x</span>(x), <span class="built_in">cont</span>(cont) &#123; &#125;&#125;;<span class="keyword">class</span> <span class="title class_">ContOuterF</span> : <span class="keyword">public</span> ContF &#123;<span class="keyword">private</span>:    <span class="type">int</span> n;    shared_ptr&lt;ContF&gt; cont;<span class="keyword">protected</span>:    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Imp</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;        <span class="keyword">return</span> <span class="built_in">f</span>(n - <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;ContInnerF&gt;(x, cont));    &#125;<span class="keyword">public</span>:    <span class="built_in">ContOuterF</span>(<span class="type">int</span> n, shared_ptr&lt;ContF&gt; cont) : <span class="built_in">n</span>(n), <span class="built_in">cont</span>(cont) &#123; &#125;&#125;;<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, shared_ptr&lt;ContF&gt; cont)</span> </span>&#123;    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;        <span class="keyword">return</span> cont-&gt;<span class="built_in">operator</span>() (<span class="number">1</span>);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="built_in">f</span>(n - <span class="number">1</span>, <span class="built_in">make_shared</span>&lt;ContOuterF&gt;(n, cont));    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="built_in">f</span>(n, <span class="built_in">make_shared</span>&lt;ContIdentityF&gt;());    &#125;&#125;</code></pre></div></div><div class="paragraph"><p>但是即便是这样，由于我们在仿函数中调用了函数`f`，编译器仍然不会“智能的”帮我们优化这一间接尾递归调用。因此我们还需要更进一步的调整，将仿函数中的函数和数据分开，为进一步整合函数创造条件。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="keyword">enum class</span> <span class="title class_">ContDataType</span> &#123; Identity, Outer, Inner &#125;;<span class="keyword">struct</span> <span class="title class_">ContData</span> &#123;    <span class="type">const</span> ContDataType type;    <span class="type">const</span> <span class="type">int</span> x;    <span class="type">const</span> shared_ptr&lt;ContData&gt; p;    <span class="built_in">ContData</span>(ContDataType type, <span class="type">int</span> x, shared_ptr&lt;ContData&gt; p)        : <span class="built_in">type</span>(type), <span class="built_in">x</span>(x), <span class="built_in">p</span>(p)    &#123;        _ASSERT(type == ContDataType::Outer             || type == ContDataType::Inner);    &#125;    <span class="built_in">ContData</span>()        : <span class="built_in">type</span>(ContDataType::Identity), <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>)    &#123; &#125;&#125;;<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, shared_ptr&lt;ContData&gt; data)</span></span>;<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f_cont</span><span class="params">(<span class="type">int</span> x, shared_ptr&lt;ContData&gt; data)</span> </span>&#123;    <span class="keyword">switch</span> (data-&gt;type)    &#123;    <span class="keyword">case</span> ContDataType::Identity:        <span class="keyword">return</span> x;    <span class="keyword">case</span> ContDataType::Outer:        <span class="keyword">return</span> <span class="built_in">f</span>(            data-&gt;x - <span class="number">2</span>,            <span class="built_in">make_shared</span>&lt;ContData&gt;(ContDataType::Inner, x, data-&gt;p));    <span class="keyword">case</span> ContDataType::Inner:        <span class="keyword">return</span> <span class="built_in">f_cont</span>(data-&gt;x + x, data-&gt;p);    &#125;&#125;<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, shared_ptr&lt;ContData&gt; cont)</span> </span>&#123;    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;        <span class="keyword">return</span> <span class="built_in">f_cont</span>(<span class="number">1</span>, cont);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="built_in">f</span>(            n - <span class="number">1</span>,            <span class="built_in">make_shared</span>&lt;ContData&gt;(ContDataType::Outer, n, cont));    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">return</span> <span class="built_in">f</span>(n, <span class="built_in">make_shared</span>&lt;ContData&gt;());    &#125;&#125;</code></pre></div></div><div class="paragraph"><p>接下来，我们将函数`f`和函数`f_cont`手工合并，并且进行尾递归优化。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, shared_ptr&lt;ContData&gt; cont)</span> </span>&#123;F_START:    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;        n = <span class="number">1</span>;        <span class="keyword">goto</span> CONT_START;    &#125; <span class="keyword">else</span> &#123;        cont = <span class="built_in">make_shared</span>&lt;ContData&gt;(ContDataType::Outer, n, cont);        n--;        <span class="keyword">goto</span> F_START;    &#125;CONT_START:    <span class="keyword">switch</span> (cont-&gt;type)    &#123;    <span class="keyword">case</span> ContDataType::Identity:        <span class="keyword">return</span> n;    <span class="keyword">case</span> ContDataType::Outer: &#123;            <span class="type">int</span> nn = n;            n = cont-&gt;x - <span class="number">2</span>;            cont = <span class="built_in">make_shared</span>&lt;ContData&gt;(ContDataType::Inner, nn, cont-&gt;p);            <span class="keyword">goto</span> F_START;        &#125;    <span class="keyword">case</span> ContDataType::Inner:        n = cont-&gt;x + n;        cont = cont-&gt;p;        <span class="keyword">goto</span> CONT_START;    &#125;&#125;</code></pre></div></div><div class="paragraph"><p>至此，我们完成了C++版本的一般递归调用函数转换为尾递归调用函数的过程。</p></div></div><div class="sect2"><h3 id="_c语言实现">C语言实现</h3><div class="paragraph"><p>C语言甚至还要更困难一些，因为C语言没有`shared_ptr`这样的东西，也没有带有构造函数的`struct`。不过这都不是什么大问题了，下面给出一个C语言的实现。</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">enum</span> &#123; Identity, Outer, Inner &#125;;<span class="keyword">struct</span> <span class="title class_">ContData</span> &#123;    <span class="type">int</span> type;    <span class="type">int</span> x;    <span class="type">int</span> pIdx;&#125;;<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> STACK_SIZE = <span class="number">10000</span>;<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, ContData stack[], <span class="type">int</span> stackTop)</span> </span>&#123;F_START:    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;        n = <span class="number">1</span>;        <span class="keyword">goto</span> CONT_START;    &#125; <span class="keyword">else</span> &#123;        stackTop++;        stack[stackTop].type = Outer;        stack[stackTop].x = n;        stack[stackTop].pIdx = stackTop - <span class="number">1</span>;        n--;        <span class="keyword">goto</span> F_START;    &#125;CONT_START:    <span class="keyword">switch</span> (stack[stackTop].type)    &#123;    <span class="keyword">case</span> Identity:        <span class="keyword">return</span> n;    <span class="keyword">case</span> Outer: &#123;            <span class="type">int</span> nn = n;            n = stack[stackTop].x - <span class="number">2</span>;            stackTop++;            stack[stackTop].type = Inner;            stack[stackTop].x = nn;            stack[stackTop].pIdx = stack[stackTop - <span class="number">1</span>].pIdx;            <span class="keyword">goto</span> F_START;        &#125;    <span class="keyword">case</span> Inner:        n = stack[stackTop].x + n;        stackTop = stack[stackTop].pIdx;        <span class="keyword">goto</span> CONT_START;    &#125;&#125;<span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125; <span class="keyword">else</span> &#123;        ContData stack[STACK_SIZE];        stack[<span class="number">0</span>].type = Identity;        <span class="keyword">return</span> <span class="built_in">f</span>(n, stack, <span class="number">0</span>);    &#125;&#125;</code></pre></div></div><div class="ulist bibliography"><ul class="bibliography"><li><p><a id="tail-recursion-optimization"></a>[tail-recursion-optimization]: Tail call elimination allows procedure calls in tail position to be implemented as efficiently as goto statements, thus allowing efficient structured programming. In the words of Guy L. Steele "in general procedure calls may be usefully thought of as GOTO statements which also pass parameters, and can be uniformly coded as [machine code] JUMP instructions". <a href="http://en.wikipedia.org/wiki/Tail_call#History">See wikipedia</a>.</p></li><li><p><a id="lambda"></a>[lambda]: F#使用`fun`关键字来创建一个匿名函数。 <a href="http://msdn.microsoft.com/en-us/library/dd233201.aspx">See MSDN</a>.</p></li><li><p><a id="CXX11-lambda"></a>[CXX11-lambda]: <a href="http://www.stroustrup.com/C&#43;&#43;11FAQ.html#lambda">See C&#43;&#43;11 FAQ</a>.</p></li><li><p><a id="latest-vs"></a>[latest-vs]: Visual Studio 2012 update 3. CL版本17.00.60610.1.</p></li><li><p><a id="latest-gxx"></a>[latest-gxx]: g++ 4:4.7.2-1 in Debian jessie.</p></li></ul></div></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/Functional-Programming/">Functional Programming</category>
      
      
      <category domain="http://hcoona.github.io/tags/Functional-Programming/">Functional Programming</category>
      
      <category domain="http://hcoona.github.io/tags/Algorithms/">Algorithms</category>
      
      
      <comments>http://hcoona.github.io/Functional-Programming/tail-recursion-cps-and-recursion-to-loop/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Solution to POJ 1009</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1009/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1009/</guid>
      <pubDate>Sun, 30 Jun 2013 16:00:00 GMT</pubDate>
      
      <description>关键在于一定不能使用模拟法，并且要对几种情况进行有效的优化。</description>
      
      
      
      <content:encoded><![CDATA[<p>关键在于一定不能使用模拟法，并且要对几种情况进行有效的优化。</p><p>原题链接：<a href="http://poj.org/problem?id=1009">POJ 1009 Edge Detection</a>。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>题目本身很明确，就不多说了。关键在于输入和输出都是通过RLE的，而且run length还有可能长达 $10^9$。题目对于图像的宽度没有规定范围，所以认为是从1（只有一列像素）到$10^9$（只有一行像素）。题目最后的Hint又说：A brute force solution that attempts to compute an output value for every individual pixel will likely fail due to space or time constraints. 这就构成了一个很强的提示。</p><p>因此，比较明确的有两点：</p><ol><li>不能使用模拟法。</li><li>不能对每一个像素进行计算。</li></ol><h2 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h2><p>首先来看第一点：不能使用模拟法。模拟法是指，使用三个数组分别记录上一行的像素，当前行的像素，以及下一行的像素。由于存在只有一行，长达 $10^9$ 的可能性，因此行不通。</p><p>经过一番思索，可以发现，通过在RLE对上添加上位置信息（比如说index），可以在不展开RLE编码的情况下，得到任意给定位置的像素值。</p><p>接下来再看第二点：不能对每一个像素进行计算。通过仔细的观察Description节中的样例，可以发现有时接下来的若干像素的输出值都等于当前这一像素的计算结果。这种情况发生的条件是，接下来若干像素的相邻的8个像素值都和当前这一像素的相邻的8个像素的值相同。换句话说，他们的上面的邻居都落在同一个RLE对中，下面的邻居也落在同一个RLE对中，并且他们的左右邻居都相等。特别需要注意只有一列像素和只有两列像素的便捷情况。</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>对应着问题一：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExtendedRLE</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="built_in">ExtendedRLE</span>(index, value, length)</span><br><span class="line">        : <span class="built_in">index</span>(index), <span class="built_in">value</span>(value), <span class="built_in">length</span>(length)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ExtendedRLE UP_BOUNDARY_RLE;</span><br><span class="line"><span class="type">const</span> ExtendedRLE LEFT_RIGHT_BOUNDARY_RLE;</span><br><span class="line"><span class="type">const</span> ExtendedRLE DOWN_BOUNDARY_RLE;</span><br><span class="line"></span><br><span class="line">ExtendedRLE pixels[INPUT_RLE_COUNT_MAX];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">ExtendedRLE * <span class="title">GetRLEItByIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;UP_BOUNDARY_RLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index % width == <span class="number">0</span> || (index + <span class="number">1</span>) % width == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;LEFT_RIGHT_BOUNDARY_RLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= EOI) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;DOWN_BOUNDARY_RLE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">upper_bound</span>(</span><br><span class="line">            &amp;pixels[<span class="number">0</span>],</span><br><span class="line">            &amp;pixels[pixelsSize],</span><br><span class="line">            <span class="built_in">ExtendedRLE</span>(index, <span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">            PredByIndex) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应着问题二：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsCurrentInRLEMiddle</span>(surroundingIts, width)) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">GetMinimumSameLength</span>(index, currentIt, surroundingIts, width);</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">        l = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PushOutputValue</span>(stack, outputValue, l);</span><br><span class="line">    index += l;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">PushOutputValue</span>(stack, outputValue, <span class="number">1</span>);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &gt;= currentIt-&gt;index + currentIt-&gt;length) &#123;</span><br><span class="line">    currentIt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsCurrentInRLEMiddle</span><span class="params">(ExtendedRLE * surroundingIts[NEIGHBOURS_COUNT], <span class="type">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (width == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> surroundingIts[SURROUNDING_MIDDLE_UP] == surroundingIts[SURROUNDING_MIDDLE_DOWN];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (width == <span class="number">2</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> surroundingIts[SURROUNDING_LEFT_MIDDLE] == surroundingIts[SURROUNDING_RIGHT_MIDDLE]</span><br><span class="line">        &amp;&amp; surroundingIts[SURROUNDING_LEFT_UP] == surroundingIts[SURROUNDING_MIDDLE_UP]</span><br><span class="line">        &amp;&amp; surroundingIts[SURROUNDING_LEFT_UP] == surroundingIts[SURROUNDING_RIGHT_UP]</span><br><span class="line">        &amp;&amp; surroundingIts[SURROUNDING_LEFT_DOWN] == surroundingIts[SURROUNDING_MIDDLE_DOWN]</span><br><span class="line">        &amp;&amp; surroundingIts[SURROUNDING_LEFT_DOWN] == surroundingIts[SURROUNDING_RIGHT_DOWN];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushOutputValue</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &amp;stack, <span class="type">int</span> value, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack.<span class="built_in">empty</span>() &amp;&amp; stack.<span class="built_in">back</span>().first == value) &#123;</span><br><span class="line">        stack.<span class="built_in">back</span>().second += length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(value, length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意不要立即将结果输出出去，而是要经过一个合并的步骤，以免输出序列中相邻的两个RLE具有相同的像素值。</p><p><a href="/assets/POJ1009.cpp">Code</a></p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1009/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Solution to POJ 1018</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1018/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1018/</guid>
      <pubDate>Tue, 25 Jun 2013 16:00:00 GMT</pubDate>
      
      <description>Enumerate all possible bandwidth would make the problem easier to solve.</description>
      
      
      
      <content:encoded><![CDATA[<p>The problem is on <a href="http://poj.org/problem?id=1018">here</a>.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>There are n group of devices. We should take one and only one device from any group.</p><p>Firstly I think it is another <a href="http://en.wikipedia.org/wiki/Dynamic_programming">Dynamic<br>Programming</a> problem, because<br>what I would choose in each group depends on what I already took in before<br>groups. However, it is not. Because what device I take now would affect the<br>result before. For example, if I took a device with a very low bandwidth, the<br>result before might not be optimal then. If I want to use Dynamic Programming, I<br>have to say, when I already take several devices to make the total price rise to<br>P and bandwidth limited to B, I would choose a optimal device in current group<br>together with the optimal devices I choose before under new limitation P’ and<br>B’. That’s too much complex. What’s worse, the combination of P would be very<br>very large. Under the worst case, it would be $\prod_{0&lt; i \leq n} m_i \leq 100^{100}$.</p><p>Obviously, we cannot use Dynamic Programming to solve this problem. What make it not is we need to judge the optimal with B&#x2F;P, which depends on both B and P, and the B is the minimum of the bandwidths which means it depends on all possible groups.</p><p>However, we now the possible final bandwidths are very limited, with no more<br>than the count of all devices which is $\sum_{0 &lt; i\leq n} m_i \leq 10000$. If we fix the final bandwidth, the problem would turn to find the minimum total price P, which is a very simple problem.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li>Enumerate all possible bandwidths.</li><li>For each possible bandwidth, find the minimum total price P.</li><li>Find the maximum B&#x2F;P for each optimal P and B.</li></ol><p>In the second step, we can follow these steps.</p><ol><li>Sort devices in each group by its bandwidth. (Do only once, hence should be done before second step above.)</li><li>Find the slice of each group whose bandwidth all be equal or greater than specified bandwidth B.</li><li>Find the minimum price P in each sliced group.</li><li>Sum the total price.</li></ol><p>Code is <a href="/assets/POJ1018.cpp">here</a>.</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1018/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Solution to POJ 1019</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1019/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1019/</guid>
      <pubDate>Tue, 25 Jun 2013 16:00:00 GMT</pubDate>
      
      <description>Easy but need more patient.</description>
      
      
      
      <content:encoded><![CDATA[<p>The problem is on <a href="http://poj.org/problem?id=1019">here</a>.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>$$S_k&#x3D;\overline{123\dots k}$$</p><p>$$S_{S_k}&#x3D;\overline{S_1S_2\dots S_k}$$</p><p>If we want to know what digit is on specified position, we need to locate the<br>$S_{S_n}$ which contains what we want, and further need to locate the $S_m$ in $S_{S_n}$ which contains<br>what we want, and finally the $k$ in $S_m$. As a result, we need<br>the length of $S_{S_k}$ and the length of $S_k$.</p><p>$$|S_k|&#x3D;\sum_{1 \leq l \leq k}{l \times \text{Counts of number with $l$ digits}}$$</p><p>$$|S_{S_k}|&#x3D;\sum_{1 \leq l \leq k}{|S_l|}$$</p><p>We can firstly calculate some of $|S_k|$, and then the $|S_{S_k}|$<br>until the maximum value less than<br><a href="http://msdn.microsoft.com/en-us/library/296az74e%28v=vs.110%29.aspx"><strong>INT_MAX</strong></a>.<br>We can use this predication to examine the overflow of add operator: <code>sum + k &lt; sum</code>. As the arrays containing $|S_k|$ and $|S_{S_k}|$ are naturally sorted, we can use binary search to improve the performance. Finally, we just need to know the digit in specified position of a number $k$. It’s a easy job and can be approached by converting $k$ into string and seek its specified position.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>After some experiences, I know only first 31267 of $|S_{S_k}|$ need to be calculated.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNumberCountByBit[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">9</span>, <span class="number">90</span>, <span class="number">900</span>, <span class="number">9000</span>, <span class="number">90000</span>, <span class="number">900000</span>, <span class="number">9000000</span>, <span class="number">90000000</span>, <span class="number">900000000</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MinNumberByBit[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxK = <span class="number">31267</span>;</span><br><span class="line"><span class="type">int</span> LengthOfSkTable[MaxK + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> LengthOfSSkTable[MaxK + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNumberBits</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; number; number /= <span class="number">10</span>) &#123;</span><br><span class="line">        bits++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LengthOfSk</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bits = <span class="built_in">GetNumberBits</span>(k);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bits; i++) &#123;</span><br><span class="line">        sum += i * MaxNumberCountByBit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum += (k - MinNumberByBit[bits] + <span class="number">1</span>) * bits;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>, sum = <span class="number">0</span>; k &lt;= MaxK; k++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">LengthOfSk</span>(k);</span><br><span class="line">        LengthOfSkTable[k] = l;</span><br><span class="line">        LengthOfSSkTable[k] = (sum += l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *previousSSkLengthIt = <span class="built_in">lower_bound</span>(&amp;LengthOfSSkTable[<span class="number">1</span>], &amp;LengthOfSSkTable[MaxK + <span class="number">1</span>], position) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> positionInSk = position - *previousSSkLengthIt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *previousSkLengthIt = <span class="built_in">lower_bound</span>(&amp;LengthOfSkTable[<span class="number">1</span>], &amp;LengthOfSkTable[MaxK + <span class="number">1</span>], positionInSk) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> positionInKK = positionInSk - *previousSkLengthIt;</span><br><span class="line">    <span class="type">int</span> kk = <span class="built_in">distance</span>(&amp;LengthOfSkTable[<span class="number">0</span>], previousSkLengthIt) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; kk;</span><br><span class="line">    <span class="type">char</span> number = ss.<span class="built_in">str</span>().<span class="built_in">at</span>(positionInKK - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Initialize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Solve</span>(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1019/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Solution to POJ 1045</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1045/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1045/</guid>
      <pubDate>Tue, 25 Jun 2013 16:00:00 GMT</pubDate>
      
      <description>The key is to derivate the fomular.</description>
      
      
      
      <content:encoded><![CDATA[<p>The problem is on <a href="http://poj.org/problem?id=1045">here</a>.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>It is hard to go with the direct fomular, because there is no build-in way to<br>calculate a differential. However, we can apporach it with the defination of<br>differential: $\frac{df(x)}{dx} &#x3D; \lim_{\Delta x \to +\infty}\frac{f(x+\Delta x)-f(x)}{\Delta x}$. Usually make $\Delta x$ equal to DOUBLE_EPSILON.</p><p>The first thing we should do is to simplification the fomulars. From $v_1&#x3D;V_S\cos{\omega t}$, $v_2&#x3D;V_R\cos(\omega t + \theta)$, $v_2&#x3D;iR$, and $i&#x3D;C\frac{d(v_1-v_2)}{dt}$, we could come out an equation shown below:</p><p>$$V_R\cos(\omega t+\theta)&#x3D;CR(\frac{d v_1}{dt}-\frac{d v_2}{dt})$$</p><p>After simplification, it would turn into the equation shown below:</p><p>$$V_R\cos(\omega t+\theta)&#x3D;\omega CR[V_R\sin(\omega t+\theta)-V_S\sin{\omega t}]$$</p><p>When $\omega t+\theta&#x3D;0$, it would show us:</p><p>$$V_R&#x3D;\omega CRV_S\sin\theta$$</p><p>When $\omega t&#x3D;0$, it would show us:</p><p>$$V_R\cos\theta&#x3D;\omega CRV_R\sin\theta$$</p><p>which would further lead to $\tan\theta&#x3D;\frac{1}{\omega CR}$.</p><p>As a consequence, we know how to calculate $V_R$.</p><h2 id="Easy-Solution"><a href="#Easy-Solution" class="headerlink" title="Easy Solution"></a>Easy Solution</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> Vs, R, C;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%d&quot;</span>, &amp;Vs, &amp;R, &amp;C, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">double</span> omega;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;omega);</span><br><span class="line">        <span class="type">double</span> CRw = C * R * omega;</span><br><span class="line">        <span class="type">double</span> phi = <span class="built_in">atan</span>(<span class="number">1.0</span> / CRw);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, CRw * Vs * <span class="built_in">sin</span>(phi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Please pay more attention about “… output should be rounded to three digits after the decimal point.”.</p>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1045/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ 的引用类型</title>
      <link>http://hcoona.github.io/PL/reference-type-in-cpp/</link>
      <guid>http://hcoona.github.io/PL/reference-type-in-cpp/</guid>
      <pubDate>Thu, 22 Nov 2012 16:00:00 GMT</pubDate>
      
      <description>&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在翻旧文的时候，发现这么一篇文章：&lt;a href=&quot;http://www.cnblogs.com/icyplayer/archive/2011/06/23/2087965.html&quot;&gt;关于一道C&amp;#43;&amp;#43;笔试题的纠结，学计算机的伤不起啊&lt;/a&gt;。当时可能是觉得
Placement new
的语法&lt;sup class=&quot;footnote&quot;&gt;[&lt;a id=&quot;_footnoteref_1&quot; class=&quot;footnote&quot; href=&quot;#_footnotedef_1&quot; title=&quot;View footnote.&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;比较新鲜，所以印象比较深刻。现在则是觉得那篇文章中的笔试题挺有水准的，于是记一篇文章，特别说明这一问题——C&amp;#43;&amp;#43;
的引用类型。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>在翻旧文的时候，发现这么一篇文章：<a href="http://www.cnblogs.com/icyplayer/archive/2011/06/23/2087965.html">关于一道C&#43;&#43;笔试题的纠结，学计算机的伤不起啊</a>。当时可能是觉得Placement new的语法<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>比较新鲜，所以印象比较深刻。现在则是觉得那篇文章中的笔试题挺有水准的，于是记一篇文章，特别说明这一问题——C&#43;&#43;的引用类型。</p></div><div class="paragraph"><p> <span id="more"></span> </p></div><div class="sect1"><h2 id="_c_的类型默认是值类型">C&#43;&#43; 的类型默认是值类型</h2><div class="sectionbody"><div class="paragraph"><p>C&#43;&#43; 的 class默认是值类型的。我们常常会从内存布局的角度来看待一个值类型。默认情况下，值类型可以复制，也就是说，值类型具有一个拷贝构造函数以及一个拷贝赋值操作符。值类型对象反映的是其内容，当拷贝发生时，总是会产生两个相互独立的对象，修改其中的一个对象不会改变另一个对象的内容。</p></div></div></div><div class="sect1"><h2 id="_c_也可以定义引用类型">C&#43;&#43; 也可以定义引用类型</h2><div class="sectionbody"><div class="paragraph"><p>我们可以通过一定的设置，构造出 C&#43;&#43;的引用类型，这样的类型具有多态的行为方式，从而可以支持面向对象编程。我们总是以实现多态行为为目的来看待引用类型的，比如说其基类是什么，有没有虚函数，等等。我们应当禁用一个引用类型的拷贝构造函数以及拷贝赋值操作符，并且使用虚析构函数。引用类型的对象反映的是其身份——这是对什么对象的引用？因此，引用类型也常被成为多态类型。</p></div></div></div><div class="sect1"><h2 id="_使用_c_定义引用类型">使用 C&#43;&#43; 定义引用类型</h2><div class="sectionbody"><div class="paragraph"><p>虽然C#里面的引用类型用的都是指针或者是引用，但是 C&#43;&#43;中的引用类型并不受此限制。但是在传递一个引用类型的对象时，只能传递引用或指针，而不能传递值，否则与引用类型的意图不符合。</p></div><div class="paragraph"><p>因此我们需要做的就是：</p></div><div class="olist arabic"><ol class="arabic"><li><p><strong>禁用</strong>拷贝构造函数。</p></li><li><p><strong>禁用</strong>拷贝赋值操作符。</p></li><li><p><strong>显式</strong>提供一个构造函数。</p></li><li><p><strong>显式</strong>提供一个<strong>虚</strong>析构函数。</p></li></ol></div><div class="paragraph"><p>示例代码如下所示：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">MyRefType</span>&#123;<span class="keyword">private</span>:    <span class="built_in">MyRefType</span>(<span class="type">const</span> MyRefType &amp;);    MyRefType &amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyRefType &amp;);<span class="keyword">public</span>:    <span class="built_in">MyRefType</span>() &#123; &#125;    <span class="keyword">virtual</span> ~<span class="built_in">MyRefType</span>() &#123; &#125;&#125;;</code></pre></div></div><div class="paragraph"><p>这样一来，我们就定义了一个引用类型的对象<code>MyRefType</code>。注意，<code>MyRefType</code>可以分配在栈上，也可以分配在堆上，这一点是与C#、Java等语言不同的。但是，如果需要传递`MyRefType`的对象，则必须传递引用或者是指针，否则将会出现编译错误：（错误信息依编译器不同而变化）</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>Cannot access private member declared in class <code>MyRefType</code>.</p></div></blockquote></div><div class="paragraph"><p>测试用例如下：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="function">MyRefType <span class="title">CreateMyRefTypeInstance</span><span class="params">()</span></span>;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span><span class="function"></span>&#123;    MyRefType instance1;    MyRefType instance2 = instance1;    MyRefType instance3 = <span class="built_in">CreateMyRefTypeInstance</span>();    <span class="keyword">return</span> <span class="number">0</span>;&#125;</code></pre></div></div><div class="paragraph"><p>其中第 19 行和第 20 行编译时期会报错。</p></div></div></div><div class="sect1"><h2 id="_c11_的新语法">C&#43;&#43;11 的新语法</h2><div class="sectionbody"><div class="paragraph"><p>C&#43;&#43;11中提出了新的语法用于删除默认函数或者是显式提供默认函数。<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>使用了新语法的示例如下：<sup class="footnote" id="_footnote_delete-syntax">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup></p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">MyRefType</span>&#123;    <span class="built_in">MyRefType</span>(<span class="type">const</span> MyRefType &amp;) = <span class="keyword">delete</span>;    MyRefType &amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyRefType &amp;) = <span class="keyword">delete</span>;<span class="keyword">public</span>:    <span class="built_in">MyRefType</span>() = <span class="keyword">default</span>;    <span class="keyword">virtual</span> ~<span class="built_in">MyRefType</span>() = <span class="keyword">default</span>;&#125;;</code></pre></div></div><div class="paragraph"><p>个人认为，使用这种方式来实现引用对象，代码可读性要上一个台阶。</p></div><div class="paragraph"><p>但是 C&#43;&#43;11 提出了一个叫做 Move的新语义，可以用于转移对象的所有权。对此有何影响，还不可知。BjarneStroustrup 的 C&#43;&#43;11 FAQ 中的 control of defaults: move and copy中提到了一些这方面的 <a href="http://www.stroustrup.com/C&#43;&#43;11FAQ.html#default2">建议</a>。</p></div></div></div><div class="sect1"><h2 id="_禁止使用栈分配对象">禁止使用栈分配对象</h2><div class="sectionbody"><div class="paragraph"><p>下面绕来绕去又回到了那个 <a href="http://www.cnblogs.com/icyplayer/archive/2011/06/23/2087965.html">笔试题</a>，即如何禁止使用栈分配对象？一般说来有两种方法：限制访问构造函数或者限制访问析构函数。并且同时，我们应该把这个对象视为一个引用类型的对象，否则我们就可以合理的创建一个在栈上的拷贝。印象中Bjarne Stroustrup 在 <em>The Design and Evolution of C&#43;&#43;</em>中曾经提到过，将析构函数设为 <code>protected</code>（未求证），就像这样：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">HeapOnlyRefType1</span>&#123;<span class="keyword">private</span>:    <span class="built_in">HeapOnlyRefType1</span>(<span class="type">const</span> HeapOnlyRefType1 &amp;);    HeapOnlyRefType1 &amp; <span class="keyword">operator</span>=(<span class="type">const</span> HeapOnlyRefType1 &amp;);<span class="keyword">public</span>:    <span class="built_in">HeapOnlyRefType1</span>() &#123; &#125;    <span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;<span class="keyword">protected</span>:    <span class="keyword">virtual</span> ~<span class="built_in">HeapOnlyRefType1</span>() &#123; &#125;&#125;;</code></pre></div></div><div class="paragraph"><p>这样一来，由于不能使用析构函数，自然就不能在栈上创建该对象了。需要注意的是，该类型的全局变量和临时对象也不能创建，因为它们最终还是要被销毁的，但是编译器却不能使用析构函数。为了避免内存泄漏，我们使用`destory`方法来销毁这一类型的对象。</p></div><div class="paragraph"><p>另一种方式，具有更高的灵活性，也是我比较习惯使用的一种方式，即通过禁用构造函数来限制这一对象，就像这样：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">HeapOnlyRefType2</span>&#123;<span class="keyword">private</span>:    <span class="built_in">HeapOnlyRefType2</span>(<span class="type">const</span> HeapOnlyRefType2 &amp;);    HeapOnlyRefType2 &amp; <span class="keyword">operator</span>=(<span class="type">const</span> HeapOnlyRefType2 &amp;);<span class="keyword">protected</span>:    <span class="built_in">HeapOnlyRefType2</span>() &#123; &#125;<span class="keyword">public</span>:    <span class="function"><span class="type">static</span> HeapOnlyRefType2 * <span class="title">CreateInstance</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HeapOnlyRefType2</span>(); &#125;    <span class="keyword">virtual</span> ~<span class="built_in">HeapOnlyRefType2</span>() &#123; &#125;&#125;;</code></pre></div></div><div class="paragraph"><p>这样一来，今后我们还可以通过修改实例方法，来控制该类型对象的创建。比如说使用单例模式（SingletonPattern）或者其他创建模式，或者使用一些对象策略，比如说缓存，等等。</p></div></div></div><div class="sect1"><h2 id="_参考资料">参考资料</h2><div class="sectionbody"><div class="ulist"><ul><li><p>[1] C&#43;&#43;0x/C&#43;&#43;11 Support in GCC - GNU Project - Free Software Foundation(FSF)[EB/OL]. [2012-11-23].<a href="http://gcc.gnu.org/projects/cxx0x.html" class="bare">http://gcc.gnu.org/projects/cxx0x.html</a>.</p></li><li><p>[2] C&#43;&#43;11 Features (Modern C&#43;&#43;)[EB/OL]. [2012-11-23].<a href="http://msdn.microsoft.com/en-us/library/vstudio/hh567368.aspx" class="bare">http://msdn.microsoft.com/en-us/library/vstudio/hh567368.aspx</a>.</p></li><li><p>[3] 陈皓. C&#43;&#43;11 中值得关注的几大变化（详解）[EB/OL]. [2012-11-23].<a href="http://coolshell.cn/articles/5265.html" class="bare">http://coolshell.cn/articles/5265.html</a>.</p></li><li><p>[4] More C&#43;&#43; Idioms/Requiring or Prohibiting Heap-based Objects[J].Wikibooks, open books for an open world.</p></li><li><p>[5] Placement syntax[J]. Wikipedia, the free encyclopedia, 2012.</p></li><li><p>[6] STROUSTRUP B. The Design and Evolution of C&#43;&#43;[M]. 第1版.Addison-Wesley Professional, 1994.</p></li><li><p>[7] Value Types (Modern C&#43;&#43;)[EB/OL]. [2012-11-23].<a href="http://msdn.microsoft.com/en-us/library/vstudio/hh438479.aspx" class="bare">http://msdn.microsoft.com/en-us/library/vstudio/hh438479.aspx</a>.</p></li><li><p>[8] What’s New for Visual C&#43;&#43; in Visual Studio 2012[EB/OL].[2012-11-23].<a href="http://msdn.microsoft.com/en-us/library/hh409293.aspx" class="bare">http://msdn.microsoft.com/en-us/library/hh409293.aspx</a>.</p></li><li><p>[9] 赵昱. 关于一道C&#43;&#43;笔试题的纠结，学计算机的伤不起啊[EB/OL].[2012-11-23].<a href="http://www.cnblogs.com/icyplayer/archive/2011/06/23/2087965.html" class="bare">http://www.cnblogs.com/icyplayer/archive/2011/06/23/2087965.html</a>.</p></li></ul></div><hr><div class="paragraph"><p><strong>2012/12/3 补充：</strong>现在最新版本的Visual Studio 2012 Update 1已经支持<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>中所提到的语法了。</p></div></div></div><div id="footnotes"><hr><div class="footnote" id="_footnotedef_1"><a href="#_footnoteref_1">1</a>. 见 <a href="http://en.wikipedia.org/wiki/Placement_syntax" class="bare">http://en.wikipedia.org/wiki/Placement_syntax</a></div><div class="footnote" id="_footnotedef_2"><a href="#_footnoteref_2">2</a>. 见<a href="http://coolshell.cn/articles/5265.html">C&#43;&#43;11 中值得关注的几大变化（详解）</a></div><div class="footnote" id="_footnotedef_3"><a href="#_footnoteref_3">3</a>. Visual Studio 的最新版本 2012 仍然<a href="http://msdn.microsoft.com/en-us/library/vstudio/hh567368.aspx">不支持这一语法</a>，但是GCC从4.4开始就<a href="http://gcc.gnu.org/projects/cxx0x.html">支持这一语法</a>了。因此请使用GCC4.4以上的版本来实践这一语法。</div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/PL/">PL</category>
      
      
      <category domain="http://hcoona.github.io/tags/Programming-Language/">Programming Language</category>
      
      <category domain="http://hcoona.github.io/tags/Tips/">Tips</category>
      
      
      <comments>http://hcoona.github.io/PL/reference-type-in-cpp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>POJ 1001 解题分析</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1001/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1001/</guid>
      <pubDate>Fri, 09 Jul 2010 16:00:00 GMT</pubDate>
      
      <description>这道题做了很多很多天，实在是非常不爽。一向最恶心高精度计算的题了，等有空了就写套类库出来，以后碰见就用 =w=</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p>这道题做了很多很多天，实在是非常不爽。一向最恶心高精度计算的题了，等有空了就写套类库出来，以后碰见就用=w=</p></div><div class="paragraph"><p><a href="http://poj.org/problem?id=1001">题目链接</a></p></div><div class="sect1"><h2 id="_解题分析">解题分析</h2><div class="sectionbody"><div class="paragraph"><p>如果不算高精度的话，实际上是一道非常简单的题o(╯□╰)o，看到好多Java的同学用BigDecimal类直接就AC了，⊙﹏⊙b汗。</p></div><div class="paragraph"><p>难度可以说几乎没有，做这道题才发现其实POJ限制相当松啊，内存居然给10M，时间500MS。</p></div><div class="paragraph"><p>个人觉得本着对自己认真负责的原则，该优化的地方还是要优化一下的，而这道题最值得优化的就是乘方部分：</p></div><div class="stemblock"><div class="content">\[R^n =\begin&#123;cases&#125;R \times R^&#123;n-1&#125;,  &amp; \text&#123;if $n$ is odd&#125; \\[2ex]R^&#123;n/2&#125; \times R^&#123;n/2&#125;, &amp; \text&#123;if $n$ is even&#125;\end&#123;cases&#125;\]</div></div><div class="paragraph"><p>这样能够大幅度减少乘法的次数。</p></div><div class="paragraph"><p>由于输入的数既有小数又有整数，为了方便处理，我们可以将所有的输入都转换为整数，并记录小数点的位置；待计算完毕后，再添加上小数点。</p></div><div class="paragraph"><p>下面给出伪代码：</p></div><div class="listingblock"><div class="content"><pre><code class="highlight plain">Procedure R, n Begin    Shift R to get an integer IntR and e which present where the dot is.    IntResult &lt;- BigIntegerPow(IntR, n)    e &lt;- e * n;    Shift IntResult by e bit to get an BigDecimal result.    Trim the result to remove zero at front of integer and zero at end of decimal.End Procedure</code></pre></div></div></div></div><div class="sect1"><h2 id="_优化余地">优化余地</h2><div class="sectionbody"><div class="paragraph"><p>做乘法的时候，可以把乘数分为若干段，分别相乘后再相加。</p></div><div class="paragraph"><p>还可以在一开始转换的时候，就不用字符串存储，而用若干个long分别存储若干段。</p></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>我只能说，这道题的数据和格式要求非常变态，真的非常非常变态╮(╯▽╰)╭。下面给不明真相的同学一套测试数据：</p></div><div class="paragraph"><p><a href="http://files.cnblogs.com/HCOONa/POJ1001TestCase.zip">POJ1001TestCase.zip</a></p></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1001/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>POJ 1002 解题分析</title>
      <link>http://hcoona.github.io/ACM/solution-to-poj-1002/</link>
      <guid>http://hcoona.github.io/ACM/solution-to-poj-1002/</guid>
      <pubDate>Sun, 04 Jul 2010 17:00:00 GMT</pubDate>
      
      <description>这道题使用排序来解决基本上一定会超时，使用二叉查找树来做就可以了</description>
      
      
      
      <content:encoded><![CDATA[<div class="paragraph"><p><a href="http://poj.org/problem?id=1002">题目链接</a></p></div><div class="sect1"><h2 id="_解题分析">解题分析</h2><div class="sectionbody"><div class="paragraph"><p>题目非常简单，可以分为以下三个步骤：</p></div><div class="olist arabic"><ol class="arabic"><li><p>对输入进行翻译（格式化）使之成为标准的电话号码格式XXX-XXXX</p></li><li><p>统计电话号码的出现次数</p></li><li><p>按照字典序升序输出重复出现的电话号码及其重复次数，没有重复的输出"No duplicates."</p></li></ol></div><div class="paragraph"><p>第一个步骤没有什么难度，遇到"-"就跳过，遇到数字直接减"0"就可以了，遇到字母就按照题目中的规则进行Map。</p></div><div class="paragraph"><p>第二个步骤就出现分歧了，大约有以下三种可能：</p></div><div class="olist arabic"><ol class="arabic"><li><p>直接把解析后的电话号码插入到序列容器里，等到扫描完毕后对序列进行排序，然后统计并输出重复的电话号码</p></li><li><p>使用哈希表存放包含电话号码和出现次数的一个数据结构，然后排序输出</p></li><li><p>使用二叉查找树存放包含电话号码和出现次数的一个数据结构，然后遍历并输出</p></li></ol></div><div class="sect2"><h3 id="_排序法">排序法</h3><div class="paragraph"><p>第一种方法最为直接，但是后来我从论坛里看到很多这么做的人都超时了。</p></div><div class="paragraph"><p>个人感觉这种方法不会超时，不知道为什么那么多人卡住了。</p></div><div class="paragraph"><p>使用数组作为容器，快速排序作为排序方法，分析一下时间复杂性：</p></div><div class="paragraph"><p>假设每个输入的电话号码的长度不超过\(m\)，一共有\(n\)个电话号码</p></div><div class="paragraph"><p>则解析一个电话号码的时间为\(O(m)\)，插入的时间为\(O(1)\)，排序的时间为\(O(n\log n)\)，最后统计加输出的时间为\(O(n)\)，</p></div><div class="paragraph"><p>整体时间复杂度为\(T(n)=n(O(m)+O(1))+O(n\log n)+O(n)=O(n\log n)\)</p></div><div class="paragraph"><p>给出伪代码：</p></div><div class="listingblock"><div class="content"><pre>ProcedureBegin    telNumberArray &lt;- empty    For currentLine &lt;- each line of input    Begin        telNumber &lt;- parse tel number from currentLine        push telNumber at the end of telNumberArray    End For    Quick sort telNumberArray    duplicates &lt;- 0    noDuplicates &lt;- true    For i from 1 to n    Begin        If telNumberArray(i – 1) = telNumberArray(i)            duplictates &lt;- duplicates + 1        Else If duplicates &gt; 0        Begin            Print telNumberArray(i – 1) and duplicates            duplicates &lt;- 0            noDuplicates &lt;- false        End If        If duplicates &gt; 0        Begin            Print telNumberArray(i – 1) and duplicates            duplicates &lt;- 0            noDuplicates &lt;- false        End If    End For    If noDuplicates        Print “No duplicates.”End Procedure</pre></div></div></div><div class="sect2"><h3 id="_哈希表">哈希表</h3><div class="paragraph"><p>这是我最先想到的方法，不过在这里用起来感觉还不如其他两种方法爽。</p></div><div class="paragraph"><p>总的来说就是把上一种方法中的数组换成哈希表，用于查找已经存在的电话号码。</p></div><div class="paragraph"><p>哈希函数可以用电话号码右移若干位得到。（位移速度远快于取模运算）</p></div><div class="paragraph"><p>时间复杂度与上一个方法在同一阶上，不过实际上应该会快不少。</p></div></div><div class="sect2"><h3 id="_平衡二叉查找树">平衡二叉查找树</h3><div class="paragraph"><p>在用哈希表解这道题的时候，我注意到一句话："Arrange the output lines by telephone number in ascending lexicographical order."</p></div><div class="paragraph"><p>而二叉查找树遍历时恰好会产生一个有序的输出。</p></div><div class="paragraph"><p>而且二叉查找树的查找性能虽然低于哈希表，但是仍有不俗的表现，因此我觉得用AVL来解这道题是比较好的。</p></div><div class="paragraph"><p>平均插入时间为\(O(n\log n)\)，平均查找时间也为\(O(n\log n)\)，</p></div><div class="paragraph"><p>总的时间复杂度\(T(n) = n(O(m) + O(n\log n) + O(n\log n)) + O(n)\)。</p></div></div></div></div><div class="sect1"><h2 id="_总结">总结</h2><div class="sectionbody"><div class="paragraph"><p>从算法分析的结果来看，第一种方法反而是时空复杂度和实现难度比较优秀的一种解法，事实又一次证明维护有序比一次排序消耗要大得多。</p></div><div class="paragraph"><p>汗，因此用第一种方法实现1002而超时的同学们应该好好检查一下自己的代码~</p></div><div class="paragraph"><p>另外，还有一些同学和我一样，没有注意到"If there are no duplicates in the input print the line:No duplicates."而WA了，在此提醒大家注意审题T_T</p></div></div></div><div class="sect1"><h2 id="_额外补充">额外补充</h2><div class="sectionbody"><div class="paragraph"><p>昨天晚上跟同学聊天，同学提到这道题如果用Trie树一定非常快。汗了，确实没有想到，不过用Trie树绝对是最快的了。对于这道题来说，Trie树插入时间和查找时间都是\(O(1)\)，然后遍历的时候就会得到一个有序的输出，总时间复杂度\(T(n) = n(O(1)) + O(n) = O(n)\)。</p></div><div class="paragraph"><p>对不了解Trie树的同学有一幅图可以说明问题：</p></div><div class="imageblock"><div class="content"><img data-src="//7xis58.com1.z0.glb.clouddn.com/images/blog/trie.png" alt="Trie Tree Sample Image"></div></div></div></div>]]></content:encoded>
      
      
      <category domain="http://hcoona.github.io/categories/ACM/">ACM</category>
      
      
      <category domain="http://hcoona.github.io/tags/ACM/">ACM</category>
      
      <category domain="http://hcoona.github.io/tags/POJ/">POJ</category>
      
      
      <comments>http://hcoona.github.io/ACM/solution-to-poj-1002/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
